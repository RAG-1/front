{"mappings":"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OAEtBsY,CAAS,CAACC,EAAS,CAAGH,EAAMpU,GAE5BsU,CAAS,CAACC,EAAS,CAAGvU,GAK5B,OAAOsU,CACT,CASA,SAASI,EACPL,CAAS,CACTM,CAAY,EAEZ,KAAON,AAAW,OAAXA,GAAiB,CACtB,IAAMO,EAAOzY,EAAyBkY,EAAQM,GAE9C,GAAIC,EAAM,CACR,GAAIA,EAAK5V,GAAG,CACV,OAAOqT,EAAQuC,EAAK5V,GAAG,EAGzB,GAAI,AAAsB,YAAtB,OAAO4V,EAAK5U,KAAK,CACnB,OAAOqS,EAAQuC,EAAK5U,KAAK,CAE7B,CAEAqU,EAAS1C,EAAe0C,EAC1B,CAMA,OAJA,WACE,OAAO,IACT,CAGF,CC3MO,IAAM5O,EAAOmM,EAAO,CACzB,IACA,OACA,UACA,UACA,OACA,UACA,QACA,QACA,IACA,MACA,MACA,MACA,QACA,aACA,OACA,KACA,SACA,SACA,UACA,SACA,OACA,OACA,MACA,WACA,UACA,OACA,WACA,KACA,YACA,MACA,UACA,MACA,SACA,MACA,MACA,KACA,KACA,UACA,KACA,WACA,aACA,SACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,KACA,KACA,OACA,SACA,SACA,KACA,OACA,IACA,MACA,QACA,MACA,MACA,QACA,SACA,KACA,OACA,MACA,OACA,UACA,OACA,WACA,QACA,MACA,OACA,KACA,WACA,SACA,SACA,IACA,UACA,MACA,WACA,IACA,KACA,KACA,OACA,IACA,OACA,UACA,SACA,SACA,QACA,SACA,SACA,OACA,SACA,SACA,QACA,MACA,UACA,MACA,QACA,QACA,KACA,WACA,WACA,QACA,KACA,QACA,OACA,KACA,QACA,KACA,IACA,KACA,MACA,QACA,MACQ,EAEGuD,EAAMvD,EAAO,CACxB,MACA,IACA,WACA,cACA,eACA,eACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,SACA,OACA,IACA,QACA,WACA,QACA,QACA,OACA,iBACA,SACA,OACA,WACA,QACA,OACA,UACA,UACA,WACA,iBACA,OACA,OACA,QACA,SACA,SACA,OACA,WACA,QACA,OACA,QACA,OACA,QACQ,EAEGmD,EAAanD,EAAO,CAC/B,UACA,gBACA,sBACA,cACA,mBACA,oBACA,oBACA,iBACA,eACA,UACA,UACA,UACA,UACA,UACA,iBACA,UACA,UACA,cACA,eACA,WACA,eACA,qBACA,cACA,SACA,eACQ,EAMGoD,EAAgBpD,EAAO,CAClC,UACA,gBACA,SACA,UACA,YACA,mBACA,iBACA,gBACA,gBACA,gBACA,QACA,YACA,OACA,eACA,YACA,UACA,gBACA,SACA,MACA,aACA,UACA,MACQ,EAEGwD,EAASxD,EAAO,CAC3B,OACA,WACA,SACA,UACA,QACA,SACA,KACA,aACA,gBACA,KACA,KACA,QACA,UACA,WACA,QACA,OACA,KACA,SACA,QACA,SACA,OACA,OACA,UACA,SACA,MACA,QACA,MACA,SACA,aACA,cACQ,EAIGsD,EAAmBtD,EAAO,CACrC,UACA,cACA,aACA,WACA,YACA,UACA,UACA,SACA,SACA,QACA,YACA,aACA,iBACA,cACA,OACQ,EAEG7L,EAAO6L,EAAO,CAAC,QAAiB,ECpRhCnM,EAAOmM,EAAO,CACzB,SACA,SACA,QACA,MACA,iBACA,eACA,uBACA,WACA,aACA,UACA,SACA,UACA,cACA,cACA,UACA,OACA,QACA,QACA,QACA,OACA,UACA,WACA,eACA,SACA,cACA,WACA,WACA,UACA,MACA,WACA,0BACA,wBACA,WACA,YACA,UACA,eACA,OACA,MACA,UACA,SACA,SACA,OACA,OACA,WACA,KACA,YACA,YACA,QACA,OACA,QACA,OACA,OACA,UACA,OACA,MACA,MACA,YACA,QACA,SACA,MACA,YACA,WACA,QACA,OACA,QACA,UACA,aACA,SACA,OACA,UACA,UACA,cACA,cACA,UACA,gBACA,sBACA,SACA,UACA,UACA,aACA,WACA,MACA,WACA,MACA,WACA,OACA,OACA,UACA,aACA,QACA,WACA,QACA,OACA,QACA,OACA,UACA,QACA,MACA,SACA,OACA,QACA,UACA,WACA,QACA,YACA,OACA,SACA,SACA,QACA,QACA,OACA,QACA,OACQ,EAEGuD,EAAMvD,EAAO,CACxB,gBACA,aACA,WACA,qBACA,YACA,SACA,gBACA,gBACA,UACA,gBACA,iBACA,QACA,OACA,KACA,QACA,OACA,gBACA,YACA,YACA,QACA,sBACA,8BACA,gBACA,kBACA,KACA,KACA,IACA,KACA,KACA,kBACA,YACA,UACA,UACA,MACA,WACA,YACA,MACA,WACA,OACA,eACA,YACA,SACA,cACA,cACA,gBACA,cACA,YACA,mBACA,eACA,aACA,eACA,cACA,KACA,KACA,KACA,KACA,aACA,WACA,gBACA,oBACA,SACA,OACA,KACA,kBACA,KACA,MACA,YACA,IACA,KACA,KACA,KACA,KACA,UACA,YACA,aACA,WACA,OACA,eACA,iBACA,eACA,mBACA,iBACA,QACA,aACA,aACA,eACA,eACA,cACA,cACA,mBACA,YACA,MACA,OACA,QACA,SACA,OACA,MACA,OACA,aACA,SACA,WACA,UACA,QACA,SACA,cACA,SACA,WACA,cACA,OACA,aACA,sBACA,mBACA,eACA,SACA,gBACA,sBACA,iBACA,IACA,KACA,KACA,SACA,OACA,OACA,cACA,YACA,UACA,SACA,SACA,QACA,OACA,kBACA,QACA,mBACA,mBACA,eACA,cACA,eACA,cACA,aACA,eACA,mBACA,oBACA,iBACA,kBACA,oBACA,iBACA,SACA,eACA,QACA,eACA,iBACA,WACA,cACA,UACA,UACA,YACA,mBACA,cACA,kBACA,iBACA,aACA,OACA,KACA,KACA,UACA,SACA,UACA,aACA,UACA,aACA,gBACA,gBACA,QACA,eACA,OACA,eACA,mBACA,mBACA,IACA,KACA,KACA,QACA,IACA,KACA,KACA,IACA,aACQ,EAEGwD,EAASxD,EAAO,CAC3B,SACA,cACA,QACA,WACA,QACA,eACA,cACA,aACA,aACA,QACA,MACA,UACA,eACA,WACA,QACA,QACA,SACA,OACA,KACA,UACA,SACA,gBACA,SACA,SACA,iBACA,YACA,WACA,cACA,UACA,UACA,gBACA,WACA,WACA,OACA,WACA,WACA,aACA,UACA,SACA,SACA,cACA,gBACA,uBACA,YACA,YACA,aACA,WACA,iBACA,iBACA,YACA,UACA,QACA,QACD,EAEYyD,EAAMzD,EAAO,CACxB,aACA,SACA,cACA,YACA,cACQ,EC/WG0D,EAAgBzD,EAAK,6BACrB0D,EAAW1D,EAAK,yBAChB2D,EAAc3D,EAAK,iBACnB4D,EAAY5D,EAAK,gCACjB6D,EAAY7D,EAAK,kBACjB8D,EAAiB9D,EAC5B,oGAEW+D,EAAoB/D,EAAK,yBACzBgE,EAAkBhE,EAC7B,+DAEWiE,EAAejE,EAAK,W,IHiETwB,E,E,O,M,C,C,U,K,U,E,gB,E,eGhEMxB,EAAK,4B,U,E,a,E,S,E,e,E,kB,E,c,E,Y,C,GCmBnC,IAAMqE,EAAY,CAChBhC,QAAS,EAETnO,KAAM,EAINoQ,uBAAwB,EACxBC,QAAS,EACTC,SAAU,CAIX,EAcKC,EAA4B,SAChCC,CAAsC,CACtCC,CAAoC,EAEpC,GACE,AAAwB,UAAxB,OAAOD,GACP,AAAqC,YAArC,OAAOA,EAAaE,YAAY,CAEhC,OAAO,KAMT,IAAIC,EAAS,KACPC,EAAY,uBACdH,CAAAA,GAAqBA,EAAkBI,YAAY,CAACD,IACtDD,CAAAA,EAASF,EAAkBK,YAAY,CAACF,EAD1C,EAIA,IAAMG,EAAa,YAAeJ,CAAAA,EAAS,IAAMA,EAAS,EAAA,EAE1D,GAAI,CACF,OAAOH,EAAaE,YAAY,CAACK,EAAY,CAC3CC,WAAAA,AAAWtR,GACFA,EAETuR,gBAAAA,AAAgBC,GACPA,CAEV,EACF,CAAC,MAAO3Z,EAAG,CAOV,OAHAuR,QAAQqI,IAAI,CACV,uBAAyBJ,EAAa,0BAEjC,IACT,CACF,EAEMK,EAAkB,WACtB,MAAO,CACLC,wBAAyB,EAAE,CAC3BC,sBAAuB,EAAE,CACzBC,uBAAwB,EAAE,CAC1BC,yBAA0B,EAAE,CAC5BC,uBAAwB,EAAE,CAC1BC,wBAAyB,EAAE,CAC3BC,sBAAuB,EAAE,CACzBC,oBAAqB,EAAE,CACvBC,uBAAwB,EAAA,AACzB,CACH,E,OAihDeC,AA/gDf,SAASA,IAAgD,IA0DnDC,EA1DmBE,EAAqBxE,UAAA3J,MAAA,CAAA2J,GAAAA,AAAAS,KAAAA,IAAAT,SAAA,CAAAS,EAAAA,CAAAT,SAAA,CAAAoe,EAAAA,CAnErC,AAAkB,aAAlB,OAAO5Z,OAAyB,KAAOA,OAoExCC,EAAwBC,AAAAA,GAAqBL,EAAgBK,GAMnE,GAJAD,EAAUE,OAAO,CAAG0Z,QAEpB5Z,EAAUG,OAAO,CAAG,EAAE,CAGpB,CAACJ,GACD,CAACA,EAAO3B,QAAQ,EAChB2B,EAAO3B,QAAQ,CAACgC,QAAQ,GAAKnC,EAAUG,QAAQ,EAC/C,CAAC2B,EAAOM,OAAO,CAMf,OAFAL,EAAUM,WAAW,CAAG,CAAA,EAEjBN,EAGT,GAAI,CAAA,SAAE5B,CAAAA,CAAU,CAAG2B,EAEbQ,EAAmBnC,EACnBoC,EACJD,EAAiBC,aAAkC,CAC/C,CAAA,iBACJC,CAAgB,CAAA,oBAChBC,CAAmB,CAAA,KACnBC,CAAI,CAAA,QACJN,CAAO,CAAA,WACPO,CAAU,CAAA,aACVC,EAAed,EAAOc,YAAY,EAAKd,EAAee,eAAe,CAAA,gBACrEC,CAAe,CAAA,UACfC,CAAS,CAAA,aACT1C,CAAAA,CACD,CAAGyB,EAEEkB,EAAmBZ,EAAQ/b,SAAS,CAEpC4c,GAAYzE,EAAawE,EAAkB,aAC3CE,GAAS1E,EAAawE,EAAkB,UACxCG,GAAiB3E,EAAawE,EAAkB,eAChDI,GAAgB5E,EAAawE,EAAkB,cAC/CK,GAAgB7E,EAAawE,EAAkB,cAQrD,GAAI,AAA+B,YAA/B,OAAOP,EAAoC,CAC7C,IAAMa,EAAWnD,EAASoD,aAAa,CAAC,WACpCD,CAAAA,EAASE,OAAO,EAAIF,EAASE,OAAO,CAACC,aAAa,EACpDtD,CAAAA,EAAWmD,EAASE,OAAO,CAACC,aAAa,AAAbA,CAEhC,CAGA,IAAIC,GAAY,GAEV,CAAA,eACJC,EAAc,CAAA,mBACdC,EAAkB,CAAA,uBAClBC,EAAsB,CAAA,qBACtBC,EAAAA,CACD,CAAG3D,EACE,CAAA,WAAE4D,EAAAA,CAAY,CAAGzB,EAEnBlZ,GAAQ6X,GAKZc,CAAAA,EAAUM,WAAW,CACnB,AAAmB,YAAnB,OAAO/G,GACP,AAAyB,YAAzB,OAAO+H,IACPM,IACAA,AAAsC5F,KAAAA,IAAtC4F,GAAeK,kBAAkB,CAEnC,GAAM,CAAA,cACJ5E,EAAa,CAAA,SACbC,EAAQ,CAAA,YACRC,EAAW,CAAA,UACXC,EAAS,CAAA,UACTC,EAAS,CAAA,kBACTE,EAAiB,CAAA,gBACjBC,EAAe,CAAA,eACfI,EAAAA,CACD,CAAGF,EAEA,CAAEJ,eAAAA,EAAAA,CAAgB,CAAGI,EAQrBqE,GAAe,KACbC,GAAuBxG,EAAS,CAAA,EAAI,IACrCie,KACAA,KACAA,KACAA,KACAA,EACJ,EAGGxX,GAAe,KACbC,GAAuB1G,EAAS,CAAA,EAAI,IACrCke,KACAA,KACAA,KACAA,EACJ,EAQGvX,GAA0Bxe,OAAO6V,IAAI,CACvCvD,EAAO,KAAM,CACXmM,aAAc,CACZC,SAAU,CAAA,EACVC,aAAc,CAAA,EACd1b,WAAY,CAAA,EACZe,MAAO,IACR,EACD4a,mBAAoB,CAClBF,SAAU,CAAA,EACVC,aAAc,CAAA,EACd1b,WAAY,CAAA,EACZe,MAAO,IACR,EACD6a,+BAAgC,CAC9BH,SAAU,CAAA,EACVC,aAAc,CAAA,EACd1b,WAAY,CAAA,EACZe,MAAO,CAAA,CACR,CACF,IAIC8a,GAAc,KAGdC,GAAc,KAGdC,GAAkB,CAAA,EAGlBC,GAAkB,CAAA,EAGlBC,GAA0B,CAAA,EAI1BC,GAA2B,CAAA,EAK3BC,GAAqB,CAAA,EAKrBC,GAAe,CAAA,EAGfC,GAAiB,CAAA,EAGjBC,GAAa,CAAA,EAIbC,GAAa,CAAA,EAMbC,GAAa,CAAA,EAIbC,GAAsB,CAAA,EAItBC,GAAsB,CAAA,EAKtBC,GAAe,CAAA,EAefC,GAAuB,CAAA,EAIvBC,GAAe,CAAA,EAIfC,GAAW,CAAA,EAGXC,GAA0C,CAAA,EAG1CC,GAAkB,KAChBC,GAA0BrI,EAAS,CAAA,EAAI,CAC3C,iBACA,QACA,WACA,OACA,gBACA,OACA,SACA,OACA,KACA,KACA,KACA,KACA,QACA,UACA,WACA,WACA,YACA,SACA,QACA,MACA,WACA,QACA,QACA,QACA,MACD,EAGGsI,GAAgB,KACdC,GAAwBvI,EAAS,CAAA,EAAI,CACzC,QACA,QACA,MACA,SACA,QACA,QACD,EAGGwI,GAAsB,KACpBC,GAA8BzI,EAAS,CAAA,EAAI,CAC/C,MACA,QACA,MACA,KACA,QACA,OACA,UACA,cACA,OACA,UACA,QACA,QACA,QACA,QACD,EAEK0I,GAAmB,qCACnBC,GAAgB,6BAChBC,GAAiB,+BAEnBC,GAAYD,GACZE,GAAiB,CAAA,EAGjBC,GAAqB,KACnBC,GAA6BhJ,EACjC,CAAA,EACA,CAAC0I,GAAkBC,GAAeC,GAAe,CACjD5J,GAGEiK,GAAiCjJ,EAAS,CAAA,EAAI,CAChD,KACA,KACA,KACA,KACA,QACD,EAEGkJ,GAA0BlJ,EAAS,CAAA,EAAI,CAAC,iBAAiB,EAMvDmJ,GAA+BnJ,EAAS,CAAA,EAAI,CAChD,QACA,QACA,OACA,IACA,SACD,EAGGoJ,GAAmD,KACjDC,GAA+B,CAAC,wBAAyB,YAAY,CAEvElJ,GAA2D,KAG3DmJ,GAAwB,KAKtBC,GAAc/G,EAASoD,aAAa,CAAC,QAErC4D,GAAoB,SACxBC,CAAkB,EAElB,OAAOA,aAAqB3c,QAAU2c,aAAqBC,QAC5D,EAQKC,GAAe,WAA0B,IAAhBC,EAAAjK,UAAA3J,MAAA,CAAA,GAAA2J,AAAAS,KAAAA,IAAAT,SAAA,CAAA,EAAA,CAAAA,SAAA,CAAA,EAAA,CAAc,CAAA,EAC3C,GAAI2J,CAAAA,IAAUA,KAAWM,GA6LzB,GAxLI,AAACA,GAAO,AAAe,UAAf,OAAOA,GACjBA,CAAAA,EAAM,CAAA,CAAA,EAIRA,EAAMrJ,EAAMqJ,GASZzJ,GACEiJ,AAAsB,0BARxBA,CAAAA,GAEEC,AAAgE,KAAhEA,GAA6BrP,OAAO,CAAC4P,EAAIR,iBAAiB,EAtC5B,YAwC1BQ,EAAIR,iBAAiB,AAAjBA,EAKJpK,EACAF,EAGNyH,GAAelH,EAAqBuK,EAAK,gBACrC5J,EAAS,CAAA,EAAI4J,EAAIrD,YAAY,CAAEpG,IAC/BqG,GACJC,GAAepH,EAAqBuK,EAAK,gBACrC5J,EAAS,CAAA,EAAI4J,EAAInD,YAAY,CAAEtG,IAC/BuG,GACJqC,GAAqB1J,EAAqBuK,EAAK,sBAC3C5J,EAAS,CAAA,EAAI4J,EAAIb,kBAAkB,CAAE/J,GACrCgK,GACJR,GAAsBnJ,EAAqBuK,EAAK,qBAC5C5J,EACEO,EAAMkI,IACNmB,EAAIC,iBAAiB,CACrB1J,IAEFsI,GACJH,GAAgBjJ,EAAqBuK,EAAK,qBACtC5J,EACEO,EAAMgI,IACNqB,EAAIE,iBAAiB,CACrB3J,IAEFoI,GACJH,GAAkB/I,EAAqBuK,EAAK,mBACxC5J,EAAS,CAAA,EAAI4J,EAAIxB,eAAe,CAAEjI,IAClCkI,GACJpB,GAAc5H,EAAqBuK,EAAK,eACpC5J,EAAS,CAAA,EAAI4J,EAAI3C,WAAW,CAAE9G,IAC9BI,EAAM,CAAA,GACV2G,GAAc7H,EAAqBuK,EAAK,eACpC5J,EAAS,CAAA,EAAI4J,EAAI1C,WAAW,CAAE/G,IAC9BI,EAAM,CAAA,GACV4H,GAAe9I,EAAAA,EAAqBuK,EAAK,iBACrCA,EAAIzB,YAAY,CAEpBhB,GAAkByC,AAAwB,CAAA,IAAxBA,EAAIzC,eAAe,CACrCC,GAAkBwC,AAAwB,CAAA,IAAxBA,EAAIxC,eAAe,CACrCC,GAA0BuC,EAAIvC,uBAAuB,EAAI,CAAA,EACzDC,GAA2BsC,AAAiC,CAAA,IAAjCA,EAAItC,wBAAwB,CACvDC,GAAqBqC,EAAIrC,kBAAkB,EAAI,CAAA,EAC/CC,GAAeoC,AAAqB,CAAA,IAArBA,EAAIpC,YAAY,CAC/BC,GAAiBmC,EAAInC,cAAc,EAAI,CAAA,EACvCG,GAAagC,EAAIhC,UAAU,EAAI,CAAA,EAC/BC,GAAsB+B,EAAI/B,mBAAmB,EAAI,CAAA,EACjDC,GAAsB8B,EAAI9B,mBAAmB,EAAI,CAAA,EACjDH,GAAaiC,EAAIjC,UAAU,EAAI,CAAA,EAC/BI,GAAe6B,AAAqB,CAAA,IAArBA,EAAI7B,YAAY,CAC/BC,GAAuB4B,EAAI5B,oBAAoB,EAAI,CAAA,EACnDC,GAAe2B,AAAqB,CAAA,IAArBA,EAAI3B,YAAY,CAC/BC,GAAW0B,EAAI1B,QAAQ,EAAI,CAAA,EAC3BpG,GAAiB8H,EAAIG,kBAAkB,EAAI7H,EAC3C2G,GAAYe,EAAIf,SAAS,EAAID,GAC7BK,GACEW,EAAIX,8BAA8B,EAAIA,GACxCC,GACEU,EAAIV,uBAAuB,EAAIA,GAEjCvC,GAA0BiD,EAAIjD,uBAAuB,EAAI,CAAA,EAEvDiD,EAAIjD,uBAAuB,EAC3B6C,GAAkBI,EAAIjD,uBAAuB,CAACC,YAAY,GAE1DD,CAAAA,GAAwBC,YAAY,CAClCgD,EAAIjD,uBAAuB,CAACC,YAAY,AAAZA,EAI9BgD,EAAIjD,uBAAuB,EAC3B6C,GAAkBI,EAAIjD,uBAAuB,CAACI,kBAAkB,GAEhEJ,CAAAA,GAAwBI,kBAAkB,CACxC6C,EAAIjD,uBAAuB,CAACI,kBAAkB,AAAlBA,EAI9B6C,EAAIjD,uBAAuB,EAC3B,AACE,WADF,OAAOiD,EAAIjD,uBAAuB,CAACK,8BAA8B,EAGjEL,CAAAA,GAAwBK,8BAA8B,CACpD4C,EAAIjD,uBAAuB,CAACK,8BAA8B,AAA9BA,EAG5BO,IACFH,CAAAA,GAAkB,CAAA,CADpB,EAIIS,IACFD,CAAAA,GAAa,CAAA,CADf,EAKIO,KACF5B,GAAevG,EAAS,CAAA,EAAIie,GAC5BxX,GAAe,EAAE,CACS,CAAA,IAAtB0B,GAAavW,IAAI,GACnBoO,EAASuG,GAAc0X,GACvBje,EAASyG,GAAcyX,IAGA,CAAA,IAArB/V,GAAa7G,GAAG,GAClBtB,EAASuG,GAAc0X,GACvBje,EAASyG,GAAcyX,GACvBle,EAASyG,GAAcyX,IAGO,CAAA,IAA5B/V,GAAajH,UAAU,GACzBlB,EAASuG,GAAc0X,GACvBje,EAASyG,GAAcyX,GACvBle,EAASyG,GAAcyX,IAGG,CAAA,IAAxB/V,GAAa5G,MAAM,GACrBvB,EAASuG,GAAc0X,GACvBje,EAASyG,GAAcyX,GACvBle,EAASyG,GAAcyX,KAKvBtU,EAAII,QAAQ,GACVzD,KAAiBC,IACnBD,CAAAA,GAAehG,EAAMgG,GADvB,EAIAvG,EAASuG,GAAcqD,EAAII,QAAQ,CAAE7J,KAGnCyJ,EAAIK,QAAQ,GACVxD,KAAiBC,IACnBD,CAAAA,GAAelG,EAAMkG,GADvB,EAIAzG,EAASyG,GAAcmD,EAAIK,QAAQ,CAAE9J,KAGnCyJ,EAAIC,iBAAiB,EACvB7J,EAASwI,GAAqBoB,EAAIC,iBAAiB,CAAE1J,IAGnDyJ,EAAIxB,eAAe,GACjBA,KAAoBC,IACtBD,CAAAA,GAAkB7H,EAAM6H,GAD1B,EAIApI,EAASoI,GAAiBwB,EAAIxB,eAAe,CAAEjI,KAI7C8H,IACF1B,CAAAA,EAAY,CAAC,QAAQ,CAAG,CAAA,CAF1B,EAMIkB,IACFzH,EAASuG,GAAc,CAAC,OAAQ,OAAQ,OAAO,EAI7CA,GAAatU,KAAK,GACpB+N,EAASuG,GAAc,CAAC,QAAQ,EAChC,OAAOU,GAAYiD,KAAK,EAGtBN,EAAIO,oBAAoB,CAAE,CAC5B,GAAI,AAA+C,YAA/C,OAAOP,EAAIO,oBAAoB,CAACjH,UAAU,CAC5C,MAAM3D,EACJ,+EAIJ,GAAI,AAAoD,YAApD,OAAOqK,EAAIO,oBAAoB,CAAChH,eAAe,CACjD,MAAM5D,EACJ,oFAQJwG,GAAY9B,AAHZA,CAAAA,EAAqB2F,EAAIO,oBAAoB,AAApBA,EAGMjH,UAAU,CAAC,GAC5C,MAEMe,AAAuB7D,KAAAA,IAAvB6D,GACFA,CAAAA,EAAqBxB,EACnBC,EACAkC,EAHJ,EAQIX,AAAuB,OAAvBA,GAA+B,AAAqB,UAArB,OAAO8B,IACxCA,CAAAA,GAAY9B,EAAmBf,UAAU,CAAC,GAD5C,CAOEnF,CAAAA,GACFA,EAAO6L,GAGTN,GAASM,EACV,EAKKQ,GAAepK,EAAS,CAAA,EAAI,IAC7Bie,KACAA,KACAA,EACJ,EACK5T,GAAkBrK,EAAS,CAAA,EAAI,IAChCie,KACAA,EACJ,EAQK3T,GAAuB,SAAUjK,CAAgB,EACrD,IAAIkK,EAAS7E,GAAcrF,EAIvB,CAACkK,GAAWA,EAAOC,OAAO,EAC5BD,CAAAA,EAAS,CACPE,aAAc5B,GACd2B,QAAS,UACV,CAAA,EAGH,IAAMA,EAAU1L,EAAkBuB,EAAQmK,OAAO,EAC3CE,EAAgB5L,EAAkByL,EAAOC,OAAO,QAEtD,CAAI,CAACzB,EAAkB,CAAC1I,EAAQoK,YAAY,CAAC,GAIzCpK,EAAQoK,YAAY,GAAK9B,GAI3B,AAAI4B,EAAOE,YAAY,GAAK7B,GACnB4B,AAAY,QAAZA,EAMLD,EAAOE,YAAY,GAAK/B,GAExB8B,AAAY,QAAZA,GACCE,CAAAA,AAAkB,mBAAlBA,GACCzB,EAA8B,CAACyB,EAAc,AAAdA,EAM9BC,CAAAA,CAAQP,EAAY,CAACI,EAAQ,CAGlCnK,EAAQoK,YAAY,GAAK/B,GAI3B,AAAI6B,EAAOE,YAAY,GAAK7B,GACnB4B,AAAY,SAAZA,EAKLD,EAAOE,YAAY,GAAK9B,GACnB6B,AAAY,SAAZA,GAAsBtB,EAAuB,CAACwB,EAAc,CAK9DC,CAAAA,CAAQN,EAAe,CAACG,EAAQ,CAGrCnK,EAAQoK,YAAY,GAAK7B,GAI3B,AACE2B,CAAAA,EAAOE,YAAY,GAAK9B,KACxB,CAACO,EAAuB,CAACwB,EAAc,AAAdA,GAMzBH,CAAAA,EAAOE,YAAY,GAAK/B,KACxB,CAACO,EAA8B,CAACyB,EAAc,AAAdA,GAQhC,CAACL,EAAe,CAACG,EAAQ,EACxBrB,CAAAA,EAA4B,CAACqB,EAAQ,EAAI,CAACJ,EAAY,CAACI,EAAQ,AAARA,EAM1DpB,AAAsB,0BAAtBA,MACAL,EAAkB,CAAC1I,EAAQoK,YAAY,CAAC,CAU3C,EAOKG,GAAe,SAAUC,CAAU,EACvCjM,EAAUwF,EAAUG,OAAO,CAAE,CAAElE,QAASwK,CAAM,GAE9C,GAAI,CAEFnF,GAAcmF,GAAMC,WAAW,CAACD,EACjC,CAAC,MAAOphB,EAAG,CACV8b,GAAOsF,EACT,CACD,EAQKE,GAAmB,SAAUnO,CAAY,CAAEyD,CAAgB,EAC/D,GAAI,CACFzB,EAAUwF,EAAUG,OAAO,CAAE,CAC3ByG,UAAW3K,EAAQ4K,gBAAgB,CAACrO,GACpCsO,KAAM7K,CACP,EACF,CAAC,MAAO5W,EAAG,CACVmV,EAAUwF,EAAUG,OAAO,CAAE,CAC3ByG,UAAW,KACXE,KAAM7K,CACP,EACH,CAKA,GAHAA,EAAQ8K,eAAe,CAACvO,GAGpBA,AAAS,OAATA,EACF,GAAIgL,IAAcC,GAChB,GAAI,CACF+C,GAAavK,EACf,CAAE,MAAO5W,EAAG,CAAA,MAEZ,GAAI,CACF4W,EAAQ+K,YAAY,CAACxO,EAAM,GAC7B,CAAE,MAAOnT,EAAG,CAAA,CAGjB,EAQK4hB,GAAgB,SAAUC,CAAa,EAE3C,IAAIC,EAAM,KACNC,EAAoB,KAExB,GAAI7D,GACF2D,EAAQ,oBAAsBA,MACzB,CAEL,IAAMG,EAAUxM,EAAYqM,EAAO,eACnCE,EAAoBC,GAAWA,CAAO,CAAC,EAAE,AAC3C,CAGErC,AAAsB,0BAAtBA,IACAP,KAAcD,IAGd0C,CAAAA,EACE,iEACAA,EACA,gBAHFA,EAMF,IAAMI,EAAezH,EACjBA,EAAmBf,UAAU,CAACoI,GAC9BA,EAKJ,GAAIzC,KAAcD,GAChB,GAAI,CACF2C,EAAM,IAAInG,IAAYuG,eAAe,CAACD,EAActC,GACtD,CAAE,MAAO3f,EAAG,CAAA,CAId,GAAI,CAAC8hB,GAAO,CAACA,EAAIK,eAAe,CAAE,CAChCL,EAAMvF,GAAe6F,cAAc,CAAChD,GAAW,WAAY,MAC3D,GAAI,CACF0C,EAAIK,eAAe,CAACE,SAAS,CAAGhD,GAC5B/C,GACA2F,CACL,CAAC,MAAOjiB,EAAG,CACV,CAEJ,CAEA,IAAMsiB,EAAOR,EAAIQ,IAAI,EAAIR,EAAIK,eAAe,OAU5C,CARIN,GAASE,GACXO,EAAKC,YAAY,CACfxJ,EAASyJ,cAAc,CAACT,GACxBO,EAAKG,UAAU,CAAC,EAAE,EAAI,MAKtBrD,KAAcD,IACTzC,GAAqBja,IAAI,CAC9Bqf,EACA9D,GAAiB,OAAS,OAC3B,CAAC,EAAE,CAGCA,GAAiB8D,EAAIK,eAAe,CAAGG,CAC/C,EAQKI,GAAsB,SAAU9H,CAAU,EAC9C,OAAO4B,GAAmB/Z,IAAI,CAC5BmY,EAAKyB,aAAa,EAAIzB,EACtBA,EAEAW,EAAWoH,YAAY,CACrBpH,EAAWqH,YAAY,CACvBrH,EAAWsH,SAAS,CACpBtH,EAAWuH,2BAA2B,CACtCvH,EAAWwH,kBAAkB,CAC/B,KAEH,EAQKC,GAAe,SAAUpM,CAAgB,EAC7C,OACEA,aAAmB8E,GAClB,CAAA,AAA4B,UAA5B,OAAO9E,EAAQqM,QAAQ,EACtB,AAA+B,UAA/B,OAAOrM,EAAQsM,WAAW,EAC1B,AAA+B,YAA/B,OAAOtM,EAAQyK,WAAW,EAC1B,CAAEzK,CAAAA,EAAQuM,UAAU,YAAY3H,CAAAA,GAChC,AAAmC,YAAnC,OAAO5E,EAAQ8K,eAAe,EAC9B,AAAgC,YAAhC,OAAO9K,EAAQ+K,YAAY,EAC3B,AAAgC,UAAhC,OAAO/K,EAAQoK,YAAY,EAC3B,AAAgC,YAAhC,OAAOpK,EAAQ2L,YAAY,EAC3B,AAAiC,YAAjC,OAAO3L,EAAQwM,aAAa,AAAK,CAEtC,EAQKC,GAAU,SAAU3gB,CAAc,EACtC,MAAO,AAAgB,YAAhB,OAAO4Y,GAAuB5Y,aAAiB4Y,CACvD,EAED,SAASgI,GAOPthB,CAAU,CAAEuhB,CAA6B,CAAEC,CAAsB,EACjE1O,EAAa9S,EAAQyhB,AAAAA,IACnBA,EAAKhhB,IAAI,CAACkY,EAAW4I,EAAaC,EAAM3D,GAC1C,EACF,CAWA,IAAM6D,GAAoB,SAAUH,CAAgB,EAClD,IAAInH,EAAU,KAMd,GAHAkH,GAActhB,GAAMkY,sBAAsB,CAAEqJ,EAAa,MAGrDP,GAAaO,GAEf,OADApC,GAAaoC,GACN,CAAA,EAIT,IAAMxC,EAAUrK,GAAkB6M,EAAYN,QAAQ,EAStD,GANAK,GAActhB,GAAMqY,mBAAmB,CAAEkJ,EAAa,CACpDxC,QAAAA,EACA4C,YAAa7G,EACd,GAICiB,IACAwF,EAAYH,aAAa,IACzB,CAACC,GAAQE,EAAYK,iBAAiB,GACtC/N,EAAW,WAAY0N,EAAYlB,SAAS,GAC5CxM,EAAW,WAAY0N,EAAYL,WAAW,GAO5CK,EAAYxI,QAAQ,GAAKnC,EAAUC,sBAAsB,EAO3DkF,IACAwF,EAAYxI,QAAQ,GAAKnC,EAAUE,OAAO,EAC1CjD,EAAW,UAAW0N,EAAYC,IAAI,EAbtC,OADArC,GAAaoC,GACN,CAAA,EAoBT,GAAI,CAACzG,EAAY,CAACiE,EAAQ,EAAIvD,EAAW,CAACuD,EAAQ,CAAE,CAElD,GAAI,CAACvD,EAAW,CAACuD,EAAQ,EAAI8C,GAAsB9C,KAE/C7D,GAAwBC,YAAY,YAAY9Z,QAChDwS,EAAWqH,GAAwBC,YAAY,CAAE4D,IAMjD7D,GAAwBC,YAAY,YAAY8C,UAChD/C,GAAwBC,YAAY,CAAC4D,IALrC,MAAO,CAAA,EAYX,GAAIvC,IAAgB,CAACG,EAAe,CAACoC,EAAQ,CAAE,CAC7C,IAAM+C,EAAa7H,GAAcsH,IAAgBA,EAAYO,UAAU,CACjErB,EAAazG,GAAcuH,IAAgBA,EAAYd,UAAU,CAEvE,GAAIA,GAAcqB,EAAY,CAC5B,IAAMC,EAAatB,EAAWlW,MAAM,CAEpC,IAAK,IAAIvJ,EAAI+gB,EAAa,EAAG/gB,GAAK,EAAG,EAAEA,EAAG,CACxC,IAAMghB,EAAanI,GAAU4G,CAAU,CAACzf,EAAE,CAAE,CAAA,EAC5CghB,CAAAA,EAAWC,cAAc,CAAIV,AAAAA,CAAAA,EAAYU,cAAc,EAAI,CAAA,EAAK,EAChEH,EAAWvB,YAAY,CAACyB,EAAYjI,GAAewH,GACrD,CACF,CACF,CAGA,OADApC,GAAaoC,GACN,CAAA,CACT,QAGA,AAAIA,aAAuBvI,GAAW,CAAC6F,GAAqB0C,IAOzDxC,AAAAA,CAAAA,AAAY,aAAZA,GACCA,AAAY,YAAZA,GACAA,AAAY,aAAZA,CAAY,GACdlL,EAAW,8BAA+B0N,EAAYlB,SAAS,GAT/DlB,GAAaoC,GACN,CAAA,IAeLzF,IAAsByF,EAAYxI,QAAQ,GAAKnC,EAAUnQ,IAAI,GAE/D2T,EAAUmH,EAAYL,WAAW,CAEjCpO,EAAa,CAACkD,GAAeC,GAAUC,GAAY,CAAGgM,AAAAA,IACpD9H,EAAU3G,EAAc2G,EAAS8H,EAAM,IACzC,GAEIX,EAAYL,WAAW,GAAK9G,IAC9BjH,EAAUwF,EAAUG,OAAO,CAAE,CAAElE,QAAS2M,EAAY1H,SAAS,EAAE,GAC/D0H,EAAYL,WAAW,CAAG9G,IAK9BkH,GAActhB,GAAM+X,qBAAqB,CAAEwJ,EAAa,MAEjD,CAAA,EACR,EAWKY,GAAoB,SACxBC,CAAa,CACbC,CAAc,CACd3hB,CAAa,EAGb,GACE4b,IACC+F,CAAAA,AAAW,OAAXA,GAAmBA,AAAW,SAAXA,CAAW,GAC9B3hB,CAAAA,KAASqW,GAAYrW,KAASod,EAAAA,EAE/B,MAAO,CAAA,EAOT,GACEnC,IACA,CAACF,EAAW,CAAC4G,EAAO,EACpBxO,EAAWsC,GAAWkM,SAGjB,GAAI3G,IAAmB7H,EAAWuC,GAAWiM,SAG7C,GAAI,CAACrH,EAAY,CAACqH,EAAO,EAAI5G,EAAW,CAAC4G,EAAO,CACrD,CAAA,IAIGR,CAAAA,GAAsBO,IACnBlH,CAAAA,GAAwBC,YAAY,YAAY9Z,QAChDwS,EAAWqH,GAAwBC,YAAY,CAAEiH,IAChDlH,GAAwBC,YAAY,YAAY8C,UAC/C/C,GAAwBC,YAAY,CAACiH,EAAAA,GACvClH,CAAAA,GAAwBI,kBAAkB,YAAYja,QACtDwS,EAAWqH,GAAwBI,kBAAkB,CAAE+G,IACtDnH,GAAwBI,kBAAkB,YAAY2C,UACrD/C,GAAwBI,kBAAkB,CAAC+G,EAAAA,GAGhDA,AAAW,OAAXA,GACCnH,GAAwBK,8BAA8B,EACpDL,CAAAA,GAAwBC,YAAY,YAAY9Z,QAChDwS,EAAWqH,GAAwBC,YAAY,CAAEza,IAChDwa,GAAwBC,YAAY,YAAY8C,UAC/C/C,GAAwBC,YAAY,CAACza,EAAAA,CAAK,EAKhD,MAAO,CAAA,CAAP,MAGG,GAAIqc,EAAmB,CAACsF,EAAO,OAI/B,GACLxO,EAAWwC,GAAgB5C,EAAc/S,EAAO6V,GAAiB,WAK5D,GACJ8L,AAAAA,CAAAA,AAAW,QAAXA,GAAoBA,AAAW,eAAXA,GAA2BA,AAAW,SAAXA,CAAW,GAC3DD,AAAU,WAAVA,GACA1O,AAAkC,IAAlCA,EAAchT,EAAO,UACrBmc,EAAa,CAACuF,EAAM,OAMf,GACLxG,IACA,CAAC/H,EAAWyC,GAAmB7C,EAAc/S,EAAO6V,GAAiB,WAIhE,GAAI7V,EACT,MAAO,CAAA,EAMT,MAAO,CAAA,CACR,EAUKmhB,GAAwB,SAAU9C,CAAe,EACrD,MAAOA,AAAY,mBAAZA,GAAgCvL,EAAYuL,EAASpI,GAC7D,EAYK2L,GAAsB,SAAUf,CAAoB,EAExDD,GAActhB,GAAMiY,wBAAwB,CAAEsJ,EAAa,MAE3D,GAAM,CAAA,WAAEJ,CAAAA,CAAY,CAAGI,EAGvB,GAAI,CAACJ,GAAcH,GAAaO,GAC9B,OAGF,IAAMgB,EAAY,CAChBC,SAAU,GACVC,UAAW,GACXC,SAAU,CAAA,EACVC,kBAAmB3H,GACnB4H,cAAejO,KAAAA,CAChB,EACGrU,EAAI6gB,EAAW5W,MAAM,CAGzB,KAAOjK,KAAK,CAEV,GAAM,CAAA,KAAE6Q,CAAI,CAAA,aAAE6N,CAAY,CAAEte,MAAO+hB,CAAAA,CAAW,CADjCtB,CAAU,CAAC7gB,EAAE,CAEpB+hB,EAAS3N,GAAkBvD,GAG7BzQ,EAAQyQ,AAAS,UAATA,EADMsR,EACyB9O,EADzB8O,GAuBlB,GAnBAF,EAAUC,QAAQ,CAAGH,EACrBE,EAAUE,SAAS,CAAG/hB,EACtB6hB,EAAUG,QAAQ,CAAG,CAAA,EACrBH,EAAUK,aAAa,CAAGjO,KAAAA,EAC1B2M,GAActhB,GAAMoY,qBAAqB,CAAEmJ,EAAagB,GACxD7hB,EAAQ6hB,EAAUE,SAAS,CAKvBlG,IAAyB8F,CAAAA,AAAW,OAAXA,GAAmBA,AAAW,SAAXA,CAAW,IAEzD/C,GAAiBnO,EAAMoQ,GAGvB7gB,EAAQmiB,AAt9BsB,gBAs9BQniB,GAIpCqb,IAAgBlI,EAAW,gCAAiCnT,GAAQ,CACtE4e,GAAiBnO,EAAMoQ,GACvB,QACF,CAGA,GAAIgB,EAAUK,aAAa,CACzB,SAIF,GAAI,CAACL,EAAUG,QAAQ,EAMnB,CAAC7G,IAA4BhI,EAAW,OAAQnT,GAN3B,CACvB4e,GAAiBnO,EAAMoQ,GACvB,QACF,CASIzF,IACFhJ,EAAa,CAACkD,GAAeC,GAAUC,GAAY,CAAGgM,AAAAA,IACpDxhB,EAAQ+S,EAAc/S,EAAOwhB,EAAM,IACrC,GAIF,IAAME,EAAQ1N,GAAkB6M,EAAYN,QAAQ,EACpD,GAAI,CAACkB,GAAkBC,EAAOC,EAAQ3hB,GAAQ,CAC5C4e,GAAiBnO,EAAMoQ,GACvB,QACF,CAGA,GACE/I,GACA,AAAwB,UAAxB,OAAOvB,GACP,AAAyC,YAAzC,OAAOA,EAAa6L,gBAAgB,CAEpC,GAAI9D,QAGF,OAAQ/H,EAAa6L,gBAAgB,CAACV,EAAOC,IAC3C,IAAK,cACH3hB,EAAQ8X,EAAmBf,UAAU,CAAC/W,GACtC,KAGF,KAAK,mBACHA,EAAQ8X,EAAmBd,eAAe,CAAChX,EAO/C,CAKJ,GAAIA,IAvFc+hB,EAwFhB,GAAI,CACEzD,EACFuC,EAAYwB,cAAc,CAAC/D,EAAc7N,EAAMzQ,GAG/C6gB,EAAY5B,YAAY,CAACxO,EAAMzQ,GAG7BsgB,GAAaO,GACfpC,GAAaoC,GAEbrO,EAASyF,EAAUG,OAAO,CAE7B,CAAC,MAAO9a,EAAG,CACVshB,GAAiBnO,EAAMoQ,EACzB,CAEJ,CAGAD,GAActhB,GAAM8X,uBAAuB,CAAEyJ,EAAa,KAC3D,EAOKyB,GAAqB,SAArBA,EAA+BC,CAA0B,EAC7D,IAAIC,EAAa,KACXC,EAAiBzC,GAAoBuC,GAK3C,IAFA3B,GAActhB,GAAMmY,uBAAuB,CAAE8K,EAAU,MAE/CC,EAAaC,EAAeC,QAAQ,IAE1C9B,GAActhB,GAAMsY,sBAAsB,CAAE4K,EAAY,MAGxDxB,GAAkBwB,GAGlBZ,GAAoBY,GAGhBA,EAAW9I,OAAO,YAAYhB,GAChC4J,EAAmBE,EAAW9I,OAAO,EAKzCkH,GAActhB,GAAMgY,sBAAsB,CAAEiL,EAAU,KACvD,EAkOD,OA/NAtK,EAAU0K,QAAQ,CAAG,SAAUxD,CAAK,EAAU,IAAR1B,EAAGjK,UAAA3J,MAAA,CAAA,GAAA2J,AAAAS,KAAAA,IAAAT,SAAA,CAAA,EAAA,CAAAA,SAAA,CAAA,EAAA,CAAG,CAAA,EACtCoM,EAAO,KACPgD,EAAe,KACf/B,EAAc,KACdgC,EAAa,KAUjB,GALIlG,AADJA,CAAAA,GAAiB,CAACwC,CAD2C,GAG3DA,CAAAA,EAAQ,aADV,EAKI,AAAiB,UAAjB,OAAOA,GAAsB,CAACwB,GAAQxB,GACxC,GAAI,AAA0B,YAA1B,OAAOA,EAAMnO,QAAQ,CAEvB,CAAA,GAAI,AAAiB,UAAjB,MADJmO,CAAAA,EAAQA,EAAMnO,QAAQ,EAAtBmO,EAEE,MAAM/L,EAAgB,kCADxB,MAIA,MAAMA,EAAgB,8BAK1B,GAAI,CAAC6E,EAAUM,WAAW,CACxB,OAAO4G,EAgBT,GAZI,AAAC5D,IACHiC,GAAaC,GAIfxF,EAAUG,OAAO,CAAG,EAAE,CAGlB,AAAiB,UAAjB,OAAO+G,GACTpD,CAAAA,GAAW,CAAA,CAFb,EAKIA,GAEF,CAAA,GAAKoD,EAAeoB,QAAQ,CAAE,CAC5B,IAAMlC,EAAUrK,GAAmBmL,EAAeoB,QAAQ,EAC1D,GAAI,CAACnG,EAAY,CAACiE,EAAQ,EAAIvD,EAAW,CAACuD,EAAQ,CAChD,MAAMjL,EACJ,0DAGN,CAAA,MACK,GAAI+L,aAAiBvG,EAMxBgK,AAFFA,CAAAA,EAAehD,AADfA,CAAAA,EAAOV,GAAc,gBADsB,EAEvBvF,aAAa,CAACM,UAAU,CAACkF,EAAO,CAAA,EAApDyD,EAEevK,QAAQ,GAAKnC,EAAUhC,OAAO,EAC3C0O,AAA0B,SAA1BA,EAAarC,QAAQ,EAIZqC,AAA0B,SAA1BA,EAAarC,QAAQ,CAC9BX,EAAOgD,EAGPhD,EAAKkD,WAAW,CAACF,OAEd,CAEL,GACE,CAACnH,IACD,CAACL,IACD,CAACE,IAED6D,AAAuB,KAAvBA,EAAMtR,OAAO,CAAC,KAEd,OAAOiK,GAAsB6D,GACzB7D,EAAmBf,UAAU,CAACoI,GAC9BA,EAON,GAAI,CAHJS,CAAAA,EAAOV,GAAcC,EADrB,EAKE,OAAO1D,GAAa,KAAOE,GAAsB/B,GAAY,EAEjE,CAGIgG,GAAQpE,IACViD,GAAamB,EAAKmD,UAAU,EAI9B,IAAMC,EAAehD,GAAoBjE,GAAWoD,EAAQS,GAG5D,KAAQiB,EAAcmC,EAAaN,QAAQ,IAEzC1B,GAAkBH,GAGlBe,GAAoBf,GAGhBA,EAAYnH,OAAO,YAAYhB,GACjC4J,GAAmBzB,EAAYnH,OAAO,EAK1C,GAAIqC,GACF,OAAOoD,EAIT,GAAI1D,GAAY,CACd,GAAIC,GAGF,IAFAmH,EAAa9I,GAAuBha,IAAI,CAAC6f,EAAKjG,aAAa,EAEpDiG,EAAKmD,UAAU,EAEpBF,EAAWC,WAAW,CAAClD,EAAKmD,UAAU,OAGxCF,EAAajD,EAcf,MAXItF,CAAAA,GAAa2I,UAAU,EAAI3I,GAAa4I,cAAc,AAAdA,GAQ1CL,CAAAA,EAAa5I,GAAWla,IAAI,CAACyY,EAAkBqK,EAAY,CAAA,EADzD,EAIGA,CACT,CAEA,IAAIM,EAAiB7H,GAAiBsE,EAAKwD,SAAS,CAAGxD,EAAKD,SAAS,CAsBrE,OAlBErE,IACAlB,EAAY,CAAC,WAAW,EACxBwF,EAAKjG,aAAa,EAClBiG,EAAKjG,aAAa,CAAC0J,OAAO,EAC1BzD,EAAKjG,aAAa,CAAC0J,OAAO,CAAC5S,IAAI,EAC/B0C,EAAW4C,EAA0B6J,EAAKjG,aAAa,CAAC0J,OAAO,CAAC5S,IAAI,GAEpE0S,CAAAA,EACE,aAAevD,EAAKjG,aAAa,CAAC0J,OAAO,CAAC5S,IAAI,CAAG,MAAQ0S,CAV7D,EAcI/H,IACFhJ,EAAa,CAACkD,GAAeC,GAAUC,GAAY,CAAGgM,AAAAA,IACpD2B,EAAiBpQ,EAAcoQ,EAAgB3B,EAAM,IACvD,GAGK1J,GAAsB6D,GACzB7D,EAAmBf,UAAU,CAACoM,GAC9BA,CACL,EAEDlL,EAAUqL,SAAS,CAAG,WAAkB,IAAR7F,EAAGjK,UAAA3J,MAAA,CAAA,GAAA2J,AAAAS,KAAAA,IAAAT,SAAA,CAAA,EAAA,CAAAA,SAAA,CAAA,EAAA,CAAG,CAAA,EACpCgK,GAAaC,GACblC,GAAa,CAAA,CACd,EAEDtD,EAAUsL,WAAW,CAAG,WACtBpG,GAAS,KACT5B,GAAa,CAAA,CACd,EAEDtD,EAAUuL,gBAAgB,CAAG,SAAU/a,CAAG,CAAEgb,CAAI,CAAEzjB,CAAK,EAQrD,OANI,AAACmd,IACHK,GAAa,CAAA,GAKRiE,GAFOzN,GAAkBvL,GACjBuL,GAAkByP,GACOzjB,EACzC,EAEDiY,EAAUyL,OAAO,CAAG,SAAUC,CAAU,CAAEC,CAAY,EACxB,YAAxB,OAAOA,GAIXnR,EAAUnT,EAAK,CAACqkB,EAAW,CAAEC,EAC9B,EAED3L,EAAU4L,UAAU,CAAG,SAAUF,CAAU,CAAEC,CAAY,EACvD,GAAIA,AAAiB3P,KAAAA,IAAjB2P,EAA4B,CAC9B,IAAM5V,EAAQuE,EAAiBjT,EAAK,CAACqkB,EAAW,CAAEC,GAElD,OAAO5V,AAAU,KAAVA,EACHiG,KAAAA,EACAvB,EAAYpT,EAAK,CAACqkB,EAAW,CAAE3V,EAAO,EAAE,CAAC,EAAE,AACjD,CAEA,OAAOwE,EAASlT,EAAK,CAACqkB,EAAW,CAClC,EAED1L,EAAU6L,WAAW,CAAG,SAAUH,CAAU,EAC1CrkB,EAAK,CAACqkB,EAAW,CAAG,EAAE,AACvB,EAED1L,EAAU8L,cAAc,CAAG,WACzBzkB,GAAQ6X,GACT,EAEMc,CACT,G,InB/nDA,MAAM,EAAgB,SAAS,cAAc,CAAC,kBACxC,EAAc,SAAS,cAAc,CAAC,gBACtC,EAAY,SAAS,cAAc,CAAC,cACpC,EAAmB,SAAS,cAAc,CAAC,qBAQjD,SAAS,EAAoB,CAAO,CAAE,EAAS,MAAM,EACnD,IAAM,EAAU,SAAS,aAAa,CAAC,MAEnC,AAAW,CAAA,SAAX,EACF,EAAQ,SAAS,CAAG,kFAEpB,EAAQ,SAAS,CAAG,gDAGtB,IAAM,EAAS,SAAS,aAAa,CAAC,OAetC,GAdA,EAAO,SAAS,CACb,AAAA,CAAA,AAAW,SAAX,EAAoB,QAAU,YAAA,EAC/B,kHACE,AAAW,SAAX,EACF,EAAO,SAAS,CAAC,GAAG,CAAC,cAAe,gBAAiB,WAEvD,EAAO,SAAS,CAAC,GAAG,CAAC,cAAe,eAAgB,cAEhD,AAAW,cAAX,EAEF,EAAO,SAAS,CAAG,AAAA,EAAA,GAAU,QAAQ,CAAC,AAAA,EAAA,MAAK,CAAE,KAAK,CAAC,IAEnD,EAAO,WAAW,CAAG,EAEnB,AAAW,cAAX,EAAwB,CAC1B,IAAM,EAAS,SAAS,aAAa,CAAC,MACtC,CAAA,EAAO,SAAS,CACd,uFACF,IAAM,EAAM,SAAS,aAAa,CAAC,MACnC,CAAA,EAAI,GAAG,CAAG,EAAA,GACV,EAAI,GAAG,CAAG,SACV,EAAI,SAAS,CAAG,6BAChB,EAAO,WAAW,CAAC,GACnB,EAAQ,WAAW,CAAC,GACpB,EAAQ,WAAW,CAAC,EACtB,MACE,EAAQ,WAAW,CAAC,GAOtB,OAJA,WAAW,KACT,EAAO,SAAS,CAAC,GAAG,CAAC,uBACvB,EAAG,IAEI,CACT,CAEA,SAAS,IACP,EAAc,SAAS,CAAG,EAAc,YAAY,AACtD,CAEA,eAAe,EAAqB,CAAW,CAAE,CAAY,EAC3D,IAAM,EAAW,MAAM,MAvDb,iCAuDwB,CAChC,OAAQ,OACR,QAAS,CACP,eAAgB,kBAClB,EACA,KAAM,KAAK,SAAS,CAAC,CACnB,MAAO,EACP,SAAU,CACZ,EAAK,GAEP,GAAI,CAAC,EAAS,EAAE,CACd,MAAM,AAAI,MAAM,+BAIlB,MAAO,AADM,CAAA,MAAM,EAAS,IAAI,EAAhC,EACY,KAAK,AACnB,CAEA,EAAY,gBAAgB,CAAC,SAAU,MAAO,IAC5C,EAAE,cAAc,GAChB,IAAM,EAAU,EAAU,KAAK,CAAC,IAAI,GAC9B,EAAmB,EAAiB,KAAK,CAC/C,GAAK,GACL,GAAI,CAAC,EAAkB,YACrB,MAAM,cAIR,EAAc,WAAW,CAAC,EAAoB,EAAS,SACvD,EAAU,KAAK,CAAG,GAClB,EAAU,KAAK,CAAC,MAAM,CAAG,GACzB,IAEA,GAAI,CACF,IAAM,EAAW,MAAM,EAAqB,EAAS,GACrD,EAAc,WAAW,CAAC,EAAoB,EAAU,cACxD,GACF,CAAE,MAAO,EAAO,CACd,QAAQ,KAAK,CAAC,qCAAsC,GACpD,EAAc,WAAW,CACvB,EACE,0CACA,cAGJ,GACF,EACF,GAEA,OAAO,gBAAgB,CAAC,mBAAoB,KAC1C,EAAc,WAAW,CACvB,EAAoB,sCAAuC,cAE7D,GACF,GAEA,MAAM,EAAW,SAAS,cAAc,CAAC,cAEzC,EAAS,gBAAgB,CAAC,QAAS,KACjC,EAAS,KAAK,CAAC,MAAM,CAAG,OACxB,EAAS,KAAK,CAAC,MAAM,CAAG,EAAS,YAAY,CAAG,IAClD,GAEA,EAAS,gBAAgB,CAAC,UAAW,AAAC,IACtB,UAAV,EAAE,GAAG,EAAiB,EAAE,QAAQ,GAClC,EAAE,cAAc,GAChB,SAAS,cAAc,CAAC,gBAAgB,aAAa,GAEzD","sources":["<anon>","src/app.js","node_modules/@parcel/runtime-js/lib/runtime-a182b67b44140455.js","node_modules/marked/lib/marked.umd.js","node_modules/marked/src/marked.ts","node_modules/marked/src/defaults.ts","node_modules/marked/src/rules.ts","node_modules/marked/src/helpers.ts","node_modules/marked/src/Tokenizer.ts","node_modules/marked/src/Lexer.ts","node_modules/marked/src/Renderer.ts","node_modules/marked/src/TextRenderer.ts","node_modules/marked/src/Parser.ts","node_modules/marked/src/Hooks.ts","node_modules/marked/src/Instance.ts","node_modules/dompurify/dist/purify.js","node_modules/dompurify/src/utils.ts","node_modules/dompurify/src/tags.ts","node_modules/dompurify/src/attrs.ts","node_modules/dompurify/src/regexp.ts","node_modules/dompurify/src/purify.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $1862cbf67f994e67$exports = {};\n$1862cbf67f994e67$exports = import.meta.resolve(\"2u8Vv\");\n\n\nvar $d55025bea272cdc1$exports = {};\n/**\n * marked v16.0.0 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */ /**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */ (function(g, f) {\n    $d55025bea272cdc1$exports = f();\n})(typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : $d55025bea272cdc1$exports, function() {\n    var exports = {};\n    var __exports = exports;\n    var module1 = {\n        exports: exports\n    };\n    \"use strict\";\n    var H = Object.defineProperty;\n    var be = Object.getOwnPropertyDescriptor;\n    var Te = Object.getOwnPropertyNames;\n    var we = Object.prototype.hasOwnProperty;\n    var ye = (l, e)=>{\n        for(var t in e)H(l, t, {\n            get: e[t],\n            enumerable: !0\n        });\n    }, Re = (l, e, t, n)=>{\n        if (e && typeof e == \"object\" || typeof e == \"function\") for (let s of Te(e))!we.call(l, s) && s !== t && H(l, s, {\n            get: ()=>e[s],\n            enumerable: !(n = be(e, s)) || n.enumerable\n        });\n        return l;\n    };\n    var Se = (l)=>Re(H({}, \"__esModule\", {\n            value: !0\n        }), l);\n    var kt = {};\n    ye(kt, {\n        Hooks: ()=>L,\n        Lexer: ()=>x,\n        Marked: ()=>E,\n        Parser: ()=>b,\n        Renderer: ()=>$,\n        TextRenderer: ()=>_,\n        Tokenizer: ()=>S,\n        defaults: ()=>w,\n        getDefaults: ()=>z,\n        lexer: ()=>ht,\n        marked: ()=>k,\n        options: ()=>it,\n        parse: ()=>pt,\n        parseInline: ()=>ct,\n        parser: ()=>ut,\n        setOptions: ()=>ot,\n        use: ()=>lt,\n        walkTokens: ()=>at\n    });\n    module1.exports = Se(kt);\n    function z() {\n        return {\n            async: !1,\n            breaks: !1,\n            extensions: null,\n            gfm: !0,\n            hooks: null,\n            pedantic: !1,\n            renderer: null,\n            silent: !1,\n            tokenizer: null,\n            walkTokens: null\n        };\n    }\n    var w = z();\n    function N(l) {\n        w = l;\n    }\n    var I = {\n        exec: ()=>null\n    };\n    function h(l, e = \"\") {\n        let t = typeof l == \"string\" ? l : l.source, n = {\n            replace: (s, i)=>{\n                let r = typeof i == \"string\" ? i : i.source;\n                return r = r.replace(m.caret, \"$1\"), t = t.replace(s, r), n;\n            },\n            getRegex: ()=>new RegExp(t, e)\n        };\n        return n;\n    }\n    var m = {\n        codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n        outputLinkReplace: /\\\\([\\[\\]])/g,\n        indentCodeCompensation: /^(\\s+)(?:```)/,\n        beginningSpace: /^\\s+/,\n        endingHash: /#$/,\n        startingSpaceChar: /^ /,\n        endingSpaceChar: / $/,\n        nonSpaceChar: /[^ ]/,\n        newLineCharGlobal: /\\n/g,\n        tabCharGlobal: /\\t/g,\n        multipleSpaceGlobal: /\\s+/g,\n        blankLine: /^[ \\t]*$/,\n        doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n        blockquoteStart: /^ {0,3}>/,\n        blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n        blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n        listReplaceTabs: /^\\t+/,\n        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n        listIsTask: /^\\[[ xX]\\] /,\n        listReplaceTask: /^\\[[ xX]\\] +/,\n        anyLine: /\\n.*\\n/,\n        hrefBrackets: /^<(.*)>$/,\n        tableDelimiter: /[:|]/,\n        tableAlignChars: /^\\||\\| *$/g,\n        tableRowBlankLine: /\\n[ \\t]*$/,\n        tableAlignRight: /^ *-+: *$/,\n        tableAlignCenter: /^ *:-+: *$/,\n        tableAlignLeft: /^ *:-+ *$/,\n        startATag: /^<a /i,\n        endATag: /^<\\/a>/i,\n        startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n        endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n        startAngleBracket: /^</,\n        endAngleBracket: />$/,\n        pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n        unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n        escapeTest: /[&<>\"']/,\n        escapeReplace: /[&<>\"']/g,\n        escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n        escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n        unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n        caret: /(^|[^\\[])\\^/g,\n        percentDecode: /%25/g,\n        findPipe: /\\|/g,\n        splitPipe: / \\|/,\n        slashPipe: /\\\\\\|/g,\n        carriageReturn: /\\r\\n|\\r/g,\n        spaceLine: /^ +$/gm,\n        notSpaceStart: /^\\S*/,\n        endingNewline: /\\n$/,\n        listItemRegex: (l)=>new RegExp(`^( {0,3}${l})((?:[\t ][^\\\\n]*)?(?:\\\\n|$))`),\n        nextBulletRegex: (l)=>new RegExp(`^ {0,${Math.min(3, l - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))`),\n        hrRegex: (l)=>new RegExp(`^ {0,${Math.min(3, l - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n        fencesBeginRegex: (l)=>new RegExp(`^ {0,${Math.min(3, l - 1)}}(?:\\`\\`\\`|~~~)`),\n        headingBeginRegex: (l)=>new RegExp(`^ {0,${Math.min(3, l - 1)}}#`),\n        htmlBeginRegex: (l)=>new RegExp(`^ {0,${Math.min(3, l - 1)}}<(?:[a-z].*>|!--)`, \"i\")\n    }, $e = /^(?:[ \\t]*(?:\\n|$))+/, _e = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/, Le = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/, O = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/, ze = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/, F = /(?:[*+-]|\\d{1,9}[.)])/, ie = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/, oe = h(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\\n>]+>\\n/).replace(/\\|table/g, \"\").getRegex(), Me = h(ie).replace(/bull/g, F).replace(/blockCode/g, /(?: {4}| {0,3}\\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\\n>]+>\\n/).replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/).getRegex(), Q = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/, Pe = /^[^\\n]+/, U = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/, Ae = h(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\", U).replace(\"title\", /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex(), Ee = h(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g, F).getRegex(), v = \"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\", K = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/, Ce = h(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$))\", \"i\").replace(\"comment\", K).replace(\"tag\", v).replace(\"attribute\", / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex(), le = h(Q).replace(\"hr\", O).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", v).getRegex(), Ie = h(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\", le).getRegex(), X = {\n        blockquote: Ie,\n        code: _e,\n        def: Ae,\n        fences: Le,\n        heading: ze,\n        hr: O,\n        html: Ce,\n        lheading: oe,\n        list: Ee,\n        newline: $e,\n        paragraph: le,\n        table: I,\n        text: Pe\n    }, re = h(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\").replace(\"hr\", O).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\", \" {0,3}>\").replace(\"code\", \"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", v).getRegex(), Oe = {\n        ...X,\n        lheading: Me,\n        table: re,\n        paragraph: h(Q).replace(\"hr\", O).replace(\"heading\", \" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\", \"\").replace(\"table\", re).replace(\"blockquote\", \" {0,3}>\").replace(\"fences\", \" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\", \" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\", \"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\", v).getRegex()\n    }, Be = {\n        ...X,\n        html: h(`^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\\\s[^'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))`).replace(\"comment\", K).replace(/tag/g, \"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),\n        def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n        heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n        fences: I,\n        lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n        paragraph: h(Q).replace(\"hr\", O).replace(\"heading\", ` *#{1,6} *[^\n]`).replace(\"lheading\", oe).replace(\"|table\", \"\").replace(\"blockquote\", \" {0,3}>\").replace(\"|fences\", \"\").replace(\"|list\", \"\").replace(\"|html\", \"\").replace(\"|tag\", \"\").getRegex()\n    }, qe = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/, ve = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/, ae = /^( {2,}|\\\\)\\n(?!\\s*$)/, De = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/, D = /[\\p{P}\\p{S}]/u, W = /[\\s\\p{P}\\p{S}]/u, ce = /[^\\s\\p{P}\\p{S}]/u, Ze = h(/^((?![*_])punctSpace)/, \"u\").replace(/punctSpace/g, W).getRegex(), pe = /(?!~)[\\p{P}\\p{S}]/u, Ge = /(?!~)[\\s\\p{P}\\p{S}]/u, He = /(?:[^\\s\\p{P}\\p{S}]|~)/u, Ne = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g, ue = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/, je = h(ue, \"u\").replace(/punct/g, D).getRegex(), Fe = h(ue, \"u\").replace(/punct/g, pe).getRegex(), he = \"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)|notPunctSpace(\\\\*+)(?=notPunctSpace)\", Qe = h(he, \"gu\").replace(/notPunctSpace/g, ce).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Ue = h(he, \"gu\").replace(/notPunctSpace/g, He).replace(/punctSpace/g, Ge).replace(/punct/g, pe).getRegex(), Ke = h(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)\", \"gu\").replace(/notPunctSpace/g, ce).replace(/punctSpace/g, W).replace(/punct/g, D).getRegex(), Xe = h(/\\\\(punct)/, \"gu\").replace(/punct/g, D).getRegex(), We = h(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(), Je = h(K).replace(\"(?:-->|$)\", \"-->\").getRegex(), Ve = h(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\").replace(\"comment\", Je).replace(\"attribute\", /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex(), q = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/, Ye = h(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/).replace(\"label\", q).replace(\"href\", /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/).replace(\"title\", /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex(), ke = h(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\", q).replace(\"ref\", U).getRegex(), ge = h(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\", U).getRegex(), et = h(\"reflink|nolink(?!\\\\()\", \"g\").replace(\"reflink\", ke).replace(\"nolink\", ge).getRegex(), J = {\n        _backpedal: I,\n        anyPunctuation: Xe,\n        autolink: We,\n        blockSkip: Ne,\n        br: ae,\n        code: ve,\n        del: I,\n        emStrongLDelim: je,\n        emStrongRDelimAst: Qe,\n        emStrongRDelimUnd: Ke,\n        escape: qe,\n        link: Ye,\n        nolink: ge,\n        punctuation: Ze,\n        reflink: ke,\n        reflinkSearch: et,\n        tag: Ve,\n        text: De,\n        url: I\n    }, tt = {\n        ...J,\n        link: h(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\", q).getRegex(),\n        reflink: h(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\", q).getRegex()\n    }, j = {\n        ...J,\n        emStrongRDelimAst: Ue,\n        emStrongLDelim: Fe,\n        url: h(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, \"i\").replace(\"email\", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),\n        _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n        del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n        text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/\n    }, nt = {\n        ...j,\n        br: h(ae).replace(\"{2,}\", \"*\").getRegex(),\n        text: h(j.text).replace(\"\\\\b_\", \"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g, \"*\").getRegex()\n    }, B = {\n        normal: X,\n        gfm: Oe,\n        pedantic: Be\n    }, P = {\n        normal: J,\n        gfm: j,\n        breaks: nt,\n        pedantic: tt\n    };\n    var st = {\n        \"&\": \"&amp;\",\n        \"<\": \"&lt;\",\n        \">\": \"&gt;\",\n        '\"': \"&quot;\",\n        \"'\": \"&#39;\"\n    }, fe = (l)=>st[l];\n    function R(l, e) {\n        if (e) {\n            if (m.escapeTest.test(l)) return l.replace(m.escapeReplace, fe);\n        } else if (m.escapeTestNoEncode.test(l)) return l.replace(m.escapeReplaceNoEncode, fe);\n        return l;\n    }\n    function V(l) {\n        try {\n            l = encodeURI(l).replace(m.percentDecode, \"%\");\n        } catch  {\n            return null;\n        }\n        return l;\n    }\n    function Y(l, e) {\n        let t = l.replace(m.findPipe, (i, r, o)=>{\n            let a = !1, c = r;\n            for(; --c >= 0 && o[c] === \"\\\\\";)a = !a;\n            return a ? \"|\" : \" |\";\n        }), n = t.split(m.splitPipe), s = 0;\n        if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e) {\n            if (n.length > e) n.splice(e);\n            else for(; n.length < e;)n.push(\"\");\n        }\n        for(; s < n.length; s++)n[s] = n[s].trim().replace(m.slashPipe, \"|\");\n        return n;\n    }\n    function A(l, e, t) {\n        let n = l.length;\n        if (n === 0) return \"\";\n        let s = 0;\n        for(; s < n;){\n            let i = l.charAt(n - s - 1);\n            if (i === e && !t) s++;\n            else if (i !== e && t) s++;\n            else break;\n        }\n        return l.slice(0, n - s);\n    }\n    function de(l, e) {\n        if (l.indexOf(e[1]) === -1) return -1;\n        let t = 0;\n        for(let n = 0; n < l.length; n++)if (l[n] === \"\\\\\") n++;\n        else if (l[n] === e[0]) t++;\n        else if (l[n] === e[1] && (t--, t < 0)) return n;\n        return t > 0 ? -2 : -1;\n    }\n    function me(l, e, t, n, s) {\n        let i = e.href, r = e.title || null, o = l[1].replace(s.other.outputLinkReplace, \"$1\");\n        n.state.inLink = !0;\n        let a = {\n            type: l[0].charAt(0) === \"!\" ? \"image\" : \"link\",\n            raw: t,\n            href: i,\n            title: r,\n            text: o,\n            tokens: n.inlineTokens(o)\n        };\n        return n.state.inLink = !1, a;\n    }\n    function rt(l, e, t) {\n        let n = l.match(t.other.indentCodeCompensation);\n        if (n === null) return e;\n        let s = n[1];\n        return e.split(`\n`).map((i)=>{\n            let r = i.match(t.other.beginningSpace);\n            if (r === null) return i;\n            let [o] = r;\n            return o.length >= s.length ? i.slice(s.length) : i;\n        }).join(`\n`);\n    }\n    var S = class {\n        options;\n        rules;\n        lexer;\n        constructor(e){\n            this.options = e || w;\n        }\n        space(e) {\n            let t = this.rules.block.newline.exec(e);\n            if (t && t[0].length > 0) return {\n                type: \"space\",\n                raw: t[0]\n            };\n        }\n        code(e) {\n            let t = this.rules.block.code.exec(e);\n            if (t) {\n                let n = t[0].replace(this.rules.other.codeRemoveIndent, \"\");\n                return {\n                    type: \"code\",\n                    raw: t[0],\n                    codeBlockStyle: \"indented\",\n                    text: this.options.pedantic ? n : A(n, `\n`)\n                };\n            }\n        }\n        fences(e) {\n            let t = this.rules.block.fences.exec(e);\n            if (t) {\n                let n = t[0], s = rt(n, t[3] || \"\", this.rules);\n                return {\n                    type: \"code\",\n                    raw: n,\n                    lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, \"$1\") : t[2],\n                    text: s\n                };\n            }\n        }\n        heading(e) {\n            let t = this.rules.block.heading.exec(e);\n            if (t) {\n                let n = t[2].trim();\n                if (this.rules.other.endingHash.test(n)) {\n                    let s = A(n, \"#\");\n                    (this.options.pedantic || !s || this.rules.other.endingSpaceChar.test(s)) && (n = s.trim());\n                }\n                return {\n                    type: \"heading\",\n                    raw: t[0],\n                    depth: t[1].length,\n                    text: n,\n                    tokens: this.lexer.inline(n)\n                };\n            }\n        }\n        hr(e) {\n            let t = this.rules.block.hr.exec(e);\n            if (t) return {\n                type: \"hr\",\n                raw: A(t[0], `\n`)\n            };\n        }\n        blockquote(e) {\n            let t = this.rules.block.blockquote.exec(e);\n            if (t) {\n                let n = A(t[0], `\n`).split(`\n`), s = \"\", i = \"\", r = [];\n                for(; n.length > 0;){\n                    let o = !1, a = [], c;\n                    for(c = 0; c < n.length; c++)if (this.rules.other.blockquoteStart.test(n[c])) a.push(n[c]), o = !0;\n                    else if (!o) a.push(n[c]);\n                    else break;\n                    n = n.slice(c);\n                    let p = a.join(`\n`), u = p.replace(this.rules.other.blockquoteSetextReplace, `\n    $1`).replace(this.rules.other.blockquoteSetextReplace2, \"\");\n                    s = s ? `${s}\n${p}` : p, i = i ? `${i}\n${u}` : u;\n                    let d = this.lexer.state.top;\n                    if (this.lexer.state.top = !0, this.lexer.blockTokens(u, r, !0), this.lexer.state.top = d, n.length === 0) break;\n                    let g = r.at(-1);\n                    if (g?.type === \"code\") break;\n                    if (g?.type === \"blockquote\") {\n                        let T = g, f = T.raw + `\n` + n.join(`\n`), y = this.blockquote(f);\n                        r[r.length - 1] = y, s = s.substring(0, s.length - T.raw.length) + y.raw, i = i.substring(0, i.length - T.text.length) + y.text;\n                        break;\n                    } else if (g?.type === \"list\") {\n                        let T = g, f = T.raw + `\n` + n.join(`\n`), y = this.list(f);\n                        r[r.length - 1] = y, s = s.substring(0, s.length - g.raw.length) + y.raw, i = i.substring(0, i.length - T.raw.length) + y.raw, n = f.substring(r.at(-1).raw.length).split(`\n`);\n                        continue;\n                    }\n                }\n                return {\n                    type: \"blockquote\",\n                    raw: s,\n                    tokens: r,\n                    text: i\n                };\n            }\n        }\n        list(e) {\n            let t = this.rules.block.list.exec(e);\n            if (t) {\n                let n = t[1].trim(), s = n.length > 1, i = {\n                    type: \"list\",\n                    raw: \"\",\n                    ordered: s,\n                    start: s ? +n.slice(0, -1) : \"\",\n                    loose: !1,\n                    items: []\n                };\n                n = s ? `\\\\d{1,9}\\\\${n.slice(-1)}` : `\\\\${n}`, this.options.pedantic && (n = s ? n : \"[*+-]\");\n                let r = this.rules.other.listItemRegex(n), o = !1;\n                for(; e;){\n                    let c = !1, p = \"\", u = \"\";\n                    if (!(t = r.exec(e)) || this.rules.block.hr.test(e)) break;\n                    p = t[0], e = e.substring(p.length);\n                    let d = t[2].split(`\n`, 1)[0].replace(this.rules.other.listReplaceTabs, (Z)=>\" \".repeat(3 * Z.length)), g = e.split(`\n`, 1)[0], T = !d.trim(), f = 0;\n                    if (this.options.pedantic ? (f = 2, u = d.trimStart()) : T ? f = t[1].length + 1 : (f = t[2].search(this.rules.other.nonSpaceChar), f = f > 4 ? 1 : f, u = d.slice(f), f += t[1].length), T && this.rules.other.blankLine.test(g) && (p += g + `\n`, e = e.substring(g.length + 1), c = !0), !c) {\n                        let Z = this.rules.other.nextBulletRegex(f), te = this.rules.other.hrRegex(f), ne = this.rules.other.fencesBeginRegex(f), se = this.rules.other.headingBeginRegex(f), xe = this.rules.other.htmlBeginRegex(f);\n                        for(; e;){\n                            let G = e.split(`\n`, 1)[0], C;\n                            if (g = G, this.options.pedantic ? (g = g.replace(this.rules.other.listReplaceNesting, \"  \"), C = g) : C = g.replace(this.rules.other.tabCharGlobal, \"    \"), ne.test(g) || se.test(g) || xe.test(g) || Z.test(g) || te.test(g)) break;\n                            if (C.search(this.rules.other.nonSpaceChar) >= f || !g.trim()) u += `\n` + C.slice(f);\n                            else {\n                                if (T || d.replace(this.rules.other.tabCharGlobal, \"    \").search(this.rules.other.nonSpaceChar) >= 4 || ne.test(d) || se.test(d) || te.test(d)) break;\n                                u += `\n` + g;\n                            }\n                            !T && !g.trim() && (T = !0), p += G + `\n`, e = e.substring(G.length + 1), d = C.slice(f);\n                        }\n                    }\n                    i.loose || (o ? i.loose = !0 : this.rules.other.doubleBlankLine.test(p) && (o = !0));\n                    let y = null, ee;\n                    this.options.gfm && (y = this.rules.other.listIsTask.exec(u), y && (ee = y[0] !== \"[ ] \", u = u.replace(this.rules.other.listReplaceTask, \"\"))), i.items.push({\n                        type: \"list_item\",\n                        raw: p,\n                        task: !!y,\n                        checked: ee,\n                        loose: !1,\n                        text: u,\n                        tokens: []\n                    }), i.raw += p;\n                }\n                let a = i.items.at(-1);\n                if (a) a.raw = a.raw.trimEnd(), a.text = a.text.trimEnd();\n                else return;\n                i.raw = i.raw.trimEnd();\n                for(let c = 0; c < i.items.length; c++)if (this.lexer.state.top = !1, i.items[c].tokens = this.lexer.blockTokens(i.items[c].text, []), !i.loose) {\n                    let p = i.items[c].tokens.filter((d)=>d.type === \"space\"), u = p.length > 0 && p.some((d)=>this.rules.other.anyLine.test(d.raw));\n                    i.loose = u;\n                }\n                if (i.loose) for(let c = 0; c < i.items.length; c++)i.items[c].loose = !0;\n                return i;\n            }\n        }\n        html(e) {\n            let t = this.rules.block.html.exec(e);\n            if (t) return {\n                type: \"html\",\n                block: !0,\n                raw: t[0],\n                pre: t[1] === \"pre\" || t[1] === \"script\" || t[1] === \"style\",\n                text: t[0]\n            };\n        }\n        def(e) {\n            let t = this.rules.block.def.exec(e);\n            if (t) {\n                let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, \" \"), s = t[2] ? t[2].replace(this.rules.other.hrefBrackets, \"$1\").replace(this.rules.inline.anyPunctuation, \"$1\") : \"\", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, \"$1\") : t[3];\n                return {\n                    type: \"def\",\n                    tag: n,\n                    raw: t[0],\n                    href: s,\n                    title: i\n                };\n            }\n        }\n        table(e) {\n            let t = this.rules.block.table.exec(e);\n            if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;\n            let n = Y(t[1]), s = t[2].replace(this.rules.other.tableAlignChars, \"\").split(\"|\"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, \"\").split(`\n`) : [], r = {\n                type: \"table\",\n                raw: t[0],\n                header: [],\n                align: [],\n                rows: []\n            };\n            if (n.length === s.length) {\n                for (let o of s)this.rules.other.tableAlignRight.test(o) ? r.align.push(\"right\") : this.rules.other.tableAlignCenter.test(o) ? r.align.push(\"center\") : this.rules.other.tableAlignLeft.test(o) ? r.align.push(\"left\") : r.align.push(null);\n                for(let o = 0; o < n.length; o++)r.header.push({\n                    text: n[o],\n                    tokens: this.lexer.inline(n[o]),\n                    header: !0,\n                    align: r.align[o]\n                });\n                for (let o of i)r.rows.push(Y(o, r.header.length).map((a, c)=>({\n                        text: a,\n                        tokens: this.lexer.inline(a),\n                        header: !1,\n                        align: r.align[c]\n                    })));\n                return r;\n            }\n        }\n        lheading(e) {\n            let t = this.rules.block.lheading.exec(e);\n            if (t) return {\n                type: \"heading\",\n                raw: t[0],\n                depth: t[2].charAt(0) === \"=\" ? 1 : 2,\n                text: t[1],\n                tokens: this.lexer.inline(t[1])\n            };\n        }\n        paragraph(e) {\n            let t = this.rules.block.paragraph.exec(e);\n            if (t) {\n                let n = t[1].charAt(t[1].length - 1) === `\n` ? t[1].slice(0, -1) : t[1];\n                return {\n                    type: \"paragraph\",\n                    raw: t[0],\n                    text: n,\n                    tokens: this.lexer.inline(n)\n                };\n            }\n        }\n        text(e) {\n            let t = this.rules.block.text.exec(e);\n            if (t) return {\n                type: \"text\",\n                raw: t[0],\n                text: t[0],\n                tokens: this.lexer.inline(t[0])\n            };\n        }\n        escape(e) {\n            let t = this.rules.inline.escape.exec(e);\n            if (t) return {\n                type: \"escape\",\n                raw: t[0],\n                text: t[1]\n            };\n        }\n        tag(e) {\n            let t = this.rules.inline.tag.exec(e);\n            if (t) return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = !0 : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = !1), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = !0 : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = !1), {\n                type: \"html\",\n                raw: t[0],\n                inLink: this.lexer.state.inLink,\n                inRawBlock: this.lexer.state.inRawBlock,\n                block: !1,\n                text: t[0]\n            };\n        }\n        link(e) {\n            let t = this.rules.inline.link.exec(e);\n            if (t) {\n                let n = t[2].trim();\n                if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {\n                    if (!this.rules.other.endAngleBracket.test(n)) return;\n                    let r = A(n.slice(0, -1), \"\\\\\");\n                    if ((n.length - r.length) % 2 === 0) return;\n                } else {\n                    let r = de(t[2], \"()\");\n                    if (r === -2) return;\n                    if (r > -1) {\n                        let a = (t[0].indexOf(\"!\") === 0 ? 5 : 4) + t[1].length + r;\n                        t[2] = t[2].substring(0, r), t[0] = t[0].substring(0, a).trim(), t[3] = \"\";\n                    }\n                }\n                let s = t[2], i = \"\";\n                if (this.options.pedantic) {\n                    let r = this.rules.other.pedanticHrefTitle.exec(s);\n                    r && (s = r[1], i = r[3]);\n                } else i = t[3] ? t[3].slice(1, -1) : \"\";\n                return s = s.trim(), this.rules.other.startAngleBracket.test(s) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? s = s.slice(1) : s = s.slice(1, -1)), me(t, {\n                    href: s && s.replace(this.rules.inline.anyPunctuation, \"$1\"),\n                    title: i && i.replace(this.rules.inline.anyPunctuation, \"$1\")\n                }, t[0], this.lexer, this.rules);\n            }\n        }\n        reflink(e, t) {\n            let n;\n            if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {\n                let s = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, \" \"), i = t[s.toLowerCase()];\n                if (!i) {\n                    let r = n[0].charAt(0);\n                    return {\n                        type: \"text\",\n                        raw: r,\n                        text: r\n                    };\n                }\n                return me(n, i, n[0], this.lexer, this.rules);\n            }\n        }\n        emStrong(e, t, n = \"\") {\n            let s = this.rules.inline.emStrongLDelim.exec(e);\n            if (!s || s[3] && n.match(this.rules.other.unicodeAlphaNumeric)) return;\n            if (!(s[1] || s[2] || \"\") || !n || this.rules.inline.punctuation.exec(n)) {\n                let r = [\n                    ...s[0]\n                ].length - 1, o, a, c = r, p = 0, u = s[0][0] === \"*\" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n                for(u.lastIndex = 0, t = t.slice(-1 * e.length + r); (s = u.exec(t)) != null;){\n                    if (o = s[1] || s[2] || s[3] || s[4] || s[5] || s[6], !o) continue;\n                    if (a = [\n                        ...o\n                    ].length, s[3] || s[4]) {\n                        c += a;\n                        continue;\n                    } else if ((s[5] || s[6]) && r % 3 && !((r + a) % 3)) {\n                        p += a;\n                        continue;\n                    }\n                    if (c -= a, c > 0) continue;\n                    a = Math.min(a, a + c + p);\n                    let d = [\n                        ...s[0]\n                    ][0].length, g = e.slice(0, r + s.index + d + a);\n                    if (Math.min(r, a) % 2) {\n                        let f = g.slice(1, -1);\n                        return {\n                            type: \"em\",\n                            raw: g,\n                            text: f,\n                            tokens: this.lexer.inlineTokens(f)\n                        };\n                    }\n                    let T = g.slice(2, -2);\n                    return {\n                        type: \"strong\",\n                        raw: g,\n                        text: T,\n                        tokens: this.lexer.inlineTokens(T)\n                    };\n                }\n            }\n        }\n        codespan(e) {\n            let t = this.rules.inline.code.exec(e);\n            if (t) {\n                let n = t[2].replace(this.rules.other.newLineCharGlobal, \" \"), s = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);\n                return s && i && (n = n.substring(1, n.length - 1)), {\n                    type: \"codespan\",\n                    raw: t[0],\n                    text: n\n                };\n            }\n        }\n        br(e) {\n            let t = this.rules.inline.br.exec(e);\n            if (t) return {\n                type: \"br\",\n                raw: t[0]\n            };\n        }\n        del(e) {\n            let t = this.rules.inline.del.exec(e);\n            if (t) return {\n                type: \"del\",\n                raw: t[0],\n                text: t[2],\n                tokens: this.lexer.inlineTokens(t[2])\n            };\n        }\n        autolink(e) {\n            let t = this.rules.inline.autolink.exec(e);\n            if (t) {\n                let n, s;\n                return t[2] === \"@\" ? (n = t[1], s = \"mailto:\" + n) : (n = t[1], s = n), {\n                    type: \"link\",\n                    raw: t[0],\n                    text: n,\n                    href: s,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: n,\n                            text: n\n                        }\n                    ]\n                };\n            }\n        }\n        url(e) {\n            let t;\n            if (t = this.rules.inline.url.exec(e)) {\n                let n, s;\n                if (t[2] === \"@\") n = t[0], s = \"mailto:\" + n;\n                else {\n                    let i;\n                    do i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? \"\";\n                    while (i !== t[0]);\n                    n = t[0], t[1] === \"www.\" ? s = \"http://\" + t[0] : s = t[0];\n                }\n                return {\n                    type: \"link\",\n                    raw: t[0],\n                    text: n,\n                    href: s,\n                    tokens: [\n                        {\n                            type: \"text\",\n                            raw: n,\n                            text: n\n                        }\n                    ]\n                };\n            }\n        }\n        inlineText(e) {\n            let t = this.rules.inline.text.exec(e);\n            if (t) {\n                let n = this.lexer.state.inRawBlock;\n                return {\n                    type: \"text\",\n                    raw: t[0],\n                    text: t[0],\n                    escaped: n\n                };\n            }\n        }\n    };\n    var x = class l {\n        tokens;\n        options;\n        state;\n        tokenizer;\n        inlineQueue;\n        constructor(e){\n            this.tokens = [], this.tokens.links = Object.create(null), this.options = e || w, this.options.tokenizer = this.options.tokenizer || new S, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = {\n                inLink: !1,\n                inRawBlock: !1,\n                top: !0\n            };\n            let t = {\n                other: m,\n                block: B.normal,\n                inline: P.normal\n            };\n            this.options.pedantic ? (t.block = B.pedantic, t.inline = P.pedantic) : this.options.gfm && (t.block = B.gfm, this.options.breaks ? t.inline = P.breaks : t.inline = P.gfm), this.tokenizer.rules = t;\n        }\n        static get rules() {\n            return {\n                block: B,\n                inline: P\n            };\n        }\n        static lex(e, t) {\n            return new l(t).lex(e);\n        }\n        static lexInline(e, t) {\n            return new l(t).inlineTokens(e);\n        }\n        lex(e) {\n            e = e.replace(m.carriageReturn, `\n`), this.blockTokens(e, this.tokens);\n            for(let t = 0; t < this.inlineQueue.length; t++){\n                let n = this.inlineQueue[t];\n                this.inlineTokens(n.src, n.tokens);\n            }\n            return this.inlineQueue = [], this.tokens;\n        }\n        blockTokens(e, t = [], n = !1) {\n            for(this.options.pedantic && (e = e.replace(m.tabCharGlobal, \"    \").replace(m.spaceLine, \"\")); e;){\n                let s;\n                if (this.options.extensions?.block?.some((r)=>(s = r.call({\n                        lexer: this\n                    }, e, t)) ? (e = e.substring(s.raw.length), t.push(s), !0) : !1)) continue;\n                if (s = this.tokenizer.space(e)) {\n                    e = e.substring(s.raw.length);\n                    let r = t.at(-1);\n                    s.raw.length === 1 && r !== void 0 ? r.raw += `\n` : t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.code(e)) {\n                    e = e.substring(s.raw.length);\n                    let r = t.at(-1);\n                    r?.type === \"paragraph\" || r?.type === \"text\" ? (r.raw += `\n` + s.raw, r.text += `\n` + s.text, this.inlineQueue.at(-1).src = r.text) : t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.fences(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.heading(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.hr(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.blockquote(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.list(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.html(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.def(e)) {\n                    e = e.substring(s.raw.length);\n                    let r = t.at(-1);\n                    r?.type === \"paragraph\" || r?.type === \"text\" ? (r.raw += `\n` + s.raw, r.text += `\n` + s.raw, this.inlineQueue.at(-1).src = r.text) : this.tokens.links[s.tag] || (this.tokens.links[s.tag] = {\n                        href: s.href,\n                        title: s.title\n                    });\n                    continue;\n                }\n                if (s = this.tokenizer.table(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                if (s = this.tokenizer.lheading(e)) {\n                    e = e.substring(s.raw.length), t.push(s);\n                    continue;\n                }\n                let i = e;\n                if (this.options.extensions?.startBlock) {\n                    let r = 1 / 0, o = e.slice(1), a;\n                    this.options.extensions.startBlock.forEach((c)=>{\n                        a = c.call({\n                            lexer: this\n                        }, o), typeof a == \"number\" && a >= 0 && (r = Math.min(r, a));\n                    }), r < 1 / 0 && r >= 0 && (i = e.substring(0, r + 1));\n                }\n                if (this.state.top && (s = this.tokenizer.paragraph(i))) {\n                    let r = t.at(-1);\n                    n && r?.type === \"paragraph\" ? (r.raw += `\n` + s.raw, r.text += `\n` + s.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = r.text) : t.push(s), n = i.length !== e.length, e = e.substring(s.raw.length);\n                    continue;\n                }\n                if (s = this.tokenizer.text(e)) {\n                    e = e.substring(s.raw.length);\n                    let r = t.at(-1);\n                    r?.type === \"text\" ? (r.raw += `\n` + s.raw, r.text += `\n` + s.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = r.text) : t.push(s);\n                    continue;\n                }\n                if (e) {\n                    let r = \"Infinite loop on byte: \" + e.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(r);\n                        break;\n                    } else throw new Error(r);\n                }\n            }\n            return this.state.top = !0, t;\n        }\n        inline(e, t = []) {\n            return this.inlineQueue.push({\n                src: e,\n                tokens: t\n            }), t;\n        }\n        inlineTokens(e, t = []) {\n            let n = e, s = null;\n            if (this.tokens.links) {\n                let o = Object.keys(this.tokens.links);\n                if (o.length > 0) for(; (s = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null;)o.includes(s[0].slice(s[0].lastIndexOf(\"[\") + 1, -1)) && (n = n.slice(0, s.index) + \"[\" + \"a\".repeat(s[0].length - 2) + \"]\" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));\n            }\n            for(; (s = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null;)n = n.slice(0, s.index) + \"++\" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n            for(; (s = this.tokenizer.rules.inline.blockSkip.exec(n)) != null;)n = n.slice(0, s.index) + \"[\" + \"a\".repeat(s[0].length - 2) + \"]\" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n            let i = !1, r = \"\";\n            for(; e;){\n                i || (r = \"\"), i = !1;\n                let o;\n                if (this.options.extensions?.inline?.some((c)=>(o = c.call({\n                        lexer: this\n                    }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), !0) : !1)) continue;\n                if (o = this.tokenizer.escape(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.tag(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.link(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.reflink(e, this.tokens.links)) {\n                    e = e.substring(o.raw.length);\n                    let c = t.at(-1);\n                    o.type === \"text\" && c?.type === \"text\" ? (c.raw += o.raw, c.text += o.text) : t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.emStrong(e, n, r)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.codespan(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.br(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.del(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (o = this.tokenizer.autolink(e)) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                if (!this.state.inLink && (o = this.tokenizer.url(e))) {\n                    e = e.substring(o.raw.length), t.push(o);\n                    continue;\n                }\n                let a = e;\n                if (this.options.extensions?.startInline) {\n                    let c = 1 / 0, p = e.slice(1), u;\n                    this.options.extensions.startInline.forEach((d)=>{\n                        u = d.call({\n                            lexer: this\n                        }, p), typeof u == \"number\" && u >= 0 && (c = Math.min(c, u));\n                    }), c < 1 / 0 && c >= 0 && (a = e.substring(0, c + 1));\n                }\n                if (o = this.tokenizer.inlineText(a)) {\n                    e = e.substring(o.raw.length), o.raw.slice(-1) !== \"_\" && (r = o.raw.slice(-1)), i = !0;\n                    let c = t.at(-1);\n                    c?.type === \"text\" ? (c.raw += o.raw, c.text += o.text) : t.push(o);\n                    continue;\n                }\n                if (e) {\n                    let c = \"Infinite loop on byte: \" + e.charCodeAt(0);\n                    if (this.options.silent) {\n                        console.error(c);\n                        break;\n                    } else throw new Error(c);\n                }\n            }\n            return t;\n        }\n    };\n    var $ = class {\n        options;\n        parser;\n        constructor(e){\n            this.options = e || w;\n        }\n        space(e) {\n            return \"\";\n        }\n        code({ text: e, lang: t, escaped: n }) {\n            let s = (t || \"\").match(m.notSpaceStart)?.[0], i = e.replace(m.endingNewline, \"\") + `\n`;\n            return s ? '<pre><code class=\"language-' + R(s) + '\">' + (n ? i : R(i, !0)) + `</code></pre>\n` : \"<pre><code>\" + (n ? i : R(i, !0)) + `</code></pre>\n`;\n        }\n        blockquote({ tokens: e }) {\n            return `<blockquote>\n${this.parser.parse(e)}</blockquote>\n`;\n        }\n        html({ text: e }) {\n            return e;\n        }\n        heading({ tokens: e, depth: t }) {\n            return `<h${t}>${this.parser.parseInline(e)}</h${t}>\n`;\n        }\n        hr(e) {\n            return `<hr>\n`;\n        }\n        list(e) {\n            let t = e.ordered, n = e.start, s = \"\";\n            for(let o = 0; o < e.items.length; o++){\n                let a = e.items[o];\n                s += this.listitem(a);\n            }\n            let i = t ? \"ol\" : \"ul\", r = t && n !== 1 ? ' start=\"' + n + '\"' : \"\";\n            return \"<\" + i + r + `>\n` + s + \"</\" + i + `>\n`;\n        }\n        listitem(e) {\n            let t = \"\";\n            if (e.task) {\n                let n = this.checkbox({\n                    checked: !!e.checked\n                });\n                e.loose ? e.tokens[0]?.type === \"paragraph\" ? (e.tokens[0].text = n + \" \" + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === \"text\" && (e.tokens[0].tokens[0].text = n + \" \" + R(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = !0)) : e.tokens.unshift({\n                    type: \"text\",\n                    raw: n + \" \",\n                    text: n + \" \",\n                    escaped: !0\n                }) : t += n + \" \";\n            }\n            return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>\n`;\n        }\n        checkbox({ checked: e }) {\n            return \"<input \" + (e ? 'checked=\"\" ' : \"\") + 'disabled=\"\" type=\"checkbox\">';\n        }\n        paragraph({ tokens: e }) {\n            return `<p>${this.parser.parseInline(e)}</p>\n`;\n        }\n        table(e) {\n            let t = \"\", n = \"\";\n            for(let i = 0; i < e.header.length; i++)n += this.tablecell(e.header[i]);\n            t += this.tablerow({\n                text: n\n            });\n            let s = \"\";\n            for(let i = 0; i < e.rows.length; i++){\n                let r = e.rows[i];\n                n = \"\";\n                for(let o = 0; o < r.length; o++)n += this.tablecell(r[o]);\n                s += this.tablerow({\n                    text: n\n                });\n            }\n            return s && (s = `<tbody>${s}</tbody>`), `<table>\n<thead>\n` + t + `</thead>\n` + s + `</table>\n`;\n        }\n        tablerow({ text: e }) {\n            return `<tr>\n${e}</tr>\n`;\n        }\n        tablecell(e) {\n            let t = this.parser.parseInline(e.tokens), n = e.header ? \"th\" : \"td\";\n            return (e.align ? `<${n} align=\"${e.align}\">` : `<${n}>`) + t + `</${n}>\n`;\n        }\n        strong({ tokens: e }) {\n            return `<strong>${this.parser.parseInline(e)}</strong>`;\n        }\n        em({ tokens: e }) {\n            return `<em>${this.parser.parseInline(e)}</em>`;\n        }\n        codespan({ text: e }) {\n            return `<code>${R(e, !0)}</code>`;\n        }\n        br(e) {\n            return \"<br>\";\n        }\n        del({ tokens: e }) {\n            return `<del>${this.parser.parseInline(e)}</del>`;\n        }\n        link({ href: e, title: t, tokens: n }) {\n            let s = this.parser.parseInline(n), i = V(e);\n            if (i === null) return s;\n            e = i;\n            let r = '<a href=\"' + e + '\"';\n            return t && (r += ' title=\"' + R(t) + '\"'), r += \">\" + s + \"</a>\", r;\n        }\n        image({ href: e, title: t, text: n, tokens: s }) {\n            s && (n = this.parser.parseInline(s, this.parser.textRenderer));\n            let i = V(e);\n            if (i === null) return R(n);\n            e = i;\n            let r = `<img src=\"${e}\" alt=\"${n}\"`;\n            return t && (r += ` title=\"${R(t)}\"`), r += \">\", r;\n        }\n        text(e) {\n            return \"tokens\" in e && e.tokens ? this.parser.parseInline(e.tokens) : \"escaped\" in e && e.escaped ? e.text : R(e.text);\n        }\n    };\n    var _ = class {\n        strong({ text: e }) {\n            return e;\n        }\n        em({ text: e }) {\n            return e;\n        }\n        codespan({ text: e }) {\n            return e;\n        }\n        del({ text: e }) {\n            return e;\n        }\n        html({ text: e }) {\n            return e;\n        }\n        text({ text: e }) {\n            return e;\n        }\n        link({ text: e }) {\n            return \"\" + e;\n        }\n        image({ text: e }) {\n            return \"\" + e;\n        }\n        br() {\n            return \"\";\n        }\n    };\n    var b = class l {\n        options;\n        renderer;\n        textRenderer;\n        constructor(e){\n            this.options = e || w, this.options.renderer = this.options.renderer || new $, this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new _;\n        }\n        static parse(e, t) {\n            return new l(t).parse(e);\n        }\n        static parseInline(e, t) {\n            return new l(t).parseInline(e);\n        }\n        parse(e, t = !0) {\n            let n = \"\";\n            for(let s = 0; s < e.length; s++){\n                let i = e[s];\n                if (this.options.extensions?.renderers?.[i.type]) {\n                    let o = i, a = this.options.extensions.renderers[o.type].call({\n                        parser: this\n                    }, o);\n                    if (a !== !1 || ![\n                        \"space\",\n                        \"hr\",\n                        \"heading\",\n                        \"code\",\n                        \"table\",\n                        \"blockquote\",\n                        \"list\",\n                        \"html\",\n                        \"paragraph\",\n                        \"text\"\n                    ].includes(o.type)) {\n                        n += a || \"\";\n                        continue;\n                    }\n                }\n                let r = i;\n                switch(r.type){\n                    case \"space\":\n                        n += this.renderer.space(r);\n                        continue;\n                    case \"hr\":\n                        n += this.renderer.hr(r);\n                        continue;\n                    case \"heading\":\n                        n += this.renderer.heading(r);\n                        continue;\n                    case \"code\":\n                        n += this.renderer.code(r);\n                        continue;\n                    case \"table\":\n                        n += this.renderer.table(r);\n                        continue;\n                    case \"blockquote\":\n                        n += this.renderer.blockquote(r);\n                        continue;\n                    case \"list\":\n                        n += this.renderer.list(r);\n                        continue;\n                    case \"html\":\n                        n += this.renderer.html(r);\n                        continue;\n                    case \"paragraph\":\n                        n += this.renderer.paragraph(r);\n                        continue;\n                    case \"text\":\n                        {\n                            let o = r, a = this.renderer.text(o);\n                            for(; s + 1 < e.length && e[s + 1].type === \"text\";)o = e[++s], a += `\n` + this.renderer.text(o);\n                            t ? n += this.renderer.paragraph({\n                                type: \"paragraph\",\n                                raw: a,\n                                text: a,\n                                tokens: [\n                                    {\n                                        type: \"text\",\n                                        raw: a,\n                                        text: a,\n                                        escaped: !0\n                                    }\n                                ]\n                            }) : n += a;\n                            continue;\n                        }\n                    default:\n                        {\n                            let o = 'Token with \"' + r.type + '\" type was not found.';\n                            if (this.options.silent) return console.error(o), \"\";\n                            throw new Error(o);\n                        }\n                }\n            }\n            return n;\n        }\n        parseInline(e, t = this.renderer) {\n            let n = \"\";\n            for(let s = 0; s < e.length; s++){\n                let i = e[s];\n                if (this.options.extensions?.renderers?.[i.type]) {\n                    let o = this.options.extensions.renderers[i.type].call({\n                        parser: this\n                    }, i);\n                    if (o !== !1 || ![\n                        \"escape\",\n                        \"html\",\n                        \"link\",\n                        \"image\",\n                        \"strong\",\n                        \"em\",\n                        \"codespan\",\n                        \"br\",\n                        \"del\",\n                        \"text\"\n                    ].includes(i.type)) {\n                        n += o || \"\";\n                        continue;\n                    }\n                }\n                let r = i;\n                switch(r.type){\n                    case \"escape\":\n                        n += t.text(r);\n                        break;\n                    case \"html\":\n                        n += t.html(r);\n                        break;\n                    case \"link\":\n                        n += t.link(r);\n                        break;\n                    case \"image\":\n                        n += t.image(r);\n                        break;\n                    case \"strong\":\n                        n += t.strong(r);\n                        break;\n                    case \"em\":\n                        n += t.em(r);\n                        break;\n                    case \"codespan\":\n                        n += t.codespan(r);\n                        break;\n                    case \"br\":\n                        n += t.br(r);\n                        break;\n                    case \"del\":\n                        n += t.del(r);\n                        break;\n                    case \"text\":\n                        n += t.text(r);\n                        break;\n                    default:\n                        {\n                            let o = 'Token with \"' + r.type + '\" type was not found.';\n                            if (this.options.silent) return console.error(o), \"\";\n                            throw new Error(o);\n                        }\n                }\n            }\n            return n;\n        }\n    };\n    var L = class {\n        options;\n        block;\n        constructor(e){\n            this.options = e || w;\n        }\n        static passThroughHooks = new Set([\n            \"preprocess\",\n            \"postprocess\",\n            \"processAllTokens\"\n        ]);\n        preprocess(e) {\n            return e;\n        }\n        postprocess(e) {\n            return e;\n        }\n        processAllTokens(e) {\n            return e;\n        }\n        provideLexer() {\n            return this.block ? x.lex : x.lexInline;\n        }\n        provideParser() {\n            return this.block ? b.parse : b.parseInline;\n        }\n    };\n    var E = class {\n        defaults = z();\n        options = this.setOptions;\n        parse = this.parseMarkdown(!0);\n        parseInline = this.parseMarkdown(!1);\n        Parser = b;\n        Renderer = $;\n        TextRenderer = _;\n        Lexer = x;\n        Tokenizer = S;\n        Hooks = L;\n        constructor(...e){\n            this.use(...e);\n        }\n        walkTokens(e, t) {\n            let n = [];\n            for (let s of e)switch(n = n.concat(t.call(this, s)), s.type){\n                case \"table\":\n                    {\n                        let i = s;\n                        for (let r of i.header)n = n.concat(this.walkTokens(r.tokens, t));\n                        for (let r of i.rows)for (let o of r)n = n.concat(this.walkTokens(o.tokens, t));\n                        break;\n                    }\n                case \"list\":\n                    {\n                        let i = s;\n                        n = n.concat(this.walkTokens(i.items, t));\n                        break;\n                    }\n                default:\n                    {\n                        let i = s;\n                        this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((r)=>{\n                            let o = i[r].flat(1 / 0);\n                            n = n.concat(this.walkTokens(o, t));\n                        }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));\n                    }\n            }\n            return n;\n        }\n        use(...e) {\n            let t = this.defaults.extensions || {\n                renderers: {},\n                childTokens: {}\n            };\n            return e.forEach((n)=>{\n                let s = {\n                    ...n\n                };\n                if (s.async = this.defaults.async || s.async || !1, n.extensions && (n.extensions.forEach((i)=>{\n                    if (!i.name) throw new Error(\"extension name required\");\n                    if (\"renderer\" in i) {\n                        let r = t.renderers[i.name];\n                        r ? t.renderers[i.name] = function(...o) {\n                            let a = i.renderer.apply(this, o);\n                            return a === !1 && (a = r.apply(this, o)), a;\n                        } : t.renderers[i.name] = i.renderer;\n                    }\n                    if (\"tokenizer\" in i) {\n                        if (!i.level || i.level !== \"block\" && i.level !== \"inline\") throw new Error(\"extension level must be 'block' or 'inline'\");\n                        let r = t[i.level];\n                        r ? r.unshift(i.tokenizer) : t[i.level] = [\n                            i.tokenizer\n                        ], i.start && (i.level === \"block\" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [\n                            i.start\n                        ] : i.level === \"inline\" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [\n                            i.start\n                        ]));\n                    }\n                    \"childTokens\" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);\n                }), s.extensions = t), n.renderer) {\n                    let i = this.defaults.renderer || new $(this.defaults);\n                    for(let r in n.renderer){\n                        if (!(r in i)) throw new Error(`renderer '${r}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"parser\"\n                        ].includes(r)) continue;\n                        let o = r, a = n.renderer[o], c = i[o];\n                        i[o] = (...p)=>{\n                            let u = a.apply(i, p);\n                            return u === !1 && (u = c.apply(i, p)), u || \"\";\n                        };\n                    }\n                    s.renderer = i;\n                }\n                if (n.tokenizer) {\n                    let i = this.defaults.tokenizer || new S(this.defaults);\n                    for(let r in n.tokenizer){\n                        if (!(r in i)) throw new Error(`tokenizer '${r}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"rules\",\n                            \"lexer\"\n                        ].includes(r)) continue;\n                        let o = r, a = n.tokenizer[o], c = i[o];\n                        i[o] = (...p)=>{\n                            let u = a.apply(i, p);\n                            return u === !1 && (u = c.apply(i, p)), u;\n                        };\n                    }\n                    s.tokenizer = i;\n                }\n                if (n.hooks) {\n                    let i = this.defaults.hooks || new L;\n                    for(let r in n.hooks){\n                        if (!(r in i)) throw new Error(`hook '${r}' does not exist`);\n                        if ([\n                            \"options\",\n                            \"block\"\n                        ].includes(r)) continue;\n                        let o = r, a = n.hooks[o], c = i[o];\n                        L.passThroughHooks.has(r) ? i[o] = (p)=>{\n                            if (this.defaults.async) return Promise.resolve(a.call(i, p)).then((d)=>c.call(i, d));\n                            let u = a.call(i, p);\n                            return c.call(i, u);\n                        } : i[o] = (...p)=>{\n                            let u = a.apply(i, p);\n                            return u === !1 && (u = c.apply(i, p)), u;\n                        };\n                    }\n                    s.hooks = i;\n                }\n                if (n.walkTokens) {\n                    let i = this.defaults.walkTokens, r = n.walkTokens;\n                    s.walkTokens = function(o) {\n                        let a = [];\n                        return a.push(r.call(this, o)), i && (a = a.concat(i.call(this, o))), a;\n                    };\n                }\n                this.defaults = {\n                    ...this.defaults,\n                    ...s\n                };\n            }), this;\n        }\n        setOptions(e) {\n            return this.defaults = {\n                ...this.defaults,\n                ...e\n            }, this;\n        }\n        lexer(e, t) {\n            return x.lex(e, t ?? this.defaults);\n        }\n        parser(e, t) {\n            return b.parse(e, t ?? this.defaults);\n        }\n        parseMarkdown(e) {\n            return (n, s)=>{\n                let i = {\n                    ...s\n                }, r = {\n                    ...this.defaults,\n                    ...i\n                }, o = this.onError(!!r.silent, !!r.async);\n                if (this.defaults.async === !0 && i.async === !1) return o(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));\n                if (typeof n > \"u\" || n === null) return o(new Error(\"marked(): input parameter is undefined or null\"));\n                if (typeof n != \"string\") return o(new Error(\"marked(): input parameter is of type \" + Object.prototype.toString.call(n) + \", string expected\"));\n                r.hooks && (r.hooks.options = r, r.hooks.block = e);\n                let a = r.hooks ? r.hooks.provideLexer() : e ? x.lex : x.lexInline, c = r.hooks ? r.hooks.provideParser() : e ? b.parse : b.parseInline;\n                if (r.async) return Promise.resolve(r.hooks ? r.hooks.preprocess(n) : n).then((p)=>a(p, r)).then((p)=>r.hooks ? r.hooks.processAllTokens(p) : p).then((p)=>r.walkTokens ? Promise.all(this.walkTokens(p, r.walkTokens)).then(()=>p) : p).then((p)=>c(p, r)).then((p)=>r.hooks ? r.hooks.postprocess(p) : p).catch(o);\n                try {\n                    r.hooks && (n = r.hooks.preprocess(n));\n                    let p = a(n, r);\n                    r.hooks && (p = r.hooks.processAllTokens(p)), r.walkTokens && this.walkTokens(p, r.walkTokens);\n                    let u = c(p, r);\n                    return r.hooks && (u = r.hooks.postprocess(u)), u;\n                } catch (p) {\n                    return o(p);\n                }\n            };\n        }\n        onError(e, t) {\n            return (n)=>{\n                if (n.message += `\nPlease report this to https://github.com/markedjs/marked.`, e) {\n                    let s = \"<p>An error occurred:</p><pre>\" + R(n.message + \"\", !0) + \"</pre>\";\n                    return t ? Promise.resolve(s) : s;\n                }\n                if (t) return Promise.reject(n);\n                throw n;\n            };\n        }\n    };\n    var M = new E;\n    function k(l, e) {\n        return M.parse(l, e);\n    }\n    k.options = k.setOptions = function(l) {\n        return M.setOptions(l), k.defaults = M.defaults, N(k.defaults), k;\n    };\n    k.getDefaults = z;\n    k.defaults = w;\n    k.use = function(...l) {\n        return M.use(...l), k.defaults = M.defaults, N(k.defaults), k;\n    };\n    k.walkTokens = function(l, e) {\n        return M.walkTokens(l, e);\n    };\n    k.parseInline = M.parseInline;\n    k.Parser = b;\n    k.parser = b.parse;\n    k.Renderer = $;\n    k.TextRenderer = _;\n    k.Lexer = x;\n    k.lexer = x.lex;\n    k.Tokenizer = S;\n    k.Hooks = L;\n    k.parse = k;\n    var it = k.options, ot = k.setOptions, lt = k.use, at = k.walkTokens, ct = k.parseInline, pt = k, ut = b.parse, ht = x.lex;\n    if (__exports != exports) module1.exports = exports;\n    return module1.exports;\n});\n\n\nvar $d349326c2b62c55f$exports = {};\n/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */ (function(global, factory) {\n    $d349326c2b62c55f$exports = factory();\n})($d349326c2b62c55f$exports, function() {\n    'use strict';\n    const { entries: entries, setPrototypeOf: setPrototypeOf, isFrozen: isFrozen, getPrototypeOf: getPrototypeOf, getOwnPropertyDescriptor: getOwnPropertyDescriptor } = Object;\n    let { freeze: freeze, seal: seal, create: create } = Object; // eslint-disable-line import/no-mutable-exports\n    let { apply: apply, construct: construct } = typeof Reflect !== 'undefined' && Reflect;\n    if (!freeze) freeze = function freeze(x) {\n        return x;\n    };\n    if (!seal) seal = function seal(x) {\n        return x;\n    };\n    if (!apply) apply = function apply(fun, thisValue, args) {\n        return fun.apply(thisValue, args);\n    };\n    if (!construct) construct = function construct(Func, args) {\n        return new Func(...args);\n    };\n    const arrayForEach = unapply(Array.prototype.forEach);\n    const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\n    const arrayPop = unapply(Array.prototype.pop);\n    const arrayPush = unapply(Array.prototype.push);\n    const arraySplice = unapply(Array.prototype.splice);\n    const stringToLowerCase = unapply(String.prototype.toLowerCase);\n    const stringToString = unapply(String.prototype.toString);\n    const stringMatch = unapply(String.prototype.match);\n    const stringReplace = unapply(String.prototype.replace);\n    const stringIndexOf = unapply(String.prototype.indexOf);\n    const stringTrim = unapply(String.prototype.trim);\n    const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n    const regExpTest = unapply(RegExp.prototype.test);\n    const typeErrorCreate = unconstruct(TypeError);\n    /**\n   * Creates a new function that calls the given function with a specified thisArg and arguments.\n   *\n   * @param func - The function to be wrapped and called.\n   * @returns A new function that calls the given function with a specified thisArg and arguments.\n   */ function unapply(func) {\n        return function(thisArg) {\n            if (thisArg instanceof RegExp) thisArg.lastIndex = 0;\n            for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)args[_key - 1] = arguments[_key];\n            return apply(func, thisArg, args);\n        };\n    }\n    /**\n   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n   *\n   * @param func - The constructor function to be wrapped and called.\n   * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n   */ function unconstruct(func) {\n        return function() {\n            for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++)args[_key2] = arguments[_key2];\n            return construct(func, args);\n        };\n    }\n    /**\n   * Add properties to a lookup table\n   *\n   * @param set - The set to which elements will be added.\n   * @param array - The array containing elements to be added to the set.\n   * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n   * @returns The modified set with added elements.\n   */ function addToSet(set, array) {\n        let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n        if (setPrototypeOf) // Make 'in' and truthy checks like Boolean(set.constructor)\n        // independent of any properties defined on Object.prototype.\n        // Prevent prototype setters from intercepting set as a this value.\n        setPrototypeOf(set, null);\n        let l = array.length;\n        while(l--){\n            let element = array[l];\n            if (typeof element === 'string') {\n                const lcElement = transformCaseFunc(element);\n                if (lcElement !== element) {\n                    // Config presets (e.g. tags.js, attrs.js) are immutable.\n                    if (!isFrozen(array)) array[l] = lcElement;\n                    element = lcElement;\n                }\n            }\n            set[element] = true;\n        }\n        return set;\n    }\n    /**\n   * Clean up an array to harden against CSPP\n   *\n   * @param array - The array to be cleaned.\n   * @returns The cleaned version of the array\n   */ function cleanArray(array) {\n        for(let index = 0; index < array.length; index++){\n            const isPropertyExist = objectHasOwnProperty(array, index);\n            if (!isPropertyExist) array[index] = null;\n        }\n        return array;\n    }\n    /**\n   * Shallow clone an object\n   *\n   * @param object - The object to be cloned.\n   * @returns A new object that copies the original.\n   */ function clone(object) {\n        const newObject = create(null);\n        for (const [property, value] of entries(object)){\n            const isPropertyExist = objectHasOwnProperty(object, property);\n            if (isPropertyExist) {\n                if (Array.isArray(value)) newObject[property] = cleanArray(value);\n                else if (value && typeof value === 'object' && value.constructor === Object) newObject[property] = clone(value);\n                else newObject[property] = value;\n            }\n        }\n        return newObject;\n    }\n    /**\n   * This method automatically checks if the prop is function or getter and behaves accordingly.\n   *\n   * @param object - The object to look up the getter function in its prototype chain.\n   * @param prop - The property name for which to find the getter function.\n   * @returns The getter function found in the prototype chain or a fallback function.\n   */ function lookupGetter(object, prop) {\n        while(object !== null){\n            const desc = getOwnPropertyDescriptor(object, prop);\n            if (desc) {\n                if (desc.get) return unapply(desc.get);\n                if (typeof desc.value === 'function') return unapply(desc.value);\n            }\n            object = getPrototypeOf(object);\n        }\n        function fallbackValue() {\n            return null;\n        }\n        return fallbackValue;\n    }\n    const html$1 = freeze([\n        'a',\n        'abbr',\n        'acronym',\n        'address',\n        'area',\n        'article',\n        'aside',\n        'audio',\n        'b',\n        'bdi',\n        'bdo',\n        'big',\n        'blink',\n        'blockquote',\n        'body',\n        'br',\n        'button',\n        'canvas',\n        'caption',\n        'center',\n        'cite',\n        'code',\n        'col',\n        'colgroup',\n        'content',\n        'data',\n        'datalist',\n        'dd',\n        'decorator',\n        'del',\n        'details',\n        'dfn',\n        'dialog',\n        'dir',\n        'div',\n        'dl',\n        'dt',\n        'element',\n        'em',\n        'fieldset',\n        'figcaption',\n        'figure',\n        'font',\n        'footer',\n        'form',\n        'h1',\n        'h2',\n        'h3',\n        'h4',\n        'h5',\n        'h6',\n        'head',\n        'header',\n        'hgroup',\n        'hr',\n        'html',\n        'i',\n        'img',\n        'input',\n        'ins',\n        'kbd',\n        'label',\n        'legend',\n        'li',\n        'main',\n        'map',\n        'mark',\n        'marquee',\n        'menu',\n        'menuitem',\n        'meter',\n        'nav',\n        'nobr',\n        'ol',\n        'optgroup',\n        'option',\n        'output',\n        'p',\n        'picture',\n        'pre',\n        'progress',\n        'q',\n        'rp',\n        'rt',\n        'ruby',\n        's',\n        'samp',\n        'section',\n        'select',\n        'shadow',\n        'small',\n        'source',\n        'spacer',\n        'span',\n        'strike',\n        'strong',\n        'style',\n        'sub',\n        'summary',\n        'sup',\n        'table',\n        'tbody',\n        'td',\n        'template',\n        'textarea',\n        'tfoot',\n        'th',\n        'thead',\n        'time',\n        'tr',\n        'track',\n        'tt',\n        'u',\n        'ul',\n        'var',\n        'video',\n        'wbr'\n    ]);\n    const svg$1 = freeze([\n        'svg',\n        'a',\n        'altglyph',\n        'altglyphdef',\n        'altglyphitem',\n        'animatecolor',\n        'animatemotion',\n        'animatetransform',\n        'circle',\n        'clippath',\n        'defs',\n        'desc',\n        'ellipse',\n        'filter',\n        'font',\n        'g',\n        'glyph',\n        'glyphref',\n        'hkern',\n        'image',\n        'line',\n        'lineargradient',\n        'marker',\n        'mask',\n        'metadata',\n        'mpath',\n        'path',\n        'pattern',\n        'polygon',\n        'polyline',\n        'radialgradient',\n        'rect',\n        'stop',\n        'style',\n        'switch',\n        'symbol',\n        'text',\n        'textpath',\n        'title',\n        'tref',\n        'tspan',\n        'view',\n        'vkern'\n    ]);\n    const svgFilters = freeze([\n        'feBlend',\n        'feColorMatrix',\n        'feComponentTransfer',\n        'feComposite',\n        'feConvolveMatrix',\n        'feDiffuseLighting',\n        'feDisplacementMap',\n        'feDistantLight',\n        'feDropShadow',\n        'feFlood',\n        'feFuncA',\n        'feFuncB',\n        'feFuncG',\n        'feFuncR',\n        'feGaussianBlur',\n        'feImage',\n        'feMerge',\n        'feMergeNode',\n        'feMorphology',\n        'feOffset',\n        'fePointLight',\n        'feSpecularLighting',\n        'feSpotLight',\n        'feTile',\n        'feTurbulence'\n    ]);\n    // List of SVG elements that are disallowed by default.\n    // We still need to know them so that we can do namespace\n    // checks properly in case one wants to add them to\n    // allow-list.\n    const svgDisallowed = freeze([\n        'animate',\n        'color-profile',\n        'cursor',\n        'discard',\n        'font-face',\n        'font-face-format',\n        'font-face-name',\n        'font-face-src',\n        'font-face-uri',\n        'foreignobject',\n        'hatch',\n        'hatchpath',\n        'mesh',\n        'meshgradient',\n        'meshpatch',\n        'meshrow',\n        'missing-glyph',\n        'script',\n        'set',\n        'solidcolor',\n        'unknown',\n        'use'\n    ]);\n    const mathMl$1 = freeze([\n        'math',\n        'menclose',\n        'merror',\n        'mfenced',\n        'mfrac',\n        'mglyph',\n        'mi',\n        'mlabeledtr',\n        'mmultiscripts',\n        'mn',\n        'mo',\n        'mover',\n        'mpadded',\n        'mphantom',\n        'mroot',\n        'mrow',\n        'ms',\n        'mspace',\n        'msqrt',\n        'mstyle',\n        'msub',\n        'msup',\n        'msubsup',\n        'mtable',\n        'mtd',\n        'mtext',\n        'mtr',\n        'munder',\n        'munderover',\n        'mprescripts'\n    ]);\n    // Similarly to SVG, we want to know all MathML elements,\n    // even those that we disallow by default.\n    const mathMlDisallowed = freeze([\n        'maction',\n        'maligngroup',\n        'malignmark',\n        'mlongdiv',\n        'mscarries',\n        'mscarry',\n        'msgroup',\n        'mstack',\n        'msline',\n        'msrow',\n        'semantics',\n        'annotation',\n        'annotation-xml',\n        'mprescripts',\n        'none'\n    ]);\n    const text = freeze([\n        '#text'\n    ]);\n    const html = freeze([\n        'accept',\n        'action',\n        'align',\n        'alt',\n        'autocapitalize',\n        'autocomplete',\n        'autopictureinpicture',\n        'autoplay',\n        'background',\n        'bgcolor',\n        'border',\n        'capture',\n        'cellpadding',\n        'cellspacing',\n        'checked',\n        'cite',\n        'class',\n        'clear',\n        'color',\n        'cols',\n        'colspan',\n        'controls',\n        'controlslist',\n        'coords',\n        'crossorigin',\n        'datetime',\n        'decoding',\n        'default',\n        'dir',\n        'disabled',\n        'disablepictureinpicture',\n        'disableremoteplayback',\n        'download',\n        'draggable',\n        'enctype',\n        'enterkeyhint',\n        'face',\n        'for',\n        'headers',\n        'height',\n        'hidden',\n        'high',\n        'href',\n        'hreflang',\n        'id',\n        'inputmode',\n        'integrity',\n        'ismap',\n        'kind',\n        'label',\n        'lang',\n        'list',\n        'loading',\n        'loop',\n        'low',\n        'max',\n        'maxlength',\n        'media',\n        'method',\n        'min',\n        'minlength',\n        'multiple',\n        'muted',\n        'name',\n        'nonce',\n        'noshade',\n        'novalidate',\n        'nowrap',\n        'open',\n        'optimum',\n        'pattern',\n        'placeholder',\n        'playsinline',\n        'popover',\n        'popovertarget',\n        'popovertargetaction',\n        'poster',\n        'preload',\n        'pubdate',\n        'radiogroup',\n        'readonly',\n        'rel',\n        'required',\n        'rev',\n        'reversed',\n        'role',\n        'rows',\n        'rowspan',\n        'spellcheck',\n        'scope',\n        'selected',\n        'shape',\n        'size',\n        'sizes',\n        'span',\n        'srclang',\n        'start',\n        'src',\n        'srcset',\n        'step',\n        'style',\n        'summary',\n        'tabindex',\n        'title',\n        'translate',\n        'type',\n        'usemap',\n        'valign',\n        'value',\n        'width',\n        'wrap',\n        'xmlns',\n        'slot'\n    ]);\n    const svg = freeze([\n        'accent-height',\n        'accumulate',\n        'additive',\n        'alignment-baseline',\n        'amplitude',\n        'ascent',\n        'attributename',\n        'attributetype',\n        'azimuth',\n        'basefrequency',\n        'baseline-shift',\n        'begin',\n        'bias',\n        'by',\n        'class',\n        'clip',\n        'clippathunits',\n        'clip-path',\n        'clip-rule',\n        'color',\n        'color-interpolation',\n        'color-interpolation-filters',\n        'color-profile',\n        'color-rendering',\n        'cx',\n        'cy',\n        'd',\n        'dx',\n        'dy',\n        'diffuseconstant',\n        'direction',\n        'display',\n        'divisor',\n        'dur',\n        'edgemode',\n        'elevation',\n        'end',\n        'exponent',\n        'fill',\n        'fill-opacity',\n        'fill-rule',\n        'filter',\n        'filterunits',\n        'flood-color',\n        'flood-opacity',\n        'font-family',\n        'font-size',\n        'font-size-adjust',\n        'font-stretch',\n        'font-style',\n        'font-variant',\n        'font-weight',\n        'fx',\n        'fy',\n        'g1',\n        'g2',\n        'glyph-name',\n        'glyphref',\n        'gradientunits',\n        'gradienttransform',\n        'height',\n        'href',\n        'id',\n        'image-rendering',\n        'in',\n        'in2',\n        'intercept',\n        'k',\n        'k1',\n        'k2',\n        'k3',\n        'k4',\n        'kerning',\n        'keypoints',\n        'keysplines',\n        'keytimes',\n        'lang',\n        'lengthadjust',\n        'letter-spacing',\n        'kernelmatrix',\n        'kernelunitlength',\n        'lighting-color',\n        'local',\n        'marker-end',\n        'marker-mid',\n        'marker-start',\n        'markerheight',\n        'markerunits',\n        'markerwidth',\n        'maskcontentunits',\n        'maskunits',\n        'max',\n        'mask',\n        'media',\n        'method',\n        'mode',\n        'min',\n        'name',\n        'numoctaves',\n        'offset',\n        'operator',\n        'opacity',\n        'order',\n        'orient',\n        'orientation',\n        'origin',\n        'overflow',\n        'paint-order',\n        'path',\n        'pathlength',\n        'patterncontentunits',\n        'patterntransform',\n        'patternunits',\n        'points',\n        'preservealpha',\n        'preserveaspectratio',\n        'primitiveunits',\n        'r',\n        'rx',\n        'ry',\n        'radius',\n        'refx',\n        'refy',\n        'repeatcount',\n        'repeatdur',\n        'restart',\n        'result',\n        'rotate',\n        'scale',\n        'seed',\n        'shape-rendering',\n        'slope',\n        'specularconstant',\n        'specularexponent',\n        'spreadmethod',\n        'startoffset',\n        'stddeviation',\n        'stitchtiles',\n        'stop-color',\n        'stop-opacity',\n        'stroke-dasharray',\n        'stroke-dashoffset',\n        'stroke-linecap',\n        'stroke-linejoin',\n        'stroke-miterlimit',\n        'stroke-opacity',\n        'stroke',\n        'stroke-width',\n        'style',\n        'surfacescale',\n        'systemlanguage',\n        'tabindex',\n        'tablevalues',\n        'targetx',\n        'targety',\n        'transform',\n        'transform-origin',\n        'text-anchor',\n        'text-decoration',\n        'text-rendering',\n        'textlength',\n        'type',\n        'u1',\n        'u2',\n        'unicode',\n        'values',\n        'viewbox',\n        'visibility',\n        'version',\n        'vert-adv-y',\n        'vert-origin-x',\n        'vert-origin-y',\n        'width',\n        'word-spacing',\n        'wrap',\n        'writing-mode',\n        'xchannelselector',\n        'ychannelselector',\n        'x',\n        'x1',\n        'x2',\n        'xmlns',\n        'y',\n        'y1',\n        'y2',\n        'z',\n        'zoomandpan'\n    ]);\n    const mathMl = freeze([\n        'accent',\n        'accentunder',\n        'align',\n        'bevelled',\n        'close',\n        'columnsalign',\n        'columnlines',\n        'columnspan',\n        'denomalign',\n        'depth',\n        'dir',\n        'display',\n        'displaystyle',\n        'encoding',\n        'fence',\n        'frame',\n        'height',\n        'href',\n        'id',\n        'largeop',\n        'length',\n        'linethickness',\n        'lspace',\n        'lquote',\n        'mathbackground',\n        'mathcolor',\n        'mathsize',\n        'mathvariant',\n        'maxsize',\n        'minsize',\n        'movablelimits',\n        'notation',\n        'numalign',\n        'open',\n        'rowalign',\n        'rowlines',\n        'rowspacing',\n        'rowspan',\n        'rspace',\n        'rquote',\n        'scriptlevel',\n        'scriptminsize',\n        'scriptsizemultiplier',\n        'selection',\n        'separator',\n        'separators',\n        'stretchy',\n        'subscriptshift',\n        'supscriptshift',\n        'symmetric',\n        'voffset',\n        'width',\n        'xmlns'\n    ]);\n    const xml = freeze([\n        'xlink:href',\n        'xml:id',\n        'xlink:title',\n        'xml:space',\n        'xmlns:xlink'\n    ]);\n    // eslint-disable-next-line unicorn/better-regex\n    const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n    const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n    const TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\n    const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\n    const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n    const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n    );\n    const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n    const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n    );\n    const DOCTYPE_NAME = seal(/^html$/i);\n    const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n    var EXPRESSIONS = /*#__PURE__*/ Object.freeze({\n        __proto__: null,\n        ARIA_ATTR: ARIA_ATTR,\n        ATTR_WHITESPACE: ATTR_WHITESPACE,\n        CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n        DATA_ATTR: DATA_ATTR,\n        DOCTYPE_NAME: DOCTYPE_NAME,\n        ERB_EXPR: ERB_EXPR,\n        IS_ALLOWED_URI: IS_ALLOWED_URI,\n        IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n        MUSTACHE_EXPR: MUSTACHE_EXPR,\n        TMPLIT_EXPR: TMPLIT_EXPR\n    });\n    /* eslint-disable @typescript-eslint/indent */ // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n    const NODE_TYPE = {\n        element: 1,\n        attribute: 2,\n        text: 3,\n        cdataSection: 4,\n        entityReference: 5,\n        // Deprecated\n        entityNode: 6,\n        // Deprecated\n        progressingInstruction: 7,\n        comment: 8,\n        document: 9,\n        documentType: 10,\n        documentFragment: 11,\n        notation: 12 // Deprecated\n    };\n    const getGlobal = function getGlobal() {\n        return typeof window === 'undefined' ? null : window;\n    };\n    /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param trustedTypes The policy factory.\n   * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */ const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n        if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') return null;\n        // Allow the callers to control the unique policy name\n        // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n        // Policy creation with duplicate names throws in Trusted Types.\n        let suffix = null;\n        const ATTR_NAME = 'data-tt-policy-suffix';\n        if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) suffix = purifyHostElement.getAttribute(ATTR_NAME);\n        const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n        try {\n            return trustedTypes.createPolicy(policyName, {\n                createHTML (html) {\n                    return html;\n                },\n                createScriptURL (scriptUrl) {\n                    return scriptUrl;\n                }\n            });\n        } catch (_) {\n            // Policy creation failed (most likely another DOMPurify script has\n            // already run). Skip creating the policy, as this will only cause errors\n            // if TT are enforced.\n            console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n            return null;\n        }\n    };\n    const _createHooksMap = function _createHooksMap() {\n        return {\n            afterSanitizeAttributes: [],\n            afterSanitizeElements: [],\n            afterSanitizeShadowDOM: [],\n            beforeSanitizeAttributes: [],\n            beforeSanitizeElements: [],\n            beforeSanitizeShadowDOM: [],\n            uponSanitizeAttribute: [],\n            uponSanitizeElement: [],\n            uponSanitizeShadowNode: []\n        };\n    };\n    function createDOMPurify() {\n        let window1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n        const DOMPurify = (root)=>createDOMPurify(root);\n        DOMPurify.version = '3.2.6';\n        DOMPurify.removed = [];\n        if (!window1 || !window1.document || window1.document.nodeType !== NODE_TYPE.document || !window1.Element) {\n            // Not running in a browser, provide a factory function\n            // so that you can pass your own Window\n            DOMPurify.isSupported = false;\n            return DOMPurify;\n        }\n        let { document: document } = window1;\n        const originalDocument = document;\n        const currentScript = originalDocument.currentScript;\n        const { DocumentFragment: DocumentFragment, HTMLTemplateElement: HTMLTemplateElement, Node: Node, Element: Element, NodeFilter: NodeFilter, NamedNodeMap: NamedNodeMap = window1.NamedNodeMap || window1.MozNamedAttrMap, HTMLFormElement: HTMLFormElement, DOMParser: DOMParser, trustedTypes: trustedTypes } = window1;\n        const ElementPrototype = Element.prototype;\n        const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n        const remove = lookupGetter(ElementPrototype, 'remove');\n        const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n        const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n        const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n        // As per issue #47, the web-components registry is inherited by a\n        // new document created via createHTMLDocument. As per the spec\n        // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n        // a new empty registry is used when creating a template contents owner\n        // document, so we use that as our parent document to ensure nothing\n        // is inherited.\n        if (typeof HTMLTemplateElement === 'function') {\n            const template = document.createElement('template');\n            if (template.content && template.content.ownerDocument) document = template.content.ownerDocument;\n        }\n        let trustedTypesPolicy;\n        let emptyHTML = '';\n        const { implementation: implementation, createNodeIterator: createNodeIterator, createDocumentFragment: createDocumentFragment, getElementsByTagName: getElementsByTagName } = document;\n        const { importNode: importNode } = originalDocument;\n        let hooks = _createHooksMap();\n        /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */ DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n        const { MUSTACHE_EXPR: MUSTACHE_EXPR, ERB_EXPR: ERB_EXPR, TMPLIT_EXPR: TMPLIT_EXPR, DATA_ATTR: DATA_ATTR, ARIA_ATTR: ARIA_ATTR, IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA, ATTR_WHITESPACE: ATTR_WHITESPACE, CUSTOM_ELEMENT: CUSTOM_ELEMENT } = EXPRESSIONS;\n        let { IS_ALLOWED_URI: IS_ALLOWED_URI$1 } = EXPRESSIONS;\n        /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */ /* allowed element names */ let ALLOWED_TAGS = null;\n        const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n            ...html$1,\n            ...svg$1,\n            ...svgFilters,\n            ...mathMl$1,\n            ...text\n        ]);\n        /* Allowed attribute names */ let ALLOWED_ATTR = null;\n        const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n            ...html,\n            ...svg,\n            ...mathMl,\n            ...xml\n        ]);\n        /*\n     * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */ let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n            tagNameCheck: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: null\n            },\n            attributeNameCheck: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: null\n            },\n            allowCustomizedBuiltInElements: {\n                writable: true,\n                configurable: false,\n                enumerable: true,\n                value: false\n            }\n        }));\n        /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */ let FORBID_TAGS = null;\n        /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */ let FORBID_ATTR = null;\n        /* Decide if ARIA attributes are okay */ let ALLOW_ARIA_ATTR = true;\n        /* Decide if custom data attributes are okay */ let ALLOW_DATA_ATTR = true;\n        /* Decide if unknown protocols are okay */ let ALLOW_UNKNOWN_PROTOCOLS = false;\n        /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */ let ALLOW_SELF_CLOSE_IN_ATTR = true;\n        /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */ let SAFE_FOR_TEMPLATES = false;\n        /* Output should be safe even for XML used within HTML and alike.\n     * This means, DOMPurify removes comments when containing risky content.\n     */ let SAFE_FOR_XML = true;\n        /* Decide if document with <html>... should be returned */ let WHOLE_DOCUMENT = false;\n        /* Track whether config is already set on this instance of DOMPurify. */ let SET_CONFIG = false;\n        /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */ let FORCE_BODY = false;\n        /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */ let RETURN_DOM = false;\n        /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */ let RETURN_DOM_FRAGMENT = false;\n        /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */ let RETURN_TRUSTED_TYPE = false;\n        /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */ let SANITIZE_DOM = true;\n        /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */ let SANITIZE_NAMED_PROPS = false;\n        const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n        /* Keep element content when removing element? */ let KEEP_CONTENT = true;\n        /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */ let IN_PLACE = false;\n        /* Allow usage of profiles like html, svg and mathMl */ let USE_PROFILES = {};\n        /* Tags to ignore content of when KEEP_CONTENT is true */ let FORBID_CONTENTS = null;\n        const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n            'annotation-xml',\n            'audio',\n            'colgroup',\n            'desc',\n            'foreignobject',\n            'head',\n            'iframe',\n            'math',\n            'mi',\n            'mn',\n            'mo',\n            'ms',\n            'mtext',\n            'noembed',\n            'noframes',\n            'noscript',\n            'plaintext',\n            'script',\n            'style',\n            'svg',\n            'template',\n            'thead',\n            'title',\n            'video',\n            'xmp'\n        ]);\n        /* Tags that are safe for data: URIs */ let DATA_URI_TAGS = null;\n        const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n            'audio',\n            'video',\n            'img',\n            'source',\n            'image',\n            'track'\n        ]);\n        /* Attributes safe for values like \"javascript:\" */ let URI_SAFE_ATTRIBUTES = null;\n        const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n            'alt',\n            'class',\n            'for',\n            'id',\n            'label',\n            'name',\n            'pattern',\n            'placeholder',\n            'role',\n            'summary',\n            'title',\n            'value',\n            'style',\n            'xmlns'\n        ]);\n        const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n        const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n        const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n        /* Document namespace */ let NAMESPACE = HTML_NAMESPACE;\n        let IS_EMPTY_INPUT = false;\n        /* Allowed XHTML+XML namespaces */ let ALLOWED_NAMESPACES = null;\n        const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [\n            MATHML_NAMESPACE,\n            SVG_NAMESPACE,\n            HTML_NAMESPACE\n        ], stringToString);\n        let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n            'mi',\n            'mo',\n            'mn',\n            'ms',\n            'mtext'\n        ]);\n        let HTML_INTEGRATION_POINTS = addToSet({}, [\n            'annotation-xml'\n        ]);\n        // Certain elements are allowed in both SVG and HTML\n        // namespace. We need to specify them explicitly\n        // so that they don't get erroneously deleted from\n        // HTML namespace.\n        const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n            'title',\n            'style',\n            'font',\n            'a',\n            'script'\n        ]);\n        /* Parsing of strict XHTML documents */ let PARSER_MEDIA_TYPE = null;\n        const SUPPORTED_PARSER_MEDIA_TYPES = [\n            'application/xhtml+xml',\n            'text/html'\n        ];\n        const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n        let transformCaseFunc = null;\n        /* Keep a reference to config to pass to hooks */ let CONFIG = null;\n        /* Ideally, do not touch anything below this line */ /* ______________________________________________ */ const formElement = document.createElement('form');\n        const isRegexOrFunction = function isRegexOrFunction(testValue) {\n            return testValue instanceof RegExp || testValue instanceof Function;\n        };\n        /**\n     * _parseConfig\n     *\n     * @param cfg optional config literal\n     */ // eslint-disable-next-line complexity\n        const _parseConfig = function _parseConfig() {\n            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            if (CONFIG && CONFIG === cfg) return;\n            /* Shield configuration object from tampering */ if (!cfg || typeof cfg !== 'object') cfg = {};\n            /* Shield configuration object from prototype pollution */ cfg = clone(cfg);\n            PARSER_MEDIA_TYPE = // eslint-disable-next-line unicorn/prefer-includes\n            SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n            // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n            transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n            /* Set configuration parameters */ ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n            ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n            ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n            URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n            DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n            FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n            FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n            FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n            USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n            ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n            ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n            ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n            ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n            SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n            SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n            WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n            RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n            RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n            RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n            FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n            SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n            SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n            KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n            IN_PLACE = cfg.IN_PLACE || false; // Default false\n            IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n            NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n            MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n            HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n            CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n            if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n            if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n            if (SAFE_FOR_TEMPLATES) ALLOW_DATA_ATTR = false;\n            if (RETURN_DOM_FRAGMENT) RETURN_DOM = true;\n            /* Parse profile info */ if (USE_PROFILES) {\n                ALLOWED_TAGS = addToSet({}, text);\n                ALLOWED_ATTR = [];\n                if (USE_PROFILES.html === true) {\n                    addToSet(ALLOWED_TAGS, html$1);\n                    addToSet(ALLOWED_ATTR, html);\n                }\n                if (USE_PROFILES.svg === true) {\n                    addToSet(ALLOWED_TAGS, svg$1);\n                    addToSet(ALLOWED_ATTR, svg);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n                if (USE_PROFILES.svgFilters === true) {\n                    addToSet(ALLOWED_TAGS, svgFilters);\n                    addToSet(ALLOWED_ATTR, svg);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n                if (USE_PROFILES.mathMl === true) {\n                    addToSet(ALLOWED_TAGS, mathMl$1);\n                    addToSet(ALLOWED_ATTR, mathMl);\n                    addToSet(ALLOWED_ATTR, xml);\n                }\n            }\n            /* Merge configuration parameters */ if (cfg.ADD_TAGS) {\n                if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) ALLOWED_TAGS = clone(ALLOWED_TAGS);\n                addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n            }\n            if (cfg.ADD_ATTR) {\n                if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) ALLOWED_ATTR = clone(ALLOWED_ATTR);\n                addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n            }\n            if (cfg.ADD_URI_SAFE_ATTR) addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n            if (cfg.FORBID_CONTENTS) {\n                if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) FORBID_CONTENTS = clone(FORBID_CONTENTS);\n                addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n            }\n            /* Add #text in case KEEP_CONTENT is set to true */ if (KEEP_CONTENT) ALLOWED_TAGS['#text'] = true;\n            /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */ if (WHOLE_DOCUMENT) addToSet(ALLOWED_TAGS, [\n                'html',\n                'head',\n                'body'\n            ]);\n            /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */ if (ALLOWED_TAGS.table) {\n                addToSet(ALLOWED_TAGS, [\n                    'tbody'\n                ]);\n                delete FORBID_TAGS.tbody;\n            }\n            if (cfg.TRUSTED_TYPES_POLICY) {\n                if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n                if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n                // Overwrite existing TrustedTypes policy.\n                trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n                // Sign local variables required by `sanitize`.\n                emptyHTML = trustedTypesPolicy.createHTML('');\n            } else {\n                // Uninitialized policy, attempt to initialize the internal dompurify policy.\n                if (trustedTypesPolicy === undefined) trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n                // If creating the internal policy succeeded sign internal variables.\n                if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') emptyHTML = trustedTypesPolicy.createHTML('');\n            }\n            // Prevent further manipulation of configuration.\n            // Not available in IE8, Safari 5, etc.\n            if (freeze) freeze(cfg);\n            CONFIG = cfg;\n        };\n        /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */ const ALL_SVG_TAGS = addToSet({}, [\n            ...svg$1,\n            ...svgFilters,\n            ...svgDisallowed\n        ]);\n        const ALL_MATHML_TAGS = addToSet({}, [\n            ...mathMl$1,\n            ...mathMlDisallowed\n        ]);\n        /**\n     * @param element a DOM element whose namespace is being checked\n     * @returns Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */ const _checkValidNamespace = function _checkValidNamespace(element) {\n            let parent = getParentNode(element);\n            // In JSDOM, if we're inside shadow DOM, then parentNode\n            // can be null. We just simulate parent in this case.\n            if (!parent || !parent.tagName) parent = {\n                namespaceURI: NAMESPACE,\n                tagName: 'template'\n            };\n            const tagName = stringToLowerCase(element.tagName);\n            const parentTagName = stringToLowerCase(parent.tagName);\n            if (!ALLOWED_NAMESPACES[element.namespaceURI]) return false;\n            if (element.namespaceURI === SVG_NAMESPACE) {\n                // The only way to switch from HTML namespace to SVG\n                // is via <svg>. If it happens via any other tag, then\n                // it should be killed.\n                if (parent.namespaceURI === HTML_NAMESPACE) return tagName === 'svg';\n                // The only way to switch from MathML to SVG is via`\n                // svg if parent is either <annotation-xml> or MathML\n                // text integration points.\n                if (parent.namespaceURI === MATHML_NAMESPACE) return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n                // We only allow elements that are defined in SVG\n                // spec. All others are disallowed in SVG namespace.\n                return Boolean(ALL_SVG_TAGS[tagName]);\n            }\n            if (element.namespaceURI === MATHML_NAMESPACE) {\n                // The only way to switch from HTML namespace to MathML\n                // is via <math>. If it happens via any other tag, then\n                // it should be killed.\n                if (parent.namespaceURI === HTML_NAMESPACE) return tagName === 'math';\n                // The only way to switch from SVG to MathML is via\n                // <math> and HTML integration points\n                if (parent.namespaceURI === SVG_NAMESPACE) return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n                // We only allow elements that are defined in MathML\n                // spec. All others are disallowed in MathML namespace.\n                return Boolean(ALL_MATHML_TAGS[tagName]);\n            }\n            if (element.namespaceURI === HTML_NAMESPACE) {\n                // The only way to switch from SVG to HTML is via\n                // HTML integration points, and from MathML to HTML\n                // is via MathML text integration points\n                if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) return false;\n                if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) return false;\n                // We disallow tags that are specific for MathML\n                // or SVG and should never appear in HTML namespace\n                return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n            }\n            // For XHTML and XML documents that support custom namespaces\n            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) return true;\n            // The code should never reach this place (this means\n            // that the element somehow got namespace that is not\n            // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n            // Return false just in case.\n            return false;\n        };\n        /**\n     * _forceRemove\n     *\n     * @param node a DOM node\n     */ const _forceRemove = function _forceRemove(node) {\n            arrayPush(DOMPurify.removed, {\n                element: node\n            });\n            try {\n                // eslint-disable-next-line unicorn/prefer-dom-node-remove\n                getParentNode(node).removeChild(node);\n            } catch (_) {\n                remove(node);\n            }\n        };\n        /**\n     * _removeAttribute\n     *\n     * @param name an Attribute name\n     * @param element a DOM node\n     */ const _removeAttribute = function _removeAttribute(name, element) {\n            try {\n                arrayPush(DOMPurify.removed, {\n                    attribute: element.getAttributeNode(name),\n                    from: element\n                });\n            } catch (_) {\n                arrayPush(DOMPurify.removed, {\n                    attribute: null,\n                    from: element\n                });\n            }\n            element.removeAttribute(name);\n            // We void attribute values for unremovable \"is\" attributes\n            if (name === 'is') {\n                if (RETURN_DOM || RETURN_DOM_FRAGMENT) try {\n                    _forceRemove(element);\n                } catch (_) {}\n                else try {\n                    element.setAttribute(name, '');\n                } catch (_) {}\n            }\n        };\n        /**\n     * _initDocument\n     *\n     * @param dirty - a string of dirty markup\n     * @return a DOM, filled with the dirty markup\n     */ const _initDocument = function _initDocument(dirty) {\n            /* Create a HTML document */ let doc = null;\n            let leadingWhitespace = null;\n            if (FORCE_BODY) dirty = '<remove></remove>' + dirty;\n            else {\n                /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */ const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n                leadingWhitespace = matches && matches[0];\n            }\n            if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n            dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n            const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n            /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */ if (NAMESPACE === HTML_NAMESPACE) try {\n                doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n            } catch (_) {}\n            /* Use createHTMLDocument in case DOMParser is not available */ if (!doc || !doc.documentElement) {\n                doc = implementation.createDocument(NAMESPACE, 'template', null);\n                try {\n                    doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n                } catch (_) {\n                // Syntax error if dirtyPayload is invalid xml\n                }\n            }\n            const body = doc.body || doc.documentElement;\n            if (dirty && leadingWhitespace) body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n            /* Work on whole document or just its body */ if (NAMESPACE === HTML_NAMESPACE) return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n            return WHOLE_DOCUMENT ? doc.documentElement : body;\n        };\n        /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     *\n     * @param root The root element or node to start traversing on.\n     * @return The created NodeIterator\n     */ const _createNodeIterator = function _createNodeIterator(root) {\n            return createNodeIterator.call(root.ownerDocument || root, root, // eslint-disable-next-line no-bitwise\n            NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n        };\n        /**\n     * _isClobbered\n     *\n     * @param element element to check for clobbering attacks\n     * @return true if clobbered, false if safe\n     */ const _isClobbered = function _isClobbered(element) {\n            return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');\n        };\n        /**\n     * Checks whether the given object is a DOM node.\n     *\n     * @param value object to check whether it's a DOM node\n     * @return true is object is a DOM node\n     */ const _isNode = function _isNode(value) {\n            return typeof Node === 'function' && value instanceof Node;\n        };\n        function _executeHooks(hooks, currentNode, data) {\n            arrayForEach(hooks, (hook)=>{\n                hook.call(DOMPurify, currentNode, data, CONFIG);\n            });\n        }\n        /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     * @param currentNode to check for permission to exist\n     * @return true if node was killed, false if left alive\n     */ const _sanitizeElements = function _sanitizeElements(currentNode) {\n            let content = null;\n            /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n            /* Check if element is clobbered or can clobber */ if (_isClobbered(currentNode)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Now let's check the element's type and name */ const tagName = transformCaseFunc(currentNode.nodeName);\n            /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeElement, currentNode, {\n                tagName: tagName,\n                allowedTags: ALLOWED_TAGS\n            });\n            /* Detect mXSS attempts abusing namespace confusion */ if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Remove any occurrence of processing instructions */ if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Remove any kind of possibly harmful comments */ if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Remove element if anything forbids its presence */ if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n                /* Check if we have a custom element to handle */ if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n                    if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) return false;\n                    if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) return false;\n                }\n                /* Keep content except for bad-listed elements */ if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n                    const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n                    const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n                    if (childNodes && parentNode) {\n                        const childCount = childNodes.length;\n                        for(let i = childCount - 1; i >= 0; --i){\n                            const childClone = cloneNode(childNodes[i], true);\n                            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n                            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n                        }\n                    }\n                }\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Check whether element has a valid namespace */ if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Make sure that older browsers don't get fallback-tag mXSS */ if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n                _forceRemove(currentNode);\n                return true;\n            }\n            /* Sanitize element content to be template-safe */ if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n                /* Get the element's text content */ content = currentNode.textContent;\n                arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    content = stringReplace(content, expr, ' ');\n                });\n                if (currentNode.textContent !== content) {\n                    arrayPush(DOMPurify.removed, {\n                        element: currentNode.cloneNode()\n                    });\n                    currentNode.textContent = content;\n                }\n            }\n            /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n            return false;\n        };\n        /**\n     * _isValidAttribute\n     *\n     * @param lcTag Lowercase tag name of containing element.\n     * @param lcName Lowercase attribute name.\n     * @param value Attribute value.\n     * @return Returns true if `value` is valid, otherwise false.\n     */ // eslint-disable-next-line complexity\n        const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n            /* Make sure attribute cannot clobber */ if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) return false;\n            /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */ if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ;\n            else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ;\n            else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n                if (// First condition does a very basic check if a) it's basically a valid custom element tagname AND\n                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n                _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) || // Alternative, second condition checks if it's an `is`-attribute, AND\n                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n                lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ;\n                else return false;\n            /* Check value is safe. First, is attr inert? If so, is safe */ } else if (URI_SAFE_ATTRIBUTES[lcName]) ;\n            else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ;\n            else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ;\n            else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ;\n            else if (value) return false;\n            return true;\n        };\n        /**\n     * _isBasicCustomElement\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     *\n     * @param tagName name of the tag of the node to sanitize\n     * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n     */ const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n            return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n        };\n        /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param currentNode to sanitize\n     */ const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n            /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n            const { attributes: attributes } = currentNode;\n            /* Check if we have attributes; if not we might have a text node */ if (!attributes || _isClobbered(currentNode)) return;\n            const hookEvent = {\n                attrName: '',\n                attrValue: '',\n                keepAttr: true,\n                allowedAttributes: ALLOWED_ATTR,\n                forceKeepAttr: undefined\n            };\n            let l = attributes.length;\n            /* Go backwards over all attributes; safely remove bad ones */ while(l--){\n                const attr = attributes[l];\n                const { name: name, namespaceURI: namespaceURI, value: attrValue } = attr;\n                const lcName = transformCaseFunc(name);\n                const initValue = attrValue;\n                let value = name === 'value' ? initValue : stringTrim(initValue);\n                /* Execute a hook if present */ hookEvent.attrName = lcName;\n                hookEvent.attrValue = value;\n                hookEvent.keepAttr = true;\n                hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n                _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n                value = hookEvent.attrValue;\n                /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */ if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n                    // Remove the attribute with this value\n                    _removeAttribute(name, currentNode);\n                    // Prefix the value and later re-create the attribute with the sanitized value\n                    value = SANITIZE_NAMED_PROPS_PREFIX + value;\n                }\n                /* Work around a security issue with comments inside attributes */ if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n                    _removeAttribute(name, currentNode);\n                    continue;\n                }\n                /* Did the hooks approve of the attribute? */ if (hookEvent.forceKeepAttr) continue;\n                /* Did the hooks approve of the attribute? */ if (!hookEvent.keepAttr) {\n                    _removeAttribute(name, currentNode);\n                    continue;\n                }\n                /* Work around a security issue in jQuery 3.0 */ if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n                    _removeAttribute(name, currentNode);\n                    continue;\n                }\n                /* Sanitize attribute content to be template-safe */ if (SAFE_FOR_TEMPLATES) arrayForEach([\n                    MUSTACHE_EXPR,\n                    ERB_EXPR,\n                    TMPLIT_EXPR\n                ], (expr)=>{\n                    value = stringReplace(value, expr, ' ');\n                });\n                /* Is `value` valid for this attribute? */ const lcTag = transformCaseFunc(currentNode.nodeName);\n                if (!_isValidAttribute(lcTag, lcName, value)) {\n                    _removeAttribute(name, currentNode);\n                    continue;\n                }\n                /* Handle attributes that require Trusted Types */ if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n                    if (namespaceURI) ;\n                    else switch(trustedTypes.getAttributeType(lcTag, lcName)){\n                        case 'TrustedHTML':\n                            value = trustedTypesPolicy.createHTML(value);\n                            break;\n                        case 'TrustedScriptURL':\n                            value = trustedTypesPolicy.createScriptURL(value);\n                            break;\n                    }\n                }\n                /* Handle invalid data-* attribute set by try-catching it */ if (value !== initValue) try {\n                    if (namespaceURI) currentNode.setAttributeNS(namespaceURI, name, value);\n                    else /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */ currentNode.setAttribute(name, value);\n                    if (_isClobbered(currentNode)) _forceRemove(currentNode);\n                    else arrayPop(DOMPurify.removed);\n                } catch (_) {\n                    _removeAttribute(name, currentNode);\n                }\n            }\n            /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n        };\n        /**\n     * _sanitizeShadowDOM\n     *\n     * @param fragment to iterate over recursively\n     */ const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n            let shadowNode = null;\n            const shadowIterator = _createNodeIterator(fragment);\n            /* Execute a hook if present */ _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n            while(shadowNode = shadowIterator.nextNode()){\n                /* Execute a hook if present */ _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n                /* Sanitize tags and elements */ _sanitizeElements(shadowNode);\n                /* Check attributes next */ _sanitizeAttributes(shadowNode);\n                /* Deep shadow DOM detected */ if (shadowNode.content instanceof DocumentFragment) _sanitizeShadowDOM(shadowNode.content);\n            }\n            /* Execute a hook if present */ _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n        };\n        // eslint-disable-next-line complexity\n        DOMPurify.sanitize = function(dirty) {\n            let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            let body = null;\n            let importedNode = null;\n            let currentNode = null;\n            let returnNode = null;\n            /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */ IS_EMPTY_INPUT = !dirty;\n            if (IS_EMPTY_INPUT) dirty = '<!-->';\n            /* Stringify, in case dirty is an object */ if (typeof dirty !== 'string' && !_isNode(dirty)) {\n                if (typeof dirty.toString === 'function') {\n                    dirty = dirty.toString();\n                    if (typeof dirty !== 'string') throw typeErrorCreate('dirty is not a string, aborting');\n                } else throw typeErrorCreate('toString is not a function');\n            }\n            /* Return dirty HTML if DOMPurify cannot run */ if (!DOMPurify.isSupported) return dirty;\n            /* Assign config vars */ if (!SET_CONFIG) _parseConfig(cfg);\n            /* Clean up removed elements */ DOMPurify.removed = [];\n            /* Check if dirty is correctly typed for IN_PLACE */ if (typeof dirty === 'string') IN_PLACE = false;\n            if (IN_PLACE) /* Do some early pre-sanitization to avoid unsafe root nodes */ {\n                if (dirty.nodeName) {\n                    const tagName = transformCaseFunc(dirty.nodeName);\n                    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n                }\n            } else if (dirty instanceof Node) {\n                /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */ body = _initDocument('<!---->');\n                importedNode = body.ownerDocument.importNode(dirty, true);\n                if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') /* Node is already a body, use as is */ body = importedNode;\n                else if (importedNode.nodeName === 'HTML') body = importedNode;\n                else // eslint-disable-next-line unicorn/prefer-dom-node-append\n                body.appendChild(importedNode);\n            } else {\n                /* Exit directly if we have nothing to do */ if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT && // eslint-disable-next-line unicorn/prefer-includes\n                dirty.indexOf('<') === -1) return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n                /* Initialize the document to work on */ body = _initDocument(dirty);\n                /* Check we have a DOM node from the data */ if (!body) return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n            }\n            /* Remove first element node (ours) if FORCE_BODY is set */ if (body && FORCE_BODY) _forceRemove(body.firstChild);\n            /* Get node iterator */ const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n            /* Now start iterating over the created document */ while(currentNode = nodeIterator.nextNode()){\n                /* Sanitize tags and elements */ _sanitizeElements(currentNode);\n                /* Check attributes next */ _sanitizeAttributes(currentNode);\n                /* Shadow DOM detected, sanitize it */ if (currentNode.content instanceof DocumentFragment) _sanitizeShadowDOM(currentNode.content);\n            }\n            /* If we sanitized `dirty` in-place, return it. */ if (IN_PLACE) return dirty;\n            /* Return sanitized string or DOM */ if (RETURN_DOM) {\n                if (RETURN_DOM_FRAGMENT) {\n                    returnNode = createDocumentFragment.call(body.ownerDocument);\n                    while(body.firstChild)// eslint-disable-next-line unicorn/prefer-dom-node-append\n                    returnNode.appendChild(body.firstChild);\n                } else returnNode = body;\n                if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */ returnNode = importNode.call(originalDocument, returnNode, true);\n                return returnNode;\n            }\n            let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n            /* Serialize doctype if allowed */ if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n            /* Sanitize final string template-safe */ if (SAFE_FOR_TEMPLATES) arrayForEach([\n                MUSTACHE_EXPR,\n                ERB_EXPR,\n                TMPLIT_EXPR\n            ], (expr)=>{\n                serializedHTML = stringReplace(serializedHTML, expr, ' ');\n            });\n            return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n        };\n        DOMPurify.setConfig = function() {\n            let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n            _parseConfig(cfg);\n            SET_CONFIG = true;\n        };\n        DOMPurify.clearConfig = function() {\n            CONFIG = null;\n            SET_CONFIG = false;\n        };\n        DOMPurify.isValidAttribute = function(tag, attr, value) {\n            /* Initialize shared config vars if necessary. */ if (!CONFIG) _parseConfig({});\n            const lcTag = transformCaseFunc(tag);\n            const lcName = transformCaseFunc(attr);\n            return _isValidAttribute(lcTag, lcName, value);\n        };\n        DOMPurify.addHook = function(entryPoint, hookFunction) {\n            if (typeof hookFunction !== 'function') return;\n            arrayPush(hooks[entryPoint], hookFunction);\n        };\n        DOMPurify.removeHook = function(entryPoint, hookFunction) {\n            if (hookFunction !== undefined) {\n                const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n                return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n            }\n            return arrayPop(hooks[entryPoint]);\n        };\n        DOMPurify.removeHooks = function(entryPoint) {\n            hooks[entryPoint] = [];\n        };\n        DOMPurify.removeAllHooks = function() {\n            hooks = _createHooksMap();\n        };\n        return DOMPurify;\n    }\n    var purify = createDOMPurify();\n    return purify;\n});\n\n\nconst $e73bf42412feb220$var$chatContainer = document.getElementById(\"chat-container\");\nconst $e73bf42412feb220$var$messageForm = document.getElementById(\"message-form\");\nconst $e73bf42412feb220$var$userInput = document.getElementById(\"user-input\");\nconst $e73bf42412feb220$var$languageSelector = document.getElementById(\"language-selector\");\n// We'll read the API endpoint from an environment variable\nconst $e73bf42412feb220$var$BASE_URL = \"https://daejeon01.fly.dev\";\nconst $e73bf42412feb220$var$url = `${$e73bf42412feb220$var$BASE_URL}/chat`;\n// This will be replaced at build time by Parcel with the appropriate value\n// from the corresponding .env file.\nfunction $e73bf42412feb220$var$createMessageBubble(content, sender = \"user\") {\n    const wrapper = document.createElement(\"div\");\n    if (sender === \"user\") wrapper.className = \"mb-6 mr-6 flex flex-row-reverse items-end justify-end space-x-3 space-x-reverse\";\n    else wrapper.className = \"mb-6 flex items-start justify-start space-x-3\";\n    const bubble = document.createElement(\"div\");\n    bubble.className = (sender === \"user\" ? \"user \" : \"assistant \") + \"max-w-[60%] p-3 rounded-3xl whitespace-pre-wrap leading-relaxed shadow-lg bubble-appear font-semibold text-base\";\n    if (sender === \"user\") bubble.classList.add(\"bg-gray-200\", \"text-pink-500\", \"ml-auto\");\n    else bubble.classList.add(\"bg-pink-400\", \"md:max-w-2xl\", \"text-white\");\n    if (sender === \"assistant\") // 마크다운을 HTML로 변환\n    bubble.innerHTML = (0, (/*@__PURE__*/$parcel$interopDefault($d349326c2b62c55f$exports))).sanitize((0, $d55025bea272cdc1$exports.marked).parse(content));\n    else bubble.textContent = content;\n    if (sender === \"assistant\") {\n        const avatar = document.createElement(\"div\");\n        avatar.className = \"avatar-cute w-10 h-10 flex-shrink-0 flex items-center justify-center overflow-hidden\";\n        const img = document.createElement(\"img\");\n        img.src = (0, (/*@__PURE__*/$parcel$interopDefault($1862cbf67f994e67$exports)));\n        img.alt = \"avatar\";\n        img.className = \"w-full h-full object-cover\";\n        avatar.appendChild(img);\n        wrapper.appendChild(avatar);\n        wrapper.appendChild(bubble);\n    } else wrapper.appendChild(bubble);\n    setTimeout(()=>{\n        bubble.classList.add(\"bubble-appear-active\");\n    }, 10);\n    return wrapper;\n}\nfunction $e73bf42412feb220$var$scrollToBottom() {\n    $e73bf42412feb220$var$chatContainer.scrollTop = $e73bf42412feb220$var$chatContainer.scrollHeight;\n}\nasync function $e73bf42412feb220$var$getAssistantResponse(userMessage, codeLanguage) {\n    const response = await fetch($e73bf42412feb220$var$url, {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            query: userMessage,\n            language: codeLanguage\n        })\n    });\n    if (!response.ok) throw new Error(\"Network response was not ok\");\n    const data = await response.json();\n    return data.reply;\n}\n$e73bf42412feb220$var$messageForm.addEventListener(\"submit\", async (e)=>{\n    e.preventDefault();\n    const message = $e73bf42412feb220$var$userInput.value.trim();\n    const selectedLanguage = $e73bf42412feb220$var$languageSelector.value;\n    if (!message) return;\n    if (!selectedLanguage) {\n        alert(\"\\uC5B8\\uC5B4\\uB97C \\uC120\\uD0DD\\uD558\\uC138\\uC694!\");\n        return;\n    }\n    $e73bf42412feb220$var$chatContainer.appendChild($e73bf42412feb220$var$createMessageBubble(message, \"user\"));\n    $e73bf42412feb220$var$userInput.value = \"\";\n    $e73bf42412feb220$var$userInput.style.height = \"\";\n    $e73bf42412feb220$var$scrollToBottom();\n    try {\n        const response = await $e73bf42412feb220$var$getAssistantResponse(message, selectedLanguage);\n        $e73bf42412feb220$var$chatContainer.appendChild($e73bf42412feb220$var$createMessageBubble(response, \"assistant\"));\n        $e73bf42412feb220$var$scrollToBottom();\n    } catch (error) {\n        console.error(\"Error fetching assistant response:\", error);\n        $e73bf42412feb220$var$chatContainer.appendChild($e73bf42412feb220$var$createMessageBubble(\"Error fetching response. Check console.\", \"assistant\"));\n        $e73bf42412feb220$var$scrollToBottom();\n    }\n});\nwindow.addEventListener(\"DOMContentLoaded\", ()=>{\n    $e73bf42412feb220$var$chatContainer.appendChild($e73bf42412feb220$var$createMessageBubble('\\uC548\\uB155\\uD558\\uC138\\uC694. \\uB2F9\\uC2E0\\uC758 \\uCF54\\uB4DC\\uB97C \\uD2B8\\uB80C\\uB4DC\\uD558\\uAC8C \\uBC14\\uAFD4\\uC904 \"\\uB378\\uD0C0\\uCE90\\uCC98\"\\uC785\\uB2C8\\uB2E4!', \"assistant\"));\n    $e73bf42412feb220$var$scrollToBottom();\n});\nconst $e73bf42412feb220$var$textarea = document.getElementById('user-input');\n$e73bf42412feb220$var$textarea.addEventListener('input', ()=>{\n    $e73bf42412feb220$var$textarea.style.height = 'auto';\n    $e73bf42412feb220$var$textarea.style.height = $e73bf42412feb220$var$textarea.scrollHeight + 'px';\n});\n$e73bf42412feb220$var$textarea.addEventListener('keydown', (e)=>{\n    if (e.key === 'Enter' && !e.shiftKey) {\n        e.preventDefault();\n        document.getElementById('message-form').requestSubmit();\n    }\n});\n\n\n//# sourceMappingURL=front.83907146.js.map\n","import avatarimg from \"url:./assets/black-cat.png\";\r\nimport { marked } from \"marked\";\r\nimport DOMPurify from \"dompurify\";\r\n\r\nconst chatContainer = document.getElementById(\"chat-container\");\r\nconst messageForm = document.getElementById(\"message-form\");\r\nconst userInput = document.getElementById(\"user-input\");\r\nconst languageSelector = document.getElementById(\"language-selector\");\r\n\r\n// We'll read the API endpoint from an environment variable\r\nconst BASE_URL = process.env.API_ENDPOINT;\r\nconst url = `${BASE_URL}/chat`;\r\n// This will be replaced at build time by Parcel with the appropriate value\r\n// from the corresponding .env file.\r\n\r\nfunction createMessageBubble(content, sender = \"user\") {\r\n  const wrapper = document.createElement(\"div\");\r\n\r\n  if (sender === \"user\") {\r\n    wrapper.className = \"mb-6 mr-6 flex flex-row-reverse items-end justify-end space-x-3 space-x-reverse\";\r\n  } else {\r\n    wrapper.className = \"mb-6 flex items-start justify-start space-x-3\";\r\n  }\r\n\r\n  const bubble = document.createElement(\"div\");\r\n  bubble.className =\r\n    (sender === \"user\" ? \"user \" : \"assistant \") +\r\n    \"max-w-[60%] p-3 rounded-3xl whitespace-pre-wrap leading-relaxed shadow-lg bubble-appear font-semibold text-base\";\r\n  if (sender === \"user\") {\r\n    bubble.classList.add(\"bg-gray-200\", \"text-pink-500\", \"ml-auto\");\r\n  } else {\r\n  bubble.classList.add(\"bg-pink-400\", \"md:max-w-2xl\", \"text-white\");\r\n  }\r\n  if (sender === \"assistant\") {\r\n    // 마크다운을 HTML로 변환\r\n    bubble.innerHTML = DOMPurify.sanitize(marked.parse(content));\r\n  } else {\r\n    bubble.textContent = content;\r\n  }\r\n  if (sender === \"assistant\") {\r\n    const avatar = document.createElement(\"div\");\r\n    avatar.className =\r\n      \"avatar-cute w-10 h-10 flex-shrink-0 flex items-center justify-center overflow-hidden\";\r\n    const img = document.createElement(\"img\");\r\n    img.src = avatarimg\r\n    img.alt = \"avatar\";\r\n    img.className = \"w-full h-full object-cover\";\r\n    avatar.appendChild(img);\r\n    wrapper.appendChild(avatar);\r\n    wrapper.appendChild(bubble);\r\n  } else {\r\n    wrapper.appendChild(bubble);\r\n  }\r\n\r\n  setTimeout(() => {\r\n    bubble.classList.add(\"bubble-appear-active\");\r\n  }, 10);\r\n\r\n  return wrapper;\r\n}\r\n\r\nfunction scrollToBottom() {\r\n  chatContainer.scrollTop = chatContainer.scrollHeight;\r\n}\r\n\r\nasync function getAssistantResponse(userMessage, codeLanguage) {\r\n  const response = await fetch(url, {\r\n    method: \"POST\",\r\n    headers: {\r\n      \"Content-Type\": \"application/json\",\r\n    },\r\n    body: JSON.stringify({\r\n      query: userMessage,\r\n      language: codeLanguage,\r\n    }),  });\r\n\r\n  if (!response.ok) {\r\n    throw new Error(\"Network response was not ok\");\r\n  }\r\n\r\n  const data = await response.json();\r\n  return data.reply;\r\n}\r\n\r\nmessageForm.addEventListener(\"submit\", async (e) => {\r\n  e.preventDefault();\r\n  const message = userInput.value.trim();\r\n  const selectedLanguage = languageSelector.value;\r\n  if (!message) return;\r\n  if (!selectedLanguage) {\r\n    alert(\"언어를 선택하세요!\");\r\n    return;\r\n  }\r\n\r\n  chatContainer.appendChild(createMessageBubble(message, \"user\"));\r\n  userInput.value = \"\";\r\n  userInput.style.height = \"\";\r\n  scrollToBottom();\r\n\r\n  try {\r\n    const response = await getAssistantResponse(message, selectedLanguage);\r\n    chatContainer.appendChild(createMessageBubble(response, \"assistant\"));\r\n    scrollToBottom();\r\n  } catch (error) {\r\n    console.error(\"Error fetching assistant response:\", error);\r\n    chatContainer.appendChild(\r\n      createMessageBubble(\r\n        \"Error fetching response. Check console.\",\r\n        \"assistant\"\r\n      )\r\n    );\r\n    scrollToBottom();\r\n  }\r\n});\r\n\r\nwindow.addEventListener(\"DOMContentLoaded\", () => {\r\n  chatContainer.appendChild(\r\n    createMessageBubble('안녕하세요. 당신의 코드를 트렌드하게 바꿔줄 \"델타캐처\"입니다!', \"assistant\")\r\n  );\r\n  scrollToBottom();\r\n});\r\n\r\nconst textarea = document.getElementById('user-input');\r\n\r\ntextarea.addEventListener('input', () => {\r\n  textarea.style.height = 'auto';\r\n  textarea.style.height = textarea.scrollHeight + 'px';\r\n});\r\n\r\ntextarea.addEventListener('keydown', (e) => {\r\n  if (e.key === 'Enter' && !e.shiftKey) {\r\n    e.preventDefault();\r\n    document.getElementById('message-form').requestSubmit();\r\n  }\r\n});","module.exports = __parcel__import__.meta.resolve(\"2u8Vv\");","/**\n * marked v16.0.0 - a markdown parser\n * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)\n * https://github.com/markedjs/marked\n */\n\n/**\n * DO NOT EDIT THIS FILE\n * The code in this file is generated from files in ./src/\n */\n(function(g,f){if(typeof exports==\"object\"&&typeof module<\"u\"){module.exports=f()}else if(\"function\"==typeof define && define.amd){define(\"marked\",f)}else {g[\"marked\"]=f()}}(typeof globalThis < \"u\" ? globalThis : typeof self < \"u\" ? self : this,function(){var exports={};var __exports=exports;var module={exports};\n\"use strict\";var H=Object.defineProperty;var be=Object.getOwnPropertyDescriptor;var Te=Object.getOwnPropertyNames;var we=Object.prototype.hasOwnProperty;var ye=(l,e)=>{for(var t in e)H(l,t,{get:e[t],enumerable:!0})},Re=(l,e,t,n)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let s of Te(e))!we.call(l,s)&&s!==t&&H(l,s,{get:()=>e[s],enumerable:!(n=be(e,s))||n.enumerable});return l};var Se=l=>Re(H({},\"__esModule\",{value:!0}),l);var kt={};ye(kt,{Hooks:()=>L,Lexer:()=>x,Marked:()=>E,Parser:()=>b,Renderer:()=>$,TextRenderer:()=>_,Tokenizer:()=>S,defaults:()=>w,getDefaults:()=>z,lexer:()=>ht,marked:()=>k,options:()=>it,parse:()=>pt,parseInline:()=>ct,parser:()=>ut,setOptions:()=>ot,use:()=>lt,walkTokens:()=>at});module.exports=Se(kt);function z(){return{async:!1,breaks:!1,extensions:null,gfm:!0,hooks:null,pedantic:!1,renderer:null,silent:!1,tokenizer:null,walkTokens:null}}var w=z();function N(l){w=l}var I={exec:()=>null};function h(l,e=\"\"){let t=typeof l==\"string\"?l:l.source,n={replace:(s,i)=>{let r=typeof i==\"string\"?i:i.source;return r=r.replace(m.caret,\"$1\"),t=t.replace(s,r),n},getRegex:()=>new RegExp(t,e)};return n}var m={codeRemoveIndent:/^(?: {1,4}| {0,3}\\t)/gm,outputLinkReplace:/\\\\([\\[\\]])/g,indentCodeCompensation:/^(\\s+)(?:```)/,beginningSpace:/^\\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\\n/g,tabCharGlobal:/\\t/g,multipleSpaceGlobal:/\\s+/g,blankLine:/^[ \\t]*$/,doubleBlankLine:/\\n[ \\t]*\\n[ \\t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \\t]?/gm,listReplaceTabs:/^\\t+/,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\\[[ xX]\\] /,listReplaceTask:/^\\[[ xX]\\] +/,anyLine:/\\n.*\\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\\||\\| *$/g,tableRowBlankLine:/\\n[ \\t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\\s|>)/i,endPreScriptTag:/^<\\/(pre|code|kbd|script)(\\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,unicodeAlphaNumeric:/[\\p{L}\\p{N}]/u,escapeTest:/[&<>\"']/,escapeReplace:/[&<>\"']/g,escapeTestNoEncode:/[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,escapeReplaceNoEncode:/[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,unescapeTest:/&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,caret:/(^|[^\\[])\\^/g,percentDecode:/%25/g,findPipe:/\\|/g,splitPipe:/ \\|/,slashPipe:/\\\\\\|/g,carriageReturn:/\\r\\n|\\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\\S*/,endingNewline:/\\n$/,listItemRegex:l=>new RegExp(`^( {0,3}${l})((?:[\t ][^\\\\n]*)?(?:\\\\n|$))`),nextBulletRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \t][^\\\\n]*)?(?:\\\\n|$))`),hrRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),fencesBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}(?:\\`\\`\\`|~~~)`),headingBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}#`),htmlBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}<(?:[a-z].*>|!--)`,\"i\")},$e=/^(?:[ \\t]*(?:\\n|$))+/,_e=/^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/,Le=/^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/,O=/^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/,ze=/^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/,F=/(?:[*+-]|\\d{1,9}[.)])/,ie=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,oe=h(ie).replace(/bull/g,F).replace(/blockCode/g,/(?: {4}| {0,3}\\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\\n>]+>\\n/).replace(/\\|table/g,\"\").getRegex(),Me=h(ie).replace(/bull/g,F).replace(/blockCode/g,/(?: {4}| {0,3}\\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\\n>]+>\\n/).replace(/table/g,/ {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/).getRegex(),Q=/^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/,Pe=/^[^\\n]+/,U=/(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/,Ae=h(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/).replace(\"label\",U).replace(\"title\",/(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/).getRegex(),Ee=h(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/).replace(/bull/g,F).getRegex(),v=\"address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul\",K=/<!--(?:-?>|[\\s\\S]*?(?:-->|$))/,Ce=h(\"^ {0,3}(?:<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)|comment[^\\\\n]*(\\\\n+|$)|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$)|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \t]*)+\\\\n|$))\",\"i\").replace(\"comment\",K).replace(\"tag\",v).replace(\"attribute\",/ +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/).getRegex(),le=h(Q).replace(\"hr\",O).replace(\"heading\",\" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\",\"\").replace(\"|table\",\"\").replace(\"blockquote\",\" {0,3}>\").replace(\"fences\",\" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\",\" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\",\"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\",v).getRegex(),Ie=h(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/).replace(\"paragraph\",le).getRegex(),X={blockquote:Ie,code:_e,def:Ae,fences:Le,heading:ze,hr:O,html:Ce,lheading:oe,list:Ee,newline:$e,paragraph:le,table:I,text:Pe},re=h(\"^ *([^\\\\n ].*)\\\\n {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)\").replace(\"hr\",O).replace(\"heading\",\" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"blockquote\",\" {0,3}>\").replace(\"code\",\"(?: {4}| {0,3}\t)[^\\\\n]\").replace(\"fences\",\" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\",\" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\",\"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\",v).getRegex(),Oe={...X,lheading:Me,table:re,paragraph:h(Q).replace(\"hr\",O).replace(\"heading\",\" {0,3}#{1,6}(?:\\\\s|$)\").replace(\"|lheading\",\"\").replace(\"table\",re).replace(\"blockquote\",\" {0,3}>\").replace(\"fences\",\" {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n\").replace(\"list\",\" {0,3}(?:[*+-]|1[.)]) \").replace(\"html\",\"</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)\").replace(\"tag\",v).getRegex()},Be={...X,html:h(`^ *(?:comment *(?:\\\\n|\\\\s*$)|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)|<tag(?:\"[^\"]*\"|'[^']*'|\\\\s[^'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))`).replace(\"comment\",K).replace(/tag/g,\"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b\").getRegex(),def:/^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,heading:/^(#{1,6})(.*)(?:\\n+|$)/,fences:I,lheading:/^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,paragraph:h(Q).replace(\"hr\",O).replace(\"heading\",` *#{1,6} *[^\n]`).replace(\"lheading\",oe).replace(\"|table\",\"\").replace(\"blockquote\",\" {0,3}>\").replace(\"|fences\",\"\").replace(\"|list\",\"\").replace(\"|html\",\"\").replace(\"|tag\",\"\").getRegex()},qe=/^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/,ve=/^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/,ae=/^( {2,}|\\\\)\\n(?!\\s*$)/,De=/^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/,D=/[\\p{P}\\p{S}]/u,W=/[\\s\\p{P}\\p{S}]/u,ce=/[^\\s\\p{P}\\p{S}]/u,Ze=h(/^((?![*_])punctSpace)/,\"u\").replace(/punctSpace/g,W).getRegex(),pe=/(?!~)[\\p{P}\\p{S}]/u,Ge=/(?!~)[\\s\\p{P}\\p{S}]/u,He=/(?:[^\\s\\p{P}\\p{S}]|~)/u,Ne=/\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g,ue=/^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/,je=h(ue,\"u\").replace(/punct/g,D).getRegex(),Fe=h(ue,\"u\").replace(/punct/g,pe).getRegex(),he=\"^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)|notPunctSpace(\\\\*+)(?=notPunctSpace)\",Qe=h(he,\"gu\").replace(/notPunctSpace/g,ce).replace(/punctSpace/g,W).replace(/punct/g,D).getRegex(),Ue=h(he,\"gu\").replace(/notPunctSpace/g,He).replace(/punctSpace/g,Ge).replace(/punct/g,pe).getRegex(),Ke=h(\"^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)\",\"gu\").replace(/notPunctSpace/g,ce).replace(/punctSpace/g,W).replace(/punct/g,D).getRegex(),Xe=h(/\\\\(punct)/,\"gu\").replace(/punct/g,D).getRegex(),We=h(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/).replace(\"scheme\",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace(\"email\",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),Je=h(K).replace(\"(?:-->|$)\",\"-->\").getRegex(),Ve=h(\"^comment|^</[a-zA-Z][\\\\w:-]*\\\\s*>|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>|^<\\\\?[\\\\s\\\\S]*?\\\\?>|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>\").replace(\"comment\",Je).replace(\"attribute\",/\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/).getRegex(),q=/(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/,Ye=h(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/).replace(\"label\",q).replace(\"href\",/<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/).replace(\"title\",/\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/).getRegex(),ke=h(/^!?\\[(label)\\]\\[(ref)\\]/).replace(\"label\",q).replace(\"ref\",U).getRegex(),ge=h(/^!?\\[(ref)\\](?:\\[\\])?/).replace(\"ref\",U).getRegex(),et=h(\"reflink|nolink(?!\\\\()\",\"g\").replace(\"reflink\",ke).replace(\"nolink\",ge).getRegex(),J={_backpedal:I,anyPunctuation:Xe,autolink:We,blockSkip:Ne,br:ae,code:ve,del:I,emStrongLDelim:je,emStrongRDelimAst:Qe,emStrongRDelimUnd:Ke,escape:qe,link:Ye,nolink:ge,punctuation:Ze,reflink:ke,reflinkSearch:et,tag:Ve,text:De,url:I},tt={...J,link:h(/^!?\\[(label)\\]\\((.*?)\\)/).replace(\"label\",q).getRegex(),reflink:h(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/).replace(\"label\",q).getRegex()},j={...J,emStrongRDelimAst:Ue,emStrongLDelim:Fe,url:h(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/,\"i\").replace(\"email\",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,del:/^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/},nt={...j,br:h(ae).replace(\"{2,}\",\"*\").getRegex(),text:h(j.text).replace(\"\\\\b_\",\"\\\\b_| {2,}\\\\n\").replace(/\\{2,\\}/g,\"*\").getRegex()},B={normal:X,gfm:Oe,pedantic:Be},P={normal:J,gfm:j,breaks:nt,pedantic:tt};var st={\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#39;\"},fe=l=>st[l];function R(l,e){if(e){if(m.escapeTest.test(l))return l.replace(m.escapeReplace,fe)}else if(m.escapeTestNoEncode.test(l))return l.replace(m.escapeReplaceNoEncode,fe);return l}function V(l){try{l=encodeURI(l).replace(m.percentDecode,\"%\")}catch{return null}return l}function Y(l,e){let t=l.replace(m.findPipe,(i,r,o)=>{let a=!1,c=r;for(;--c>=0&&o[c]===\"\\\\\";)a=!a;return a?\"|\":\" |\"}),n=t.split(m.splitPipe),s=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push(\"\");for(;s<n.length;s++)n[s]=n[s].trim().replace(m.slashPipe,\"|\");return n}function A(l,e,t){let n=l.length;if(n===0)return\"\";let s=0;for(;s<n;){let i=l.charAt(n-s-1);if(i===e&&!t)s++;else if(i!==e&&t)s++;else break}return l.slice(0,n-s)}function de(l,e){if(l.indexOf(e[1])===-1)return-1;let t=0;for(let n=0;n<l.length;n++)if(l[n]===\"\\\\\")n++;else if(l[n]===e[0])t++;else if(l[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function me(l,e,t,n,s){let i=e.href,r=e.title||null,o=l[1].replace(s.other.outputLinkReplace,\"$1\");n.state.inLink=!0;let a={type:l[0].charAt(0)===\"!\"?\"image\":\"link\",raw:t,href:i,title:r,text:o,tokens:n.inlineTokens(o)};return n.state.inLink=!1,a}function rt(l,e,t){let n=l.match(t.other.indentCodeCompensation);if(n===null)return e;let s=n[1];return e.split(`\n`).map(i=>{let r=i.match(t.other.beginningSpace);if(r===null)return i;let[o]=r;return o.length>=s.length?i.slice(s.length):i}).join(`\n`)}var S=class{options;rules;lexer;constructor(e){this.options=e||w}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return{type:\"space\",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,\"\");return{type:\"code\",raw:t[0],codeBlockStyle:\"indented\",text:this.options.pedantic?n:A(n,`\n`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],s=rt(n,t[3]||\"\",this.rules);return{type:\"code\",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,\"$1\"):t[2],text:s}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let s=A(n,\"#\");(this.options.pedantic||!s||this.rules.other.endingSpaceChar.test(s))&&(n=s.trim())}return{type:\"heading\",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return{type:\"hr\",raw:A(t[0],`\n`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=A(t[0],`\n`).split(`\n`),s=\"\",i=\"\",r=[];for(;n.length>0;){let o=!1,a=[],c;for(c=0;c<n.length;c++)if(this.rules.other.blockquoteStart.test(n[c]))a.push(n[c]),o=!0;else if(!o)a.push(n[c]);else break;n=n.slice(c);let p=a.join(`\n`),u=p.replace(this.rules.other.blockquoteSetextReplace,`\n    $1`).replace(this.rules.other.blockquoteSetextReplace2,\"\");s=s?`${s}\n${p}`:p,i=i?`${i}\n${u}`:u;let d=this.lexer.state.top;if(this.lexer.state.top=!0,this.lexer.blockTokens(u,r,!0),this.lexer.state.top=d,n.length===0)break;let g=r.at(-1);if(g?.type===\"code\")break;if(g?.type===\"blockquote\"){let T=g,f=T.raw+`\n`+n.join(`\n`),y=this.blockquote(f);r[r.length-1]=y,s=s.substring(0,s.length-T.raw.length)+y.raw,i=i.substring(0,i.length-T.text.length)+y.text;break}else if(g?.type===\"list\"){let T=g,f=T.raw+`\n`+n.join(`\n`),y=this.list(f);r[r.length-1]=y,s=s.substring(0,s.length-g.raw.length)+y.raw,i=i.substring(0,i.length-T.raw.length)+y.raw,n=f.substring(r.at(-1).raw.length).split(`\n`);continue}}return{type:\"blockquote\",raw:s,tokens:r,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),s=n.length>1,i={type:\"list\",raw:\"\",ordered:s,start:s?+n.slice(0,-1):\"\",loose:!1,items:[]};n=s?`\\\\d{1,9}\\\\${n.slice(-1)}`:`\\\\${n}`,this.options.pedantic&&(n=s?n:\"[*+-]\");let r=this.rules.other.listItemRegex(n),o=!1;for(;e;){let c=!1,p=\"\",u=\"\";if(!(t=r.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let d=t[2].split(`\n`,1)[0].replace(this.rules.other.listReplaceTabs,Z=>\" \".repeat(3*Z.length)),g=e.split(`\n`,1)[0],T=!d.trim(),f=0;if(this.options.pedantic?(f=2,u=d.trimStart()):T?f=t[1].length+1:(f=t[2].search(this.rules.other.nonSpaceChar),f=f>4?1:f,u=d.slice(f),f+=t[1].length),T&&this.rules.other.blankLine.test(g)&&(p+=g+`\n`,e=e.substring(g.length+1),c=!0),!c){let Z=this.rules.other.nextBulletRegex(f),te=this.rules.other.hrRegex(f),ne=this.rules.other.fencesBeginRegex(f),se=this.rules.other.headingBeginRegex(f),xe=this.rules.other.htmlBeginRegex(f);for(;e;){let G=e.split(`\n`,1)[0],C;if(g=G,this.options.pedantic?(g=g.replace(this.rules.other.listReplaceNesting,\"  \"),C=g):C=g.replace(this.rules.other.tabCharGlobal,\"    \"),ne.test(g)||se.test(g)||xe.test(g)||Z.test(g)||te.test(g))break;if(C.search(this.rules.other.nonSpaceChar)>=f||!g.trim())u+=`\n`+C.slice(f);else{if(T||d.replace(this.rules.other.tabCharGlobal,\"    \").search(this.rules.other.nonSpaceChar)>=4||ne.test(d)||se.test(d)||te.test(d))break;u+=`\n`+g}!T&&!g.trim()&&(T=!0),p+=G+`\n`,e=e.substring(G.length+1),d=C.slice(f)}}i.loose||(o?i.loose=!0:this.rules.other.doubleBlankLine.test(p)&&(o=!0));let y=null,ee;this.options.gfm&&(y=this.rules.other.listIsTask.exec(u),y&&(ee=y[0]!==\"[ ] \",u=u.replace(this.rules.other.listReplaceTask,\"\"))),i.items.push({type:\"list_item\",raw:p,task:!!y,checked:ee,loose:!1,text:u,tokens:[]}),i.raw+=p}let a=i.items.at(-1);if(a)a.raw=a.raw.trimEnd(),a.text=a.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let c=0;c<i.items.length;c++)if(this.lexer.state.top=!1,i.items[c].tokens=this.lexer.blockTokens(i.items[c].text,[]),!i.loose){let p=i.items[c].tokens.filter(d=>d.type===\"space\"),u=p.length>0&&p.some(d=>this.rules.other.anyLine.test(d.raw));i.loose=u}if(i.loose)for(let c=0;c<i.items.length;c++)i.items[c].loose=!0;return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return{type:\"html\",block:!0,raw:t[0],pre:t[1]===\"pre\"||t[1]===\"script\"||t[1]===\"style\",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal,\" \"),s=t[2]?t[2].replace(this.rules.other.hrefBrackets,\"$1\").replace(this.rules.inline.anyPunctuation,\"$1\"):\"\",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,\"$1\"):t[3];return{type:\"def\",tag:n,raw:t[0],href:s,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=Y(t[1]),s=t[2].replace(this.rules.other.tableAlignChars,\"\").split(\"|\"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,\"\").split(`\n`):[],r={type:\"table\",raw:t[0],header:[],align:[],rows:[]};if(n.length===s.length){for(let o of s)this.rules.other.tableAlignRight.test(o)?r.align.push(\"right\"):this.rules.other.tableAlignCenter.test(o)?r.align.push(\"center\"):this.rules.other.tableAlignLeft.test(o)?r.align.push(\"left\"):r.align.push(null);for(let o=0;o<n.length;o++)r.header.push({text:n[o],tokens:this.lexer.inline(n[o]),header:!0,align:r.align[o]});for(let o of i)r.rows.push(Y(o,r.header.length).map((a,c)=>({text:a,tokens:this.lexer.inline(a),header:!1,align:r.align[c]})));return r}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return{type:\"heading\",raw:t[0],depth:t[2].charAt(0)===\"=\"?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`\n`?t[1].slice(0,-1):t[1];return{type:\"paragraph\",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return{type:\"text\",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return{type:\"escape\",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return!this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=!0:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=!1),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=!0:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=!1),{type:\"html\",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:!1,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let r=A(n.slice(0,-1),\"\\\\\");if((n.length-r.length)%2===0)return}else{let r=de(t[2],\"()\");if(r===-2)return;if(r>-1){let a=(t[0].indexOf(\"!\")===0?5:4)+t[1].length+r;t[2]=t[2].substring(0,r),t[0]=t[0].substring(0,a).trim(),t[3]=\"\"}}let s=t[2],i=\"\";if(this.options.pedantic){let r=this.rules.other.pedanticHrefTitle.exec(s);r&&(s=r[1],i=r[3])}else i=t[3]?t[3].slice(1,-1):\"\";return s=s.trim(),this.rules.other.startAngleBracket.test(s)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?s=s.slice(1):s=s.slice(1,-1)),me(t,{href:s&&s.replace(this.rules.inline.anyPunctuation,\"$1\"),title:i&&i.replace(this.rules.inline.anyPunctuation,\"$1\")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let s=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal,\" \"),i=t[s.toLowerCase()];if(!i){let r=n[0].charAt(0);return{type:\"text\",raw:r,text:r}}return me(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=\"\"){let s=this.rules.inline.emStrongLDelim.exec(e);if(!s||s[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(s[1]||s[2]||\"\")||!n||this.rules.inline.punctuation.exec(n)){let r=[...s[0]].length-1,o,a,c=r,p=0,u=s[0][0]===\"*\"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(u.lastIndex=0,t=t.slice(-1*e.length+r);(s=u.exec(t))!=null;){if(o=s[1]||s[2]||s[3]||s[4]||s[5]||s[6],!o)continue;if(a=[...o].length,s[3]||s[4]){c+=a;continue}else if((s[5]||s[6])&&r%3&&!((r+a)%3)){p+=a;continue}if(c-=a,c>0)continue;a=Math.min(a,a+c+p);let d=[...s[0]][0].length,g=e.slice(0,r+s.index+d+a);if(Math.min(r,a)%2){let f=g.slice(1,-1);return{type:\"em\",raw:g,text:f,tokens:this.lexer.inlineTokens(f)}}let T=g.slice(2,-2);return{type:\"strong\",raw:g,text:T,tokens:this.lexer.inlineTokens(T)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal,\" \"),s=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return s&&i&&(n=n.substring(1,n.length-1)),{type:\"codespan\",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return{type:\"br\",raw:t[0]}}del(e){let t=this.rules.inline.del.exec(e);if(t)return{type:\"del\",raw:t[0],text:t[2],tokens:this.lexer.inlineTokens(t[2])}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,s;return t[2]===\"@\"?(n=t[1],s=\"mailto:\"+n):(n=t[1],s=n),{type:\"link\",raw:t[0],text:n,href:s,tokens:[{type:\"text\",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,s;if(t[2]===\"@\")n=t[0],s=\"mailto:\"+n;else{let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??\"\";while(i!==t[0]);n=t[0],t[1]===\"www.\"?s=\"http://\"+t[0]:s=t[0]}return{type:\"link\",raw:t[0],text:n,href:s,tokens:[{type:\"text\",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return{type:\"text\",raw:t[0],text:t[0],escaped:n}}}};var x=class l{tokens;options;state;tokenizer;inlineQueue;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||w,this.options.tokenizer=this.options.tokenizer||new S,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:!1,inRawBlock:!1,top:!0};let t={other:m,block:B.normal,inline:P.normal};this.options.pedantic?(t.block=B.pedantic,t.inline=P.pedantic):this.options.gfm&&(t.block=B.gfm,this.options.breaks?t.inline=P.breaks:t.inline=P.gfm),this.tokenizer.rules=t}static get rules(){return{block:B,inline:P}}static lex(e,t){return new l(t).lex(e)}static lexInline(e,t){return new l(t).inlineTokens(e)}lex(e){e=e.replace(m.carriageReturn,`\n`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens)}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=!1){for(this.options.pedantic&&(e=e.replace(m.tabCharGlobal,\"    \").replace(m.spaceLine,\"\"));e;){let s;if(this.options.extensions?.block?.some(r=>(s=r.call({lexer:this},e,t))?(e=e.substring(s.raw.length),t.push(s),!0):!1))continue;if(s=this.tokenizer.space(e)){e=e.substring(s.raw.length);let r=t.at(-1);s.raw.length===1&&r!==void 0?r.raw+=`\n`:t.push(s);continue}if(s=this.tokenizer.code(e)){e=e.substring(s.raw.length);let r=t.at(-1);r?.type===\"paragraph\"||r?.type===\"text\"?(r.raw+=`\n`+s.raw,r.text+=`\n`+s.text,this.inlineQueue.at(-1).src=r.text):t.push(s);continue}if(s=this.tokenizer.fences(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.heading(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.hr(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.blockquote(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.list(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.html(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.def(e)){e=e.substring(s.raw.length);let r=t.at(-1);r?.type===\"paragraph\"||r?.type===\"text\"?(r.raw+=`\n`+s.raw,r.text+=`\n`+s.raw,this.inlineQueue.at(-1).src=r.text):this.tokens.links[s.tag]||(this.tokens.links[s.tag]={href:s.href,title:s.title});continue}if(s=this.tokenizer.table(e)){e=e.substring(s.raw.length),t.push(s);continue}if(s=this.tokenizer.lheading(e)){e=e.substring(s.raw.length),t.push(s);continue}let i=e;if(this.options.extensions?.startBlock){let r=1/0,o=e.slice(1),a;this.options.extensions.startBlock.forEach(c=>{a=c.call({lexer:this},o),typeof a==\"number\"&&a>=0&&(r=Math.min(r,a))}),r<1/0&&r>=0&&(i=e.substring(0,r+1))}if(this.state.top&&(s=this.tokenizer.paragraph(i))){let r=t.at(-1);n&&r?.type===\"paragraph\"?(r.raw+=`\n`+s.raw,r.text+=`\n`+s.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=r.text):t.push(s),n=i.length!==e.length,e=e.substring(s.raw.length);continue}if(s=this.tokenizer.text(e)){e=e.substring(s.raw.length);let r=t.at(-1);r?.type===\"text\"?(r.raw+=`\n`+s.raw,r.text+=`\n`+s.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=r.text):t.push(s);continue}if(e){let r=\"Infinite loop on byte: \"+e.charCodeAt(0);if(this.options.silent){console.error(r);break}else throw new Error(r)}}return this.state.top=!0,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,s=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(s=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(s[0].slice(s[0].lastIndexOf(\"[\")+1,-1))&&(n=n.slice(0,s.index)+\"[\"+\"a\".repeat(s[0].length-2)+\"]\"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex))}for(;(s=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,s.index)+\"++\"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);for(;(s=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)n=n.slice(0,s.index)+\"[\"+\"a\".repeat(s[0].length-2)+\"]\"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);let i=!1,r=\"\";for(;e;){i||(r=\"\"),i=!1;let o;if(this.options.extensions?.inline?.some(c=>(o=c.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),!0):!1))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let c=t.at(-1);o.type===\"text\"&&c?.type===\"text\"?(c.raw+=o.raw,c.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,r)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let a=e;if(this.options.extensions?.startInline){let c=1/0,p=e.slice(1),u;this.options.extensions.startInline.forEach(d=>{u=d.call({lexer:this},p),typeof u==\"number\"&&u>=0&&(c=Math.min(c,u))}),c<1/0&&c>=0&&(a=e.substring(0,c+1))}if(o=this.tokenizer.inlineText(a)){e=e.substring(o.raw.length),o.raw.slice(-1)!==\"_\"&&(r=o.raw.slice(-1)),i=!0;let c=t.at(-1);c?.type===\"text\"?(c.raw+=o.raw,c.text+=o.text):t.push(o);continue}if(e){let c=\"Infinite loop on byte: \"+e.charCodeAt(0);if(this.options.silent){console.error(c);break}else throw new Error(c)}}return t}};var $=class{options;parser;constructor(e){this.options=e||w}space(e){return\"\"}code({text:e,lang:t,escaped:n}){let s=(t||\"\").match(m.notSpaceStart)?.[0],i=e.replace(m.endingNewline,\"\")+`\n`;return s?'<pre><code class=\"language-'+R(s)+'\">'+(n?i:R(i,!0))+`</code></pre>\n`:\"<pre><code>\"+(n?i:R(i,!0))+`</code></pre>\n`}blockquote({tokens:e}){return`<blockquote>\n${this.parser.parse(e)}</blockquote>\n`}html({text:e}){return e}heading({tokens:e,depth:t}){return`<h${t}>${this.parser.parseInline(e)}</h${t}>\n`}hr(e){return`<hr>\n`}list(e){let t=e.ordered,n=e.start,s=\"\";for(let o=0;o<e.items.length;o++){let a=e.items[o];s+=this.listitem(a)}let i=t?\"ol\":\"ul\",r=t&&n!==1?' start=\"'+n+'\"':\"\";return\"<\"+i+r+`>\n`+s+\"</\"+i+`>\n`}listitem(e){let t=\"\";if(e.task){let n=this.checkbox({checked:!!e.checked});e.loose?e.tokens[0]?.type===\"paragraph\"?(e.tokens[0].text=n+\" \"+e.tokens[0].text,e.tokens[0].tokens&&e.tokens[0].tokens.length>0&&e.tokens[0].tokens[0].type===\"text\"&&(e.tokens[0].tokens[0].text=n+\" \"+R(e.tokens[0].tokens[0].text),e.tokens[0].tokens[0].escaped=!0)):e.tokens.unshift({type:\"text\",raw:n+\" \",text:n+\" \",escaped:!0}):t+=n+\" \"}return t+=this.parser.parse(e.tokens,!!e.loose),`<li>${t}</li>\n`}checkbox({checked:e}){return\"<input \"+(e?'checked=\"\" ':\"\")+'disabled=\"\" type=\"checkbox\">'}paragraph({tokens:e}){return`<p>${this.parser.parseInline(e)}</p>\n`}table(e){let t=\"\",n=\"\";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let s=\"\";for(let i=0;i<e.rows.length;i++){let r=e.rows[i];n=\"\";for(let o=0;o<r.length;o++)n+=this.tablecell(r[o]);s+=this.tablerow({text:n})}return s&&(s=`<tbody>${s}</tbody>`),`<table>\n<thead>\n`+t+`</thead>\n`+s+`</table>\n`}tablerow({text:e}){return`<tr>\n${e}</tr>\n`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?\"th\":\"td\";return(e.align?`<${n} align=\"${e.align}\">`:`<${n}>`)+t+`</${n}>\n`}strong({tokens:e}){return`<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return`<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return`<code>${R(e,!0)}</code>`}br(e){return\"<br>\"}del({tokens:e}){return`<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let s=this.parser.parseInline(n),i=V(e);if(i===null)return s;e=i;let r='<a href=\"'+e+'\"';return t&&(r+=' title=\"'+R(t)+'\"'),r+=\">\"+s+\"</a>\",r}image({href:e,title:t,text:n,tokens:s}){s&&(n=this.parser.parseInline(s,this.parser.textRenderer));let i=V(e);if(i===null)return R(n);e=i;let r=`<img src=\"${e}\" alt=\"${n}\"`;return t&&(r+=` title=\"${R(t)}\"`),r+=\">\",r}text(e){return\"tokens\"in e&&e.tokens?this.parser.parseInline(e.tokens):\"escaped\"in e&&e.escaped?e.text:R(e.text)}};var _=class{strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return\"\"+e}image({text:e}){return\"\"+e}br(){return\"\"}};var b=class l{options;renderer;textRenderer;constructor(e){this.options=e||w,this.options.renderer=this.options.renderer||new $,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new _}static parse(e,t){return new l(t).parse(e)}static parseInline(e,t){return new l(t).parseInline(e)}parse(e,t=!0){let n=\"\";for(let s=0;s<e.length;s++){let i=e[s];if(this.options.extensions?.renderers?.[i.type]){let o=i,a=this.options.extensions.renderers[o.type].call({parser:this},o);if(a!==!1||![\"space\",\"hr\",\"heading\",\"code\",\"table\",\"blockquote\",\"list\",\"html\",\"paragraph\",\"text\"].includes(o.type)){n+=a||\"\";continue}}let r=i;switch(r.type){case\"space\":{n+=this.renderer.space(r);continue}case\"hr\":{n+=this.renderer.hr(r);continue}case\"heading\":{n+=this.renderer.heading(r);continue}case\"code\":{n+=this.renderer.code(r);continue}case\"table\":{n+=this.renderer.table(r);continue}case\"blockquote\":{n+=this.renderer.blockquote(r);continue}case\"list\":{n+=this.renderer.list(r);continue}case\"html\":{n+=this.renderer.html(r);continue}case\"paragraph\":{n+=this.renderer.paragraph(r);continue}case\"text\":{let o=r,a=this.renderer.text(o);for(;s+1<e.length&&e[s+1].type===\"text\";)o=e[++s],a+=`\n`+this.renderer.text(o);t?n+=this.renderer.paragraph({type:\"paragraph\",raw:a,text:a,tokens:[{type:\"text\",raw:a,text:a,escaped:!0}]}):n+=a;continue}default:{let o='Token with \"'+r.type+'\" type was not found.';if(this.options.silent)return console.error(o),\"\";throw new Error(o)}}}return n}parseInline(e,t=this.renderer){let n=\"\";for(let s=0;s<e.length;s++){let i=e[s];if(this.options.extensions?.renderers?.[i.type]){let o=this.options.extensions.renderers[i.type].call({parser:this},i);if(o!==!1||![\"escape\",\"html\",\"link\",\"image\",\"strong\",\"em\",\"codespan\",\"br\",\"del\",\"text\"].includes(i.type)){n+=o||\"\";continue}}let r=i;switch(r.type){case\"escape\":{n+=t.text(r);break}case\"html\":{n+=t.html(r);break}case\"link\":{n+=t.link(r);break}case\"image\":{n+=t.image(r);break}case\"strong\":{n+=t.strong(r);break}case\"em\":{n+=t.em(r);break}case\"codespan\":{n+=t.codespan(r);break}case\"br\":{n+=t.br(r);break}case\"del\":{n+=t.del(r);break}case\"text\":{n+=t.text(r);break}default:{let o='Token with \"'+r.type+'\" type was not found.';if(this.options.silent)return console.error(o),\"\";throw new Error(o)}}}return n}};var L=class{options;block;constructor(e){this.options=e||w}static passThroughHooks=new Set([\"preprocess\",\"postprocess\",\"processAllTokens\"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}provideLexer(){return this.block?x.lex:x.lexInline}provideParser(){return this.block?b.parse:b.parseInline}};var E=class{defaults=z();options=this.setOptions;parse=this.parseMarkdown(!0);parseInline=this.parseMarkdown(!1);Parser=b;Renderer=$;TextRenderer=_;Lexer=x;Tokenizer=S;Hooks=L;constructor(...e){this.use(...e)}walkTokens(e,t){let n=[];for(let s of e)switch(n=n.concat(t.call(this,s)),s.type){case\"table\":{let i=s;for(let r of i.header)n=n.concat(this.walkTokens(r.tokens,t));for(let r of i.rows)for(let o of r)n=n.concat(this.walkTokens(o.tokens,t));break}case\"list\":{let i=s;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=s;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(r=>{let o=i[r].flat(1/0);n=n.concat(this.walkTokens(o,t))}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)))}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let s={...n};if(s.async=this.defaults.async||s.async||!1,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error(\"extension name required\");if(\"renderer\"in i){let r=t.renderers[i.name];r?t.renderers[i.name]=function(...o){let a=i.renderer.apply(this,o);return a===!1&&(a=r.apply(this,o)),a}:t.renderers[i.name]=i.renderer}if(\"tokenizer\"in i){if(!i.level||i.level!==\"block\"&&i.level!==\"inline\")throw new Error(\"extension level must be 'block' or 'inline'\");let r=t[i.level];r?r.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level===\"block\"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level===\"inline\"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]))}\"childTokens\"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens)}),s.extensions=t),n.renderer){let i=this.defaults.renderer||new $(this.defaults);for(let r in n.renderer){if(!(r in i))throw new Error(`renderer '${r}' does not exist`);if([\"options\",\"parser\"].includes(r))continue;let o=r,a=n.renderer[o],c=i[o];i[o]=(...p)=>{let u=a.apply(i,p);return u===!1&&(u=c.apply(i,p)),u||\"\"}}s.renderer=i}if(n.tokenizer){let i=this.defaults.tokenizer||new S(this.defaults);for(let r in n.tokenizer){if(!(r in i))throw new Error(`tokenizer '${r}' does not exist`);if([\"options\",\"rules\",\"lexer\"].includes(r))continue;let o=r,a=n.tokenizer[o],c=i[o];i[o]=(...p)=>{let u=a.apply(i,p);return u===!1&&(u=c.apply(i,p)),u}}s.tokenizer=i}if(n.hooks){let i=this.defaults.hooks||new L;for(let r in n.hooks){if(!(r in i))throw new Error(`hook '${r}' does not exist`);if([\"options\",\"block\"].includes(r))continue;let o=r,a=n.hooks[o],c=i[o];L.passThroughHooks.has(r)?i[o]=p=>{if(this.defaults.async)return Promise.resolve(a.call(i,p)).then(d=>c.call(i,d));let u=a.call(i,p);return c.call(i,u)}:i[o]=(...p)=>{let u=a.apply(i,p);return u===!1&&(u=c.apply(i,p)),u}}s.hooks=i}if(n.walkTokens){let i=this.defaults.walkTokens,r=n.walkTokens;s.walkTokens=function(o){let a=[];return a.push(r.call(this,o)),i&&(a=a.concat(i.call(this,o))),a}}this.defaults={...this.defaults,...s}}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return x.lex(e,t??this.defaults)}parser(e,t){return b.parse(e,t??this.defaults)}parseMarkdown(e){return(n,s)=>{let i={...s},r={...this.defaults,...i},o=this.onError(!!r.silent,!!r.async);if(this.defaults.async===!0&&i.async===!1)return o(new Error(\"marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.\"));if(typeof n>\"u\"||n===null)return o(new Error(\"marked(): input parameter is undefined or null\"));if(typeof n!=\"string\")return o(new Error(\"marked(): input parameter is of type \"+Object.prototype.toString.call(n)+\", string expected\"));r.hooks&&(r.hooks.options=r,r.hooks.block=e);let a=r.hooks?r.hooks.provideLexer():e?x.lex:x.lexInline,c=r.hooks?r.hooks.provideParser():e?b.parse:b.parseInline;if(r.async)return Promise.resolve(r.hooks?r.hooks.preprocess(n):n).then(p=>a(p,r)).then(p=>r.hooks?r.hooks.processAllTokens(p):p).then(p=>r.walkTokens?Promise.all(this.walkTokens(p,r.walkTokens)).then(()=>p):p).then(p=>c(p,r)).then(p=>r.hooks?r.hooks.postprocess(p):p).catch(o);try{r.hooks&&(n=r.hooks.preprocess(n));let p=a(n,r);r.hooks&&(p=r.hooks.processAllTokens(p)),r.walkTokens&&this.walkTokens(p,r.walkTokens);let u=c(p,r);return r.hooks&&(u=r.hooks.postprocess(u)),u}catch(p){return o(p)}}}onError(e,t){return n=>{if(n.message+=`\nPlease report this to https://github.com/markedjs/marked.`,e){let s=\"<p>An error occurred:</p><pre>\"+R(n.message+\"\",!0)+\"</pre>\";return t?Promise.resolve(s):s}if(t)return Promise.reject(n);throw n}}};var M=new E;function k(l,e){return M.parse(l,e)}k.options=k.setOptions=function(l){return M.setOptions(l),k.defaults=M.defaults,N(k.defaults),k};k.getDefaults=z;k.defaults=w;k.use=function(...l){return M.use(...l),k.defaults=M.defaults,N(k.defaults),k};k.walkTokens=function(l,e){return M.walkTokens(l,e)};k.parseInline=M.parseInline;k.Parser=b;k.parser=b.parse;k.Renderer=$;k.TextRenderer=_;k.Lexer=x;k.lexer=x.lex;k.Tokenizer=S;k.Hooks=L;k.parse=k;var it=k.options,ot=k.setOptions,lt=k.use,at=k.walkTokens,ct=k.parseInline,pt=k,ut=b.parse,ht=x.lex;\n\nif(__exports != exports)module.exports = exports;return module.exports}));\n//# sourceMappingURL=marked.umd.js.map\n","import { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { Marked } from './Instance.ts';\nimport {\n  _getDefaults,\n  changeDefaults,\n  _defaults,\n} from './defaults.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\nimport type { MaybePromise } from './Instance.ts';\n\nconst markedInstance = new Marked();\n\n/**\n * Compiles markdown to HTML asynchronously.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options, having async: true\n * @return Promise of string of compiled HTML\n */\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\n\n/**\n * Compiles markdown to HTML.\n *\n * @param src String of markdown source to be compiled\n * @param options Optional hash of options\n * @return String of compiled HTML. Will be a Promise of string if async is set to true by any extensions.\n */\nexport function marked(src: string, options: MarkedOptions & { async: false }): string;\nexport function marked(src: string, options: MarkedOptions & { async: true }): Promise<string>;\nexport function marked(src: string, options?: MarkedOptions | null): string | Promise<string>;\nexport function marked(src: string, opt?: MarkedOptions | null): string | Promise<string> {\n  return markedInstance.parse(src, opt);\n}\n\n/**\n * Sets the default options.\n *\n * @param options Hash of options\n */\nmarked.options =\nmarked.setOptions = function(options: MarkedOptions) {\n  markedInstance.setOptions(options);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Gets the original marked default options.\n */\nmarked.getDefaults = _getDefaults;\n\nmarked.defaults = _defaults;\n\n/**\n * Use Extension\n */\n\nmarked.use = function(...args: MarkedExtension[]) {\n  markedInstance.use(...args);\n  marked.defaults = markedInstance.defaults;\n  changeDefaults(marked.defaults);\n  return marked;\n};\n\n/**\n * Run callback for every token\n */\n\nmarked.walkTokens = function(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n  return markedInstance.walkTokens(tokens, callback);\n};\n\n/**\n * Compiles markdown to HTML without enclosing `p` tag.\n *\n * @param src String of markdown source to be compiled\n * @param options Hash of options\n * @return String of compiled HTML\n */\nmarked.parseInline = markedInstance.parseInline;\n\n/**\n * Expose\n */\nmarked.Parser = _Parser;\nmarked.parser = _Parser.parse;\nmarked.Renderer = _Renderer;\nmarked.TextRenderer = _TextRenderer;\nmarked.Lexer = _Lexer;\nmarked.lexer = _Lexer.lex;\nmarked.Tokenizer = _Tokenizer;\nmarked.Hooks = _Hooks;\nmarked.parse = marked;\n\nexport const options = marked.options;\nexport const setOptions = marked.setOptions;\nexport const use = marked.use;\nexport const walkTokens = marked.walkTokens;\nexport const parseInline = marked.parseInline;\nexport const parse = marked;\nexport const parser = _Parser.parse;\nexport const lexer = _Lexer.lex;\nexport { _defaults as defaults, _getDefaults as getDefaults } from './defaults.ts';\nexport { _Lexer as Lexer } from './Lexer.ts';\nexport { _Parser as Parser } from './Parser.ts';\nexport { _Tokenizer as Tokenizer } from './Tokenizer.ts';\nexport { _Renderer as Renderer } from './Renderer.ts';\nexport { _TextRenderer as TextRenderer } from './TextRenderer.ts';\nexport { _Hooks as Hooks } from './Hooks.ts';\nexport { Marked } from './Instance.ts';\nexport type * from './MarkedOptions.ts';\nexport type * from './Tokens.ts';\n","import type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Gets the original marked default options.\n */\nexport function _getDefaults(): MarkedOptions {\n  return {\n    async: false,\n    breaks: false,\n    extensions: null,\n    gfm: true,\n    hooks: null,\n    pedantic: false,\n    renderer: null,\n    silent: false,\n    tokenizer: null,\n    walkTokens: null,\n  };\n}\n\nexport let _defaults = _getDefaults();\n\nexport function changeDefaults(newDefaults: MarkedOptions) {\n  _defaults = newDefaults;\n}\n","const noopTest = { exec: () => null } as unknown as RegExp;\n\nfunction edit(regex: string | RegExp, opt = '') {\n  let source = typeof regex === 'string' ? regex : regex.source;\n  const obj = {\n    replace: (name: string | RegExp, val: string | RegExp) => {\n      let valSource = typeof val === 'string' ? val : val.source;\n      valSource = valSource.replace(other.caret, '$1');\n      source = source.replace(name, valSource);\n      return obj;\n    },\n    getRegex: () => {\n      return new RegExp(source, opt);\n    },\n  };\n  return obj;\n}\n\nexport const other = {\n  codeRemoveIndent: /^(?: {1,4}| {0,3}\\t)/gm,\n  outputLinkReplace: /\\\\([\\[\\]])/g,\n  indentCodeCompensation: /^(\\s+)(?:```)/,\n  beginningSpace: /^\\s+/,\n  endingHash: /#$/,\n  startingSpaceChar: /^ /,\n  endingSpaceChar: / $/,\n  nonSpaceChar: /[^ ]/,\n  newLineCharGlobal: /\\n/g,\n  tabCharGlobal: /\\t/g,\n  multipleSpaceGlobal: /\\s+/g,\n  blankLine: /^[ \\t]*$/,\n  doubleBlankLine: /\\n[ \\t]*\\n[ \\t]*$/,\n  blockquoteStart: /^ {0,3}>/,\n  blockquoteSetextReplace: /\\n {0,3}((?:=+|-+) *)(?=\\n|$)/g,\n  blockquoteSetextReplace2: /^ {0,3}>[ \\t]?/gm,\n  listReplaceTabs: /^\\t+/,\n  listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,\n  listIsTask: /^\\[[ xX]\\] /,\n  listReplaceTask: /^\\[[ xX]\\] +/,\n  anyLine: /\\n.*\\n/,\n  hrefBrackets: /^<(.*)>$/,\n  tableDelimiter: /[:|]/,\n  tableAlignChars: /^\\||\\| *$/g,\n  tableRowBlankLine: /\\n[ \\t]*$/,\n  tableAlignRight: /^ *-+: *$/,\n  tableAlignCenter: /^ *:-+: *$/,\n  tableAlignLeft: /^ *:-+ *$/,\n  startATag: /^<a /i,\n  endATag: /^<\\/a>/i,\n  startPreScriptTag: /^<(pre|code|kbd|script)(\\s|>)/i,\n  endPreScriptTag: /^<\\/(pre|code|kbd|script)(\\s|>)/i,\n  startAngleBracket: /^</,\n  endAngleBracket: />$/,\n  pedanticHrefTitle: /^([^'\"]*[^\\s])\\s+(['\"])(.*)\\2/,\n  unicodeAlphaNumeric: /[\\p{L}\\p{N}]/u,\n  escapeTest: /[&<>\"']/,\n  escapeReplace: /[&<>\"']/g,\n  escapeTestNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/,\n  escapeReplaceNoEncode: /[<>\"']|&(?!(#\\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\\w+);)/g,\n  unescapeTest: /&(#(?:\\d+)|(?:#x[0-9A-Fa-f]+)|(?:\\w+));?/ig,\n  caret: /(^|[^\\[])\\^/g,\n  percentDecode: /%25/g,\n  findPipe: /\\|/g,\n  splitPipe: / \\|/,\n  slashPipe: /\\\\\\|/g,\n  carriageReturn: /\\r\\n|\\r/g,\n  spaceLine: /^ +$/gm,\n  notSpaceStart: /^\\S*/,\n  endingNewline: /\\n$/,\n  listItemRegex: (bull: string) => new RegExp(`^( {0,3}${bull})((?:[\\t ][^\\\\n]*)?(?:\\\\n|$))`),\n  nextBulletRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:[*+-]|\\\\d{1,9}[.)])((?:[ \\t][^\\\\n]*)?(?:\\\\n|$))`),\n  hrRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\\\* *){3,})(?:\\\\n+|$)`),\n  fencesBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}(?:\\`\\`\\`|~~~)`),\n  headingBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}#`),\n  htmlBeginRegex: (indent: number) => new RegExp(`^ {0,${Math.min(3, indent - 1)}}<(?:[a-z].*>|!--)`, 'i'),\n};\n\n/**\n * Block-Level Grammar\n */\n\nconst newline = /^(?:[ \\t]*(?:\\n|$))+/;\nconst blockCode = /^((?: {4}| {0,3}\\t)[^\\n]+(?:\\n(?:[ \\t]*(?:\\n|$))*)?)+/;\nconst fences = /^ {0,3}(`{3,}(?=[^`\\n]*(?:\\n|$))|~{3,})([^\\n]*)(?:\\n|$)(?:|([\\s\\S]*?)(?:\\n|$))(?: {0,3}\\1[~`]* *(?=\\n|$)|$)/;\nconst hr = /^ {0,3}((?:-[\\t ]*){3,}|(?:_[ \\t]*){3,}|(?:\\*[ \\t]*){3,})(?:\\n+|$)/;\nconst heading = /^ {0,3}(#{1,6})(?=\\s|$)(.*)(?:\\n+|$)/;\nconst bullet = /(?:[*+-]|\\d{1,9}[.)])/;\nconst lheadingCore = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\\n(?!\\s*?\\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/;\nconst lheading = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/\\|table/g, '') // table not in commonmark\n  .getRegex();\nconst lheadingGfm = edit(lheadingCore)\n  .replace(/bull/g, bullet) // lists can interrupt\n  .replace(/blockCode/g, /(?: {4}| {0,3}\\t)/) // indented code blocks can interrupt\n  .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/) // fenced code blocks can interrupt\n  .replace(/blockquote/g, / {0,3}>/) // blockquote can interrupt\n  .replace(/heading/g, / {0,3}#{1,6}/) // ATX heading can interrupt\n  .replace(/html/g, / {0,3}<[^\\n>]+>\\n/) // block html can interrupt\n  .replace(/table/g, / {0,3}\\|?(?:[:\\- ]*\\|)+[\\:\\- ]*\\n/) // table can interrupt\n  .getRegex();\nconst _paragraph = /^([^\\n]+(?:\\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\\n)[^\\n]+)*)/;\nconst blockText = /^[^\\n]+/;\nconst _blockLabel = /(?!\\s*\\])(?:\\\\.|[^\\[\\]\\\\])+/;\nconst def = edit(/^ {0,3}\\[(label)\\]: *(?:\\n[ \\t]*)?([^<\\s][^\\s]*|<.*?>)(?:(?: +(?:\\n[ \\t]*)?| *\\n[ \\t]*)(title))? *(?:\\n+|$)/)\n  .replace('label', _blockLabel)\n  .replace('title', /(?:\"(?:\\\\\"?|[^\"\\\\])*\"|'[^'\\n]*(?:\\n[^'\\n]+)*\\n?'|\\([^()]*\\))/)\n  .getRegex();\n\nconst list = edit(/^( {0,3}bull)([ \\t][^\\n]+?)?(?:\\n|$)/)\n  .replace(/bull/g, bullet)\n  .getRegex();\n\nconst _tag = 'address|article|aside|base|basefont|blockquote|body|caption'\n  + '|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption'\n  + '|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe'\n  + '|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option'\n  + '|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title'\n  + '|tr|track|ul';\nconst _comment = /<!--(?:-?>|[\\s\\S]*?(?:-->|$))/;\nconst html = edit(\n  '^ {0,3}(?:' // optional indentation\n+ '<(script|pre|style|textarea)[\\\\s>][\\\\s\\\\S]*?(?:</\\\\1>[^\\\\n]*\\\\n+|$)' // (1)\n+ '|comment[^\\\\n]*(\\\\n+|$)' // (2)\n+ '|<\\\\?[\\\\s\\\\S]*?(?:\\\\?>\\\\n*|$)' // (3)\n+ '|<![A-Z][\\\\s\\\\S]*?(?:>\\\\n*|$)' // (4)\n+ '|<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?(?:\\\\]\\\\]>\\\\n*|$)' // (5)\n+ '|</?(tag)(?: +|\\\\n|/?>)[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (6)\n+ '|<(?!script|pre|style|textarea)([a-z][\\\\w-]*)(?:attribute)*? */?>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) open tag\n+ '|</(?!script|pre|style|textarea)[a-z][\\\\w-]*\\\\s*>(?=[ \\\\t]*(?:\\\\n|$))[\\\\s\\\\S]*?(?:(?:\\\\n[ \\t]*)+\\\\n|$)' // (7) closing tag\n+ ')', 'i')\n  .replace('comment', _comment)\n  .replace('tag', _tag)\n  .replace('attribute', / +[a-zA-Z:_][\\w.:-]*(?: *= *\"[^\"\\n]*\"| *= *'[^'\\n]*'| *= *[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst paragraph = edit(_paragraph)\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n  .replace('|table', '')\n  .replace('blockquote', ' {0,3}>')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockquote = edit(/^( {0,3}> ?(paragraph|[^\\n]*)(?:\\n|$))+/)\n  .replace('paragraph', paragraph)\n  .getRegex();\n\n/**\n * Normal Block Grammar\n */\n\nconst blockNormal = {\n  blockquote,\n  code: blockCode,\n  def,\n  fences,\n  heading,\n  hr,\n  html,\n  lheading,\n  list,\n  newline,\n  paragraph,\n  table: noopTest,\n  text: blockText,\n};\n\ntype BlockKeys = keyof typeof blockNormal;\n\n/**\n * GFM Block Grammar\n */\n\nconst gfmTable = edit(\n  '^ *([^\\\\n ].*)\\\\n' // Header\n+ ' {0,3}((?:\\\\| *)?:?-+:? *(?:\\\\| *:?-+:? *)*(?:\\\\| *)?)' // Align\n+ '(?:\\\\n((?:(?! *\\\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\\\n|$))*)\\\\n*|$)') // Cells\n  .replace('hr', hr)\n  .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n  .replace('blockquote', ' {0,3}>')\n  .replace('code', '(?: {4}| {0,3}\\t)[^\\\\n]')\n  .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n  .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n  .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n  .replace('tag', _tag) // tables can be interrupted by type (6) html blocks\n  .getRegex();\n\nconst blockGfm: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  lheading: lheadingGfm,\n  table: gfmTable,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' {0,3}#{1,6}(?:\\\\s|$)')\n    .replace('|lheading', '') // setext headings don't interrupt commonmark paragraphs\n    .replace('table', gfmTable) // interrupt paragraphs with table\n    .replace('blockquote', ' {0,3}>')\n    .replace('fences', ' {0,3}(?:`{3,}(?=[^`\\\\n]*\\\\n)|~{3,})[^\\\\n]*\\\\n')\n    .replace('list', ' {0,3}(?:[*+-]|1[.)]) ') // only lists starting from 1 can interrupt\n    .replace('html', '</?(?:tag)(?: +|\\\\n|/?>)|<(?:script|pre|style|textarea|!--)')\n    .replace('tag', _tag) // pars can be interrupted by type (6) html blocks\n    .getRegex(),\n};\n\n/**\n * Pedantic grammar (original John Gruber's loose markdown specification)\n */\n\nconst blockPedantic: Record<BlockKeys, RegExp> = {\n  ...blockNormal,\n  html: edit(\n    '^ *(?:comment *(?:\\\\n|\\\\s*$)'\n    + '|<(tag)[\\\\s\\\\S]+?</\\\\1> *(?:\\\\n{2,}|\\\\s*$)' // closed tag\n    + '|<tag(?:\"[^\"]*\"|\\'[^\\']*\\'|\\\\s[^\\'\"/>\\\\s]*)*?/?> *(?:\\\\n{2,}|\\\\s*$))')\n    .replace('comment', _comment)\n    .replace(/tag/g, '(?!(?:'\n      + 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub'\n      + '|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)'\n      + '\\\\b)\\\\w+(?!:|[^\\\\w\\\\s@]*@)\\\\b')\n    .getRegex(),\n  def: /^ *\\[([^\\]]+)\\]: *<?([^\\s>]+)>?(?: +([\"(][^\\n]+[\")]))? *(?:\\n+|$)/,\n  heading: /^(#{1,6})(.*)(?:\\n+|$)/,\n  fences: noopTest, // fences not supported\n  lheading: /^(.+?)\\n {0,3}(=+|-+) *(?:\\n+|$)/,\n  paragraph: edit(_paragraph)\n    .replace('hr', hr)\n    .replace('heading', ' *#{1,6} *[^\\n]')\n    .replace('lheading', lheading)\n    .replace('|table', '')\n    .replace('blockquote', ' {0,3}>')\n    .replace('|fences', '')\n    .replace('|list', '')\n    .replace('|html', '')\n    .replace('|tag', '')\n    .getRegex(),\n};\n\n/**\n * Inline-Level Grammar\n */\n\nconst escape = /^\\\\([!\"#$%&'()*+,\\-./:;<=>?@\\[\\]\\\\^_`{|}~])/;\nconst inlineCode = /^(`+)([^`]|[^`][\\s\\S]*?[^`])\\1(?!`)/;\nconst br = /^( {2,}|\\\\)\\n(?!\\s*$)/;\nconst inlineText = /^(`+|[^`])(?:(?= {2,}\\n)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*_]|\\b_|$)|[^ ](?= {2,}\\n)))/;\n\n// list of unicode punctuation marks, plus any missing characters from CommonMark spec\nconst _punctuation = /[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpace = /[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpace = /[^\\s\\p{P}\\p{S}]/u;\nconst punctuation = edit(/^((?![*_])punctSpace)/, 'u')\n  .replace(/punctSpace/g, _punctuationOrSpace).getRegex();\n\n// GFM allows ~ inside strong and em for strikethrough\nconst _punctuationGfmStrongEm = /(?!~)[\\p{P}\\p{S}]/u;\nconst _punctuationOrSpaceGfmStrongEm = /(?!~)[\\s\\p{P}\\p{S}]/u;\nconst _notPunctuationOrSpaceGfmStrongEm = /(?:[^\\s\\p{P}\\p{S}]|~)/u;\n\n// sequences em should skip over [title](link), `code`, <html>\nconst blockSkip = /\\[[^[\\]]*?\\]\\((?:\\\\.|[^\\\\\\(\\)]|\\((?:\\\\.|[^\\\\\\(\\)])*\\))*\\)|`[^`]*?`|<[^<>]*?>/g;\n\nconst emStrongLDelimCore = /^(?:\\*+(?:((?!\\*)punct)|[^\\s*]))|^_+(?:((?!_)punct)|([^\\s_]))/;\n\nconst emStrongLDelim = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongLDelimGfm = edit(emStrongLDelimCore, 'u')\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\nconst emStrongRDelimAstCore =\n  '^[^_*]*?__[^_*]*?\\\\*[^_*]*?(?=__)' // Skip orphan inside strong\n+ '|[^*]+(?=[^*])' // Consume to delim\n+ '|(?!\\\\*)punct(\\\\*+)(?=[\\\\s]|$)' // (1) #*** can only be a Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?!\\\\*)(?=punctSpace|$)' // (2) a***#, a*** can only be a Right Delimiter\n+ '|(?!\\\\*)punctSpace(\\\\*+)(?=notPunctSpace)' // (3) #***a, ***a can only be Left Delimiter\n+ '|[\\\\s](\\\\*+)(?!\\\\*)(?=punct)' // (4) ***# can only be Left Delimiter\n+ '|(?!\\\\*)punct(\\\\*+)(?!\\\\*)(?=punct)' // (5) #***# can be either Left or Right Delimiter\n+ '|notPunctSpace(\\\\*+)(?=notPunctSpace)'; // (6) a***a can be either Left or Right Delimiter\n\nconst emStrongRDelimAst = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst emStrongRDelimAstGfm = edit(emStrongRDelimAstCore, 'gu')\n  .replace(/notPunctSpace/g, _notPunctuationOrSpaceGfmStrongEm)\n  .replace(/punctSpace/g, _punctuationOrSpaceGfmStrongEm)\n  .replace(/punct/g, _punctuationGfmStrongEm)\n  .getRegex();\n\n// (6) Not allowed for _\nconst emStrongRDelimUnd = edit(\n  '^[^_*]*?\\\\*\\\\*[^_*]*?_[^_*]*?(?=\\\\*\\\\*)' // Skip orphan inside strong\n+ '|[^_]+(?=[^_])' // Consume to delim\n+ '|(?!_)punct(_+)(?=[\\\\s]|$)' // (1) #___ can only be a Right Delimiter\n+ '|notPunctSpace(_+)(?!_)(?=punctSpace|$)' // (2) a___#, a___ can only be a Right Delimiter\n+ '|(?!_)punctSpace(_+)(?=notPunctSpace)' // (3) #___a, ___a can only be Left Delimiter\n+ '|[\\\\s](_+)(?!_)(?=punct)' // (4) ___# can only be Left Delimiter\n+ '|(?!_)punct(_+)(?!_)(?=punct)', 'gu') // (5) #___# can be either Left or Right Delimiter\n  .replace(/notPunctSpace/g, _notPunctuationOrSpace)\n  .replace(/punctSpace/g, _punctuationOrSpace)\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst anyPunctuation = edit(/\\\\(punct)/, 'gu')\n  .replace(/punct/g, _punctuation)\n  .getRegex();\n\nconst autolink = edit(/^<(scheme:[^\\s\\x00-\\x1f<>]*|email)>/)\n  .replace('scheme', /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)\n  .replace('email', /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/)\n  .getRegex();\n\nconst _inlineComment = edit(_comment).replace('(?:-->|$)', '-->').getRegex();\nconst tag = edit(\n  '^comment'\n    + '|^</[a-zA-Z][\\\\w:-]*\\\\s*>' // self-closing tag\n    + '|^<[a-zA-Z][\\\\w-]*(?:attribute)*?\\\\s*/?>' // open tag\n    + '|^<\\\\?[\\\\s\\\\S]*?\\\\?>' // processing instruction, e.g. <?php ?>\n    + '|^<![a-zA-Z]+\\\\s[\\\\s\\\\S]*?>' // declaration, e.g. <!DOCTYPE html>\n    + '|^<!\\\\[CDATA\\\\[[\\\\s\\\\S]*?\\\\]\\\\]>') // CDATA section\n  .replace('comment', _inlineComment)\n  .replace('attribute', /\\s+[a-zA-Z:_][\\w.:-]*(?:\\s*=\\s*\"[^\"]*\"|\\s*=\\s*'[^']*'|\\s*=\\s*[^\\s\"'=<>`]+)?/)\n  .getRegex();\n\nconst _inlineLabel = /(?:\\[(?:\\\\.|[^\\[\\]\\\\])*\\]|\\\\.|`[^`]*`|[^\\[\\]\\\\`])*?/;\n\nconst link = edit(/^!?\\[(label)\\]\\(\\s*(href)(?:(?:[ \\t]*(?:\\n[ \\t]*)?)(title))?\\s*\\)/)\n  .replace('label', _inlineLabel)\n  .replace('href', /<(?:\\\\.|[^\\n<>\\\\])+>|[^ \\t\\n\\x00-\\x1f]*/)\n  .replace('title', /\"(?:\\\\\"?|[^\"\\\\])*\"|'(?:\\\\'?|[^'\\\\])*'|\\((?:\\\\\\)?|[^)\\\\])*\\)/)\n  .getRegex();\n\nconst reflink = edit(/^!?\\[(label)\\]\\[(ref)\\]/)\n  .replace('label', _inlineLabel)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst nolink = edit(/^!?\\[(ref)\\](?:\\[\\])?/)\n  .replace('ref', _blockLabel)\n  .getRegex();\n\nconst reflinkSearch = edit('reflink|nolink(?!\\\\()', 'g')\n  .replace('reflink', reflink)\n  .replace('nolink', nolink)\n  .getRegex();\n\n/**\n * Normal Inline Grammar\n */\n\nconst inlineNormal = {\n  _backpedal: noopTest, // only used for GFM url\n  anyPunctuation,\n  autolink,\n  blockSkip,\n  br,\n  code: inlineCode,\n  del: noopTest,\n  emStrongLDelim,\n  emStrongRDelimAst,\n  emStrongRDelimUnd,\n  escape,\n  link,\n  nolink,\n  punctuation,\n  reflink,\n  reflinkSearch,\n  tag,\n  text: inlineText,\n  url: noopTest,\n};\n\ntype InlineKeys = keyof typeof inlineNormal;\n\n/**\n * Pedantic Inline Grammar\n */\n\nconst inlinePedantic: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  link: edit(/^!?\\[(label)\\]\\((.*?)\\)/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n  reflink: edit(/^!?\\[(label)\\]\\s*\\[([^\\]]*)\\]/)\n    .replace('label', _inlineLabel)\n    .getRegex(),\n};\n\n/**\n * GFM Inline Grammar\n */\n\nconst inlineGfm: Record<InlineKeys, RegExp> = {\n  ...inlineNormal,\n  emStrongRDelimAst: emStrongRDelimAstGfm,\n  emStrongLDelim: emStrongLDelimGfm,\n  url: edit(/^((?:ftp|https?):\\/\\/|www\\.)(?:[a-zA-Z0-9\\-]+\\.?)+[^\\s<]*|^email/, 'i')\n    .replace('email', /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/)\n    .getRegex(),\n  _backpedal: /(?:[^?!.,:;*_'\"~()&]+|\\([^)]*\\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'\"~)]+(?!$))+/,\n  del: /^(~~?)(?=[^\\s~])((?:\\\\.|[^\\\\])*?(?:\\\\.|[^\\s~\\\\]))\\1(?=[^~]|$)/,\n  text: /^([`~]+|[^`~])(?:(?= {2,}\\n)|(?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)|[\\s\\S]*?(?:(?=[\\\\<!\\[`*~_]|\\b_|https?:\\/\\/|ftp:\\/\\/|www\\.|$)|[^ ](?= {2,}\\n)|[^a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-](?=[a-zA-Z0-9.!#$%&'*+\\/=?_`{\\|}~-]+@)))/,\n};\n\n/**\n * GFM + Line Breaks Inline Grammar\n */\n\nconst inlineBreaks: Record<InlineKeys, RegExp> = {\n  ...inlineGfm,\n  br: edit(br).replace('{2,}', '*').getRegex(),\n  text: edit(inlineGfm.text)\n    .replace('\\\\b_', '\\\\b_| {2,}\\\\n')\n    .replace(/\\{2,\\}/g, '*')\n    .getRegex(),\n};\n\n/**\n * exports\n */\n\nexport const block = {\n  normal: blockNormal,\n  gfm: blockGfm,\n  pedantic: blockPedantic,\n};\n\nexport const inline = {\n  normal: inlineNormal,\n  gfm: inlineGfm,\n  breaks: inlineBreaks,\n  pedantic: inlinePedantic,\n};\n\nexport interface Rules {\n  other: typeof other\n  block: Record<BlockKeys, RegExp>\n  inline: Record<InlineKeys, RegExp>\n}\n","import { other } from './rules.ts';\n\n/**\n * Helpers\n */\nconst escapeReplacements: { [index: string]: string } = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#39;',\n};\nconst getEscapeReplacement = (ch: string) => escapeReplacements[ch];\n\nexport function escape(html: string, encode?: boolean) {\n  if (encode) {\n    if (other.escapeTest.test(html)) {\n      return html.replace(other.escapeReplace, getEscapeReplacement);\n    }\n  } else {\n    if (other.escapeTestNoEncode.test(html)) {\n      return html.replace(other.escapeReplaceNoEncode, getEscapeReplacement);\n    }\n  }\n\n  return html;\n}\n\nexport function unescape(html: string) {\n  // explicitly match decimal, hex, and named HTML entities\n  return html.replace(other.unescapeTest, (_, n) => {\n    n = n.toLowerCase();\n    if (n === 'colon') return ':';\n    if (n.charAt(0) === '#') {\n      return n.charAt(1) === 'x'\n        ? String.fromCharCode(parseInt(n.substring(2), 16))\n        : String.fromCharCode(+n.substring(1));\n    }\n    return '';\n  });\n}\n\nexport function cleanUrl(href: string) {\n  try {\n    href = encodeURI(href).replace(other.percentDecode, '%');\n  } catch {\n    return null;\n  }\n  return href;\n}\n\nexport function splitCells(tableRow: string, count?: number) {\n  // ensure that every cell-delimiting pipe has a space\n  // before it to distinguish it from an escaped pipe\n  const row = tableRow.replace(other.findPipe, (match, offset, str) => {\n      let escaped = false;\n      let curr = offset;\n      while (--curr >= 0 && str[curr] === '\\\\') escaped = !escaped;\n      if (escaped) {\n        // odd number of slashes means | is escaped\n        // so we leave it alone\n        return '|';\n      } else {\n        // add space before unescaped |\n        return ' |';\n      }\n    }),\n    cells = row.split(other.splitPipe);\n  let i = 0;\n\n  // First/last cell in a row cannot be empty if it has no leading/trailing pipe\n  if (!cells[0].trim()) {\n    cells.shift();\n  }\n  if (cells.length > 0 && !cells.at(-1)?.trim()) {\n    cells.pop();\n  }\n\n  if (count) {\n    if (cells.length > count) {\n      cells.splice(count);\n    } else {\n      while (cells.length < count) cells.push('');\n    }\n  }\n\n  for (; i < cells.length; i++) {\n    // leading or trailing whitespace is ignored per the gfm spec\n    cells[i] = cells[i].trim().replace(other.slashPipe, '|');\n  }\n  return cells;\n}\n\n/**\n * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').\n * /c*$/ is vulnerable to REDOS.\n *\n * @param str\n * @param c\n * @param invert Remove suffix of non-c chars instead. Default falsey.\n */\nexport function rtrim(str: string, c: string, invert?: boolean) {\n  const l = str.length;\n  if (l === 0) {\n    return '';\n  }\n\n  // Length of suffix matching the invert condition.\n  let suffLen = 0;\n\n  // Step left until we fail to match the invert condition.\n  while (suffLen < l) {\n    const currChar = str.charAt(l - suffLen - 1);\n    if (currChar === c && !invert) {\n      suffLen++;\n    } else if (currChar !== c && invert) {\n      suffLen++;\n    } else {\n      break;\n    }\n  }\n\n  return str.slice(0, l - suffLen);\n}\n\nexport function findClosingBracket(str: string, b: string) {\n  if (str.indexOf(b[1]) === -1) {\n    return -1;\n  }\n\n  let level = 0;\n  for (let i = 0; i < str.length; i++) {\n    if (str[i] === '\\\\') {\n      i++;\n    } else if (str[i] === b[0]) {\n      level++;\n    } else if (str[i] === b[1]) {\n      level--;\n      if (level < 0) {\n        return i;\n      }\n    }\n  }\n  if (level > 0) {\n    return -2;\n  }\n\n  return -1;\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  rtrim,\n  splitCells,\n  findClosingBracket,\n} from './helpers.ts';\nimport type { Rules } from './rules.ts';\nimport type { _Lexer } from './Lexer.ts';\nimport type { Links, Tokens, Token } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\nfunction outputLink(cap: string[], link: Pick<Tokens.Link, 'href' | 'title'>, raw: string, lexer: _Lexer, rules: Rules): Tokens.Link | Tokens.Image {\n  const href = link.href;\n  const title = link.title || null;\n  const text = cap[1].replace(rules.other.outputLinkReplace, '$1');\n\n  lexer.state.inLink = true;\n  const token: Tokens.Link | Tokens.Image = {\n    type: cap[0].charAt(0) === '!' ? 'image' : 'link',\n    raw,\n    href,\n    title,\n    text,\n    tokens: lexer.inlineTokens(text),\n  };\n  lexer.state.inLink = false;\n  return token;\n}\n\nfunction indentCodeCompensation(raw: string, text: string, rules: Rules) {\n  const matchIndentToCode = raw.match(rules.other.indentCodeCompensation);\n\n  if (matchIndentToCode === null) {\n    return text;\n  }\n\n  const indentToCode = matchIndentToCode[1];\n\n  return text\n    .split('\\n')\n    .map(node => {\n      const matchIndentInNode = node.match(rules.other.beginningSpace);\n      if (matchIndentInNode === null) {\n        return node;\n      }\n\n      const [indentInNode] = matchIndentInNode;\n\n      if (indentInNode.length >= indentToCode.length) {\n        return node.slice(indentToCode.length);\n      }\n\n      return node;\n    })\n    .join('\\n');\n}\n\n/**\n * Tokenizer\n */\nexport class _Tokenizer {\n  options: MarkedOptions;\n  rules!: Rules; // set by the lexer\n  lexer!: _Lexer; // set by the lexer\n\n  constructor(options?: MarkedOptions) {\n    this.options = options || _defaults;\n  }\n\n  space(src: string): Tokens.Space | undefined {\n    const cap = this.rules.block.newline.exec(src);\n    if (cap && cap[0].length > 0) {\n      return {\n        type: 'space',\n        raw: cap[0],\n      };\n    }\n  }\n\n  code(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.code.exec(src);\n    if (cap) {\n      const text = cap[0].replace(this.rules.other.codeRemoveIndent, '');\n      return {\n        type: 'code',\n        raw: cap[0],\n        codeBlockStyle: 'indented',\n        text: !this.options.pedantic\n          ? rtrim(text, '\\n')\n          : text,\n      };\n    }\n  }\n\n  fences(src: string): Tokens.Code | undefined {\n    const cap = this.rules.block.fences.exec(src);\n    if (cap) {\n      const raw = cap[0];\n      const text = indentCodeCompensation(raw, cap[3] || '', this.rules);\n\n      return {\n        type: 'code',\n        raw,\n        lang: cap[2] ? cap[2].trim().replace(this.rules.inline.anyPunctuation, '$1') : cap[2],\n        text,\n      };\n    }\n  }\n\n  heading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.heading.exec(src);\n    if (cap) {\n      let text = cap[2].trim();\n\n      // remove trailing #s\n      if (this.rules.other.endingHash.test(text)) {\n        const trimmed = rtrim(text, '#');\n        if (this.options.pedantic) {\n          text = trimmed.trim();\n        } else if (!trimmed || this.rules.other.endingSpaceChar.test(trimmed)) {\n          // CommonMark requires space before trailing #s\n          text = trimmed.trim();\n        }\n      }\n\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[1].length,\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  hr(src: string): Tokens.Hr | undefined {\n    const cap = this.rules.block.hr.exec(src);\n    if (cap) {\n      return {\n        type: 'hr',\n        raw: rtrim(cap[0], '\\n'),\n      };\n    }\n  }\n\n  blockquote(src: string): Tokens.Blockquote | undefined {\n    const cap = this.rules.block.blockquote.exec(src);\n    if (cap) {\n      let lines = rtrim(cap[0], '\\n').split('\\n');\n      let raw = '';\n      let text = '';\n      const tokens: Token[] = [];\n\n      while (lines.length > 0) {\n        let inBlockquote = false;\n        const currentLines = [];\n\n        let i;\n        for (i = 0; i < lines.length; i++) {\n          // get lines up to a continuation\n          if (this.rules.other.blockquoteStart.test(lines[i])) {\n            currentLines.push(lines[i]);\n            inBlockquote = true;\n          } else if (!inBlockquote) {\n            currentLines.push(lines[i]);\n          } else {\n            break;\n          }\n        }\n        lines = lines.slice(i);\n\n        const currentRaw = currentLines.join('\\n');\n        const currentText = currentRaw\n          // precede setext continuation with 4 spaces so it isn't a setext\n          .replace(this.rules.other.blockquoteSetextReplace, '\\n    $1')\n          .replace(this.rules.other.blockquoteSetextReplace2, '');\n        raw = raw ? `${raw}\\n${currentRaw}` : currentRaw;\n        text = text ? `${text}\\n${currentText}` : currentText;\n\n        // parse blockquote lines as top level tokens\n        // merge paragraphs if this is a continuation\n        const top = this.lexer.state.top;\n        this.lexer.state.top = true;\n        this.lexer.blockTokens(currentText, tokens, true);\n        this.lexer.state.top = top;\n\n        // if there is no continuation then we are done\n        if (lines.length === 0) {\n          break;\n        }\n\n        const lastToken = tokens.at(-1);\n\n        if (lastToken?.type === 'code') {\n          // blockquote continuation cannot be preceded by a code block\n          break;\n        } else if (lastToken?.type === 'blockquote') {\n          // include continuation in nested blockquote\n          const oldToken = lastToken as Tokens.Blockquote;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.blockquote(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - oldToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.text.length) + newToken.text;\n          break;\n        } else if (lastToken?.type === 'list') {\n          // include continuation in nested list\n          const oldToken = lastToken as Tokens.List;\n          const newText = oldToken.raw + '\\n' + lines.join('\\n');\n          const newToken = this.list(newText)!;\n          tokens[tokens.length - 1] = newToken;\n\n          raw = raw.substring(0, raw.length - lastToken.raw.length) + newToken.raw;\n          text = text.substring(0, text.length - oldToken.raw.length) + newToken.raw;\n          lines = newText.substring(tokens.at(-1)!.raw.length).split('\\n');\n          continue;\n        }\n      }\n\n      return {\n        type: 'blockquote',\n        raw,\n        tokens,\n        text,\n      };\n    }\n  }\n\n  list(src: string): Tokens.List | undefined {\n    let cap = this.rules.block.list.exec(src);\n    if (cap) {\n      let bull = cap[1].trim();\n      const isordered = bull.length > 1;\n\n      const list: Tokens.List = {\n        type: 'list',\n        raw: '',\n        ordered: isordered,\n        start: isordered ? +bull.slice(0, -1) : '',\n        loose: false,\n        items: [],\n      };\n\n      bull = isordered ? `\\\\d{1,9}\\\\${bull.slice(-1)}` : `\\\\${bull}`;\n\n      if (this.options.pedantic) {\n        bull = isordered ? bull : '[*+-]';\n      }\n\n      // Get next list item\n      const itemRegex = this.rules.other.listItemRegex(bull);\n      let endsWithBlankLine = false;\n      // Check if current bullet point can start a new List Item\n      while (src) {\n        let endEarly = false;\n        let raw = '';\n        let itemContents = '';\n        if (!(cap = itemRegex.exec(src))) {\n          break;\n        }\n\n        if (this.rules.block.hr.test(src)) { // End list if bullet was actually HR (possibly move into itemRegex?)\n          break;\n        }\n\n        raw = cap[0];\n        src = src.substring(raw.length);\n\n        let line = cap[2].split('\\n', 1)[0].replace(this.rules.other.listReplaceTabs, (t: string) => ' '.repeat(3 * t.length));\n        let nextLine = src.split('\\n', 1)[0];\n        let blankLine = !line.trim();\n\n        let indent = 0;\n        if (this.options.pedantic) {\n          indent = 2;\n          itemContents = line.trimStart();\n        } else if (blankLine) {\n          indent = cap[1].length + 1;\n        } else {\n          indent = cap[2].search(this.rules.other.nonSpaceChar); // Find first non-space char\n          indent = indent > 4 ? 1 : indent; // Treat indented code blocks (> 4 spaces) as having only 1 indent\n          itemContents = line.slice(indent);\n          indent += cap[1].length;\n        }\n\n        if (blankLine && this.rules.other.blankLine.test(nextLine)) { // Items begin with at most one blank line\n          raw += nextLine + '\\n';\n          src = src.substring(nextLine.length + 1);\n          endEarly = true;\n        }\n\n        if (!endEarly) {\n          const nextBulletRegex = this.rules.other.nextBulletRegex(indent);\n          const hrRegex = this.rules.other.hrRegex(indent);\n          const fencesBeginRegex = this.rules.other.fencesBeginRegex(indent);\n          const headingBeginRegex = this.rules.other.headingBeginRegex(indent);\n          const htmlBeginRegex = this.rules.other.htmlBeginRegex(indent);\n\n          // Check if following lines should be included in List Item\n          while (src) {\n            const rawLine = src.split('\\n', 1)[0];\n            let nextLineWithoutTabs;\n            nextLine = rawLine;\n\n            // Re-align to follow commonmark nesting rules\n            if (this.options.pedantic) {\n              nextLine = nextLine.replace(this.rules.other.listReplaceNesting, '  ');\n              nextLineWithoutTabs = nextLine;\n            } else {\n              nextLineWithoutTabs = nextLine.replace(this.rules.other.tabCharGlobal, '    ');\n            }\n\n            // End list item if found code fences\n            if (fencesBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new heading\n            if (headingBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of html block\n            if (htmlBeginRegex.test(nextLine)) {\n              break;\n            }\n\n            // End list item if found start of new bullet\n            if (nextBulletRegex.test(nextLine)) {\n              break;\n            }\n\n            // Horizontal rule found\n            if (hrRegex.test(nextLine)) {\n              break;\n            }\n\n            if (nextLineWithoutTabs.search(this.rules.other.nonSpaceChar) >= indent || !nextLine.trim()) { // Dedent if possible\n              itemContents += '\\n' + nextLineWithoutTabs.slice(indent);\n            } else {\n              // not enough indentation\n              if (blankLine) {\n                break;\n              }\n\n              // paragraph continuation unless last line was a different block level element\n              if (line.replace(this.rules.other.tabCharGlobal, '    ').search(this.rules.other.nonSpaceChar) >= 4) { // indented code block\n                break;\n              }\n              if (fencesBeginRegex.test(line)) {\n                break;\n              }\n              if (headingBeginRegex.test(line)) {\n                break;\n              }\n              if (hrRegex.test(line)) {\n                break;\n              }\n\n              itemContents += '\\n' + nextLine;\n            }\n\n            if (!blankLine && !nextLine.trim()) { // Check if current line is blank\n              blankLine = true;\n            }\n\n            raw += rawLine + '\\n';\n            src = src.substring(rawLine.length + 1);\n            line = nextLineWithoutTabs.slice(indent);\n          }\n        }\n\n        if (!list.loose) {\n          // If the previous item ended with a blank line, the list is loose\n          if (endsWithBlankLine) {\n            list.loose = true;\n          } else if (this.rules.other.doubleBlankLine.test(raw)) {\n            endsWithBlankLine = true;\n          }\n        }\n\n        let istask: RegExpExecArray | null = null;\n        let ischecked: boolean | undefined;\n        // Check for task list items\n        if (this.options.gfm) {\n          istask = this.rules.other.listIsTask.exec(itemContents);\n          if (istask) {\n            ischecked = istask[0] !== '[ ] ';\n            itemContents = itemContents.replace(this.rules.other.listReplaceTask, '');\n          }\n        }\n\n        list.items.push({\n          type: 'list_item',\n          raw,\n          task: !!istask,\n          checked: ischecked,\n          loose: false,\n          text: itemContents,\n          tokens: [],\n        });\n\n        list.raw += raw;\n      }\n\n      // Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic\n      const lastItem = list.items.at(-1);\n      if (lastItem) {\n        lastItem.raw = lastItem.raw.trimEnd();\n        lastItem.text = lastItem.text.trimEnd();\n      } else {\n        // not a list since there were no items\n        return;\n      }\n      list.raw = list.raw.trimEnd();\n\n      // Item child tokens handled here at end because we needed to have the final item to trim it first\n      for (let i = 0; i < list.items.length; i++) {\n        this.lexer.state.top = false;\n        list.items[i].tokens = this.lexer.blockTokens(list.items[i].text, []);\n\n        if (!list.loose) {\n          // Check if list should be loose\n          const spacers = list.items[i].tokens.filter(t => t.type === 'space');\n          const hasMultipleLineBreaks = spacers.length > 0 && spacers.some(t => this.rules.other.anyLine.test(t.raw));\n\n          list.loose = hasMultipleLineBreaks;\n        }\n      }\n\n      // Set all items to loose if list is loose\n      if (list.loose) {\n        for (let i = 0; i < list.items.length; i++) {\n          list.items[i].loose = true;\n        }\n      }\n\n      return list;\n    }\n  }\n\n  html(src: string): Tokens.HTML | undefined {\n    const cap = this.rules.block.html.exec(src);\n    if (cap) {\n      const token: Tokens.HTML = {\n        type: 'html',\n        block: true,\n        raw: cap[0],\n        pre: cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style',\n        text: cap[0],\n      };\n      return token;\n    }\n  }\n\n  def(src: string): Tokens.Def | undefined {\n    const cap = this.rules.block.def.exec(src);\n    if (cap) {\n      const tag = cap[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const href = cap[2] ? cap[2].replace(this.rules.other.hrefBrackets, '$1').replace(this.rules.inline.anyPunctuation, '$1') : '';\n      const title = cap[3] ? cap[3].substring(1, cap[3].length - 1).replace(this.rules.inline.anyPunctuation, '$1') : cap[3];\n      return {\n        type: 'def',\n        tag,\n        raw: cap[0],\n        href,\n        title,\n      };\n    }\n  }\n\n  table(src: string): Tokens.Table | undefined {\n    const cap = this.rules.block.table.exec(src);\n    if (!cap) {\n      return;\n    }\n\n    if (!this.rules.other.tableDelimiter.test(cap[2])) {\n      // delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading\n      return;\n    }\n\n    const headers = splitCells(cap[1]);\n    const aligns = cap[2].replace(this.rules.other.tableAlignChars, '').split('|');\n    const rows = cap[3]?.trim() ? cap[3].replace(this.rules.other.tableRowBlankLine, '').split('\\n') : [];\n\n    const item: Tokens.Table = {\n      type: 'table',\n      raw: cap[0],\n      header: [],\n      align: [],\n      rows: [],\n    };\n\n    if (headers.length !== aligns.length) {\n      // header and align columns must be equal, rows can be different.\n      return;\n    }\n\n    for (const align of aligns) {\n      if (this.rules.other.tableAlignRight.test(align)) {\n        item.align.push('right');\n      } else if (this.rules.other.tableAlignCenter.test(align)) {\n        item.align.push('center');\n      } else if (this.rules.other.tableAlignLeft.test(align)) {\n        item.align.push('left');\n      } else {\n        item.align.push(null);\n      }\n    }\n\n    for (let i = 0; i < headers.length; i++) {\n      item.header.push({\n        text: headers[i],\n        tokens: this.lexer.inline(headers[i]),\n        header: true,\n        align: item.align[i],\n      });\n    }\n\n    for (const row of rows) {\n      item.rows.push(splitCells(row, item.header.length).map((cell, i) => {\n        return {\n          text: cell,\n          tokens: this.lexer.inline(cell),\n          header: false,\n          align: item.align[i],\n        };\n      }));\n    }\n\n    return item;\n  }\n\n  lheading(src: string): Tokens.Heading | undefined {\n    const cap = this.rules.block.lheading.exec(src);\n    if (cap) {\n      return {\n        type: 'heading',\n        raw: cap[0],\n        depth: cap[2].charAt(0) === '=' ? 1 : 2,\n        text: cap[1],\n        tokens: this.lexer.inline(cap[1]),\n      };\n    }\n  }\n\n  paragraph(src: string): Tokens.Paragraph | undefined {\n    const cap = this.rules.block.paragraph.exec(src);\n    if (cap) {\n      const text = cap[1].charAt(cap[1].length - 1) === '\\n'\n        ? cap[1].slice(0, -1)\n        : cap[1];\n      return {\n        type: 'paragraph',\n        raw: cap[0],\n        text,\n        tokens: this.lexer.inline(text),\n      };\n    }\n  }\n\n  text(src: string): Tokens.Text | undefined {\n    const cap = this.rules.block.text.exec(src);\n    if (cap) {\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        tokens: this.lexer.inline(cap[0]),\n      };\n    }\n  }\n\n  escape(src: string): Tokens.Escape | undefined {\n    const cap = this.rules.inline.escape.exec(src);\n    if (cap) {\n      return {\n        type: 'escape',\n        raw: cap[0],\n        text: cap[1],\n      };\n    }\n  }\n\n  tag(src: string): Tokens.Tag | undefined {\n    const cap = this.rules.inline.tag.exec(src);\n    if (cap) {\n      if (!this.lexer.state.inLink && this.rules.other.startATag.test(cap[0])) {\n        this.lexer.state.inLink = true;\n      } else if (this.lexer.state.inLink && this.rules.other.endATag.test(cap[0])) {\n        this.lexer.state.inLink = false;\n      }\n      if (!this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = true;\n      } else if (this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(cap[0])) {\n        this.lexer.state.inRawBlock = false;\n      }\n\n      return {\n        type: 'html',\n        raw: cap[0],\n        inLink: this.lexer.state.inLink,\n        inRawBlock: this.lexer.state.inRawBlock,\n        block: false,\n        text: cap[0],\n      };\n    }\n  }\n\n  link(src: string): Tokens.Link | Tokens.Image | undefined {\n    const cap = this.rules.inline.link.exec(src);\n    if (cap) {\n      const trimmedUrl = cap[2].trim();\n      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(trimmedUrl)) {\n        // commonmark requires matching angle brackets\n        if (!(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          return;\n        }\n\n        // ending angle bracket cannot be escaped\n        const rtrimSlash = rtrim(trimmedUrl.slice(0, -1), '\\\\');\n        if ((trimmedUrl.length - rtrimSlash.length) % 2 === 0) {\n          return;\n        }\n      } else {\n        // find closing parenthesis\n        const lastParenIndex = findClosingBracket(cap[2], '()');\n        if (lastParenIndex === -2) {\n          // more open parens than closed\n          return;\n        }\n\n        if (lastParenIndex > -1) {\n          const start = cap[0].indexOf('!') === 0 ? 5 : 4;\n          const linkLen = start + cap[1].length + lastParenIndex;\n          cap[2] = cap[2].substring(0, lastParenIndex);\n          cap[0] = cap[0].substring(0, linkLen).trim();\n          cap[3] = '';\n        }\n      }\n      let href = cap[2];\n      let title = '';\n      if (this.options.pedantic) {\n        // split pedantic href and title\n        const link = this.rules.other.pedanticHrefTitle.exec(href);\n\n        if (link) {\n          href = link[1];\n          title = link[3];\n        }\n      } else {\n        title = cap[3] ? cap[3].slice(1, -1) : '';\n      }\n\n      href = href.trim();\n      if (this.rules.other.startAngleBracket.test(href)) {\n        if (this.options.pedantic && !(this.rules.other.endAngleBracket.test(trimmedUrl))) {\n          // pedantic allows starting angle bracket without ending angle bracket\n          href = href.slice(1);\n        } else {\n          href = href.slice(1, -1);\n        }\n      }\n      return outputLink(cap, {\n        href: href ? href.replace(this.rules.inline.anyPunctuation, '$1') : href,\n        title: title ? title.replace(this.rules.inline.anyPunctuation, '$1') : title,\n      }, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  reflink(src: string, links: Links): Tokens.Link | Tokens.Image | Tokens.Text | undefined {\n    let cap;\n    if ((cap = this.rules.inline.reflink.exec(src))\n      || (cap = this.rules.inline.nolink.exec(src))) {\n      const linkString = (cap[2] || cap[1]).replace(this.rules.other.multipleSpaceGlobal, ' ');\n      const link = links[linkString.toLowerCase()];\n      if (!link) {\n        const text = cap[0].charAt(0);\n        return {\n          type: 'text',\n          raw: text,\n          text,\n        };\n      }\n      return outputLink(cap, link, cap[0], this.lexer, this.rules);\n    }\n  }\n\n  emStrong(src: string, maskedSrc: string, prevChar = ''): Tokens.Em | Tokens.Strong | undefined {\n    let match = this.rules.inline.emStrongLDelim.exec(src);\n    if (!match) return;\n\n    // _ can't be between two alphanumerics. \\p{L}\\p{N} includes non-english alphabet/numbers as well\n    if (match[3] && prevChar.match(this.rules.other.unicodeAlphaNumeric)) return;\n\n    const nextChar = match[1] || match[2] || '';\n\n    if (!nextChar || !prevChar || this.rules.inline.punctuation.exec(prevChar)) {\n      // unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)\n      const lLength = [...match[0]].length - 1;\n      let rDelim, rLength, delimTotal = lLength, midDelimTotal = 0;\n\n      const endReg = match[0][0] === '*' ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;\n      endReg.lastIndex = 0;\n\n      // Clip maskedSrc to same section of string as src (move to lexer?)\n      maskedSrc = maskedSrc.slice(-1 * src.length + lLength);\n\n      while ((match = endReg.exec(maskedSrc)) != null) {\n        rDelim = match[1] || match[2] || match[3] || match[4] || match[5] || match[6];\n\n        if (!rDelim) continue; // skip single * in __abc*abc__\n\n        rLength = [...rDelim].length;\n\n        if (match[3] || match[4]) { // found another Left Delim\n          delimTotal += rLength;\n          continue;\n        } else if (match[5] || match[6]) { // either Left or Right Delim\n          if (lLength % 3 && !((lLength + rLength) % 3)) {\n            midDelimTotal += rLength;\n            continue; // CommonMark Emphasis Rules 9-10\n          }\n        }\n\n        delimTotal -= rLength;\n\n        if (delimTotal > 0) continue; // Haven't found enough closing delimiters\n\n        // Remove extra characters. *a*** -> *a*\n        rLength = Math.min(rLength, rLength + delimTotal + midDelimTotal);\n        // char length can be >1 for unicode characters;\n        const lastCharLength = [...match[0]][0].length;\n        const raw = src.slice(0, lLength + match.index + lastCharLength + rLength);\n\n        // Create `em` if smallest delimiter has odd char count. *a***\n        if (Math.min(lLength, rLength) % 2) {\n          const text = raw.slice(1, -1);\n          return {\n            type: 'em',\n            raw,\n            text,\n            tokens: this.lexer.inlineTokens(text),\n          };\n        }\n\n        // Create 'strong' if smallest delimiter has even char count. **a***\n        const text = raw.slice(2, -2);\n        return {\n          type: 'strong',\n          raw,\n          text,\n          tokens: this.lexer.inlineTokens(text),\n        };\n      }\n    }\n  }\n\n  codespan(src: string): Tokens.Codespan | undefined {\n    const cap = this.rules.inline.code.exec(src);\n    if (cap) {\n      let text = cap[2].replace(this.rules.other.newLineCharGlobal, ' ');\n      const hasNonSpaceChars = this.rules.other.nonSpaceChar.test(text);\n      const hasSpaceCharsOnBothEnds = this.rules.other.startingSpaceChar.test(text) && this.rules.other.endingSpaceChar.test(text);\n      if (hasNonSpaceChars && hasSpaceCharsOnBothEnds) {\n        text = text.substring(1, text.length - 1);\n      }\n      return {\n        type: 'codespan',\n        raw: cap[0],\n        text,\n      };\n    }\n  }\n\n  br(src: string): Tokens.Br | undefined {\n    const cap = this.rules.inline.br.exec(src);\n    if (cap) {\n      return {\n        type: 'br',\n        raw: cap[0],\n      };\n    }\n  }\n\n  del(src: string): Tokens.Del | undefined {\n    const cap = this.rules.inline.del.exec(src);\n    if (cap) {\n      return {\n        type: 'del',\n        raw: cap[0],\n        text: cap[2],\n        tokens: this.lexer.inlineTokens(cap[2]),\n      };\n    }\n  }\n\n  autolink(src: string): Tokens.Link | undefined {\n    const cap = this.rules.inline.autolink.exec(src);\n    if (cap) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[1];\n        href = 'mailto:' + text;\n      } else {\n        text = cap[1];\n        href = text;\n      }\n\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  url(src: string): Tokens.Link | undefined {\n    let cap;\n    if (cap = this.rules.inline.url.exec(src)) {\n      let text, href;\n      if (cap[2] === '@') {\n        text = cap[0];\n        href = 'mailto:' + text;\n      } else {\n        // do extended autolink path validation\n        let prevCapZero;\n        do {\n          prevCapZero = cap[0];\n          cap[0] = this.rules.inline._backpedal.exec(cap[0])?.[0] ?? '';\n        } while (prevCapZero !== cap[0]);\n        text = cap[0];\n        if (cap[1] === 'www.') {\n          href = 'http://' + cap[0];\n        } else {\n          href = cap[0];\n        }\n      }\n      return {\n        type: 'link',\n        raw: cap[0],\n        text,\n        href,\n        tokens: [\n          {\n            type: 'text',\n            raw: text,\n            text,\n          },\n        ],\n      };\n    }\n  }\n\n  inlineText(src: string): Tokens.Text | undefined {\n    const cap = this.rules.inline.text.exec(src);\n    if (cap) {\n      const escaped = this.lexer.state.inRawBlock;\n      return {\n        type: 'text',\n        raw: cap[0],\n        text: cap[0],\n        escaped,\n      };\n    }\n  }\n}\n","import { _Tokenizer } from './Tokenizer.ts';\nimport { _defaults } from './defaults.ts';\nimport { other, block, inline } from './rules.ts';\nimport type { Token, TokensList, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Block Lexer\n */\nexport class _Lexer {\n  tokens: TokensList;\n  options: MarkedOptions;\n  state: {\n    inLink: boolean;\n    inRawBlock: boolean;\n    top: boolean;\n  };\n\n  private tokenizer: _Tokenizer;\n  private inlineQueue: { src: string, tokens: Token[] }[];\n\n  constructor(options?: MarkedOptions) {\n    // TokenList cannot be created in one go\n    this.tokens = [] as unknown as TokensList;\n    this.tokens.links = Object.create(null);\n    this.options = options || _defaults;\n    this.options.tokenizer = this.options.tokenizer || new _Tokenizer();\n    this.tokenizer = this.options.tokenizer;\n    this.tokenizer.options = this.options;\n    this.tokenizer.lexer = this;\n    this.inlineQueue = [];\n    this.state = {\n      inLink: false,\n      inRawBlock: false,\n      top: true,\n    };\n\n    const rules = {\n      other,\n      block: block.normal,\n      inline: inline.normal,\n    };\n\n    if (this.options.pedantic) {\n      rules.block = block.pedantic;\n      rules.inline = inline.pedantic;\n    } else if (this.options.gfm) {\n      rules.block = block.gfm;\n      if (this.options.breaks) {\n        rules.inline = inline.breaks;\n      } else {\n        rules.inline = inline.gfm;\n      }\n    }\n    this.tokenizer.rules = rules;\n  }\n\n  /**\n   * Expose Rules\n   */\n  static get rules() {\n    return {\n      block,\n      inline,\n    };\n  }\n\n  /**\n   * Static Lex Method\n   */\n  static lex(src: string, options?: MarkedOptions) {\n    const lexer = new _Lexer(options);\n    return lexer.lex(src);\n  }\n\n  /**\n   * Static Lex Inline Method\n   */\n  static lexInline(src: string, options?: MarkedOptions) {\n    const lexer = new _Lexer(options);\n    return lexer.inlineTokens(src);\n  }\n\n  /**\n   * Preprocessing\n   */\n  lex(src: string) {\n    src = src.replace(other.carriageReturn, '\\n');\n\n    this.blockTokens(src, this.tokens);\n\n    for (let i = 0; i < this.inlineQueue.length; i++) {\n      const next = this.inlineQueue[i];\n      this.inlineTokens(next.src, next.tokens);\n    }\n    this.inlineQueue = [];\n\n    return this.tokens;\n  }\n\n  /**\n   * Lexing\n   */\n  blockTokens(src: string, tokens?: Token[], lastParagraphClipped?: boolean): Token[];\n  blockTokens(src: string, tokens?: TokensList, lastParagraphClipped?: boolean): TokensList;\n  blockTokens(src: string, tokens: Token[] = [], lastParagraphClipped = false) {\n    if (this.options.pedantic) {\n      src = src.replace(other.tabCharGlobal, '    ').replace(other.spaceLine, '');\n    }\n\n    while (src) {\n      let token: Tokens.Generic | undefined;\n\n      if (this.options.extensions?.block?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // newline\n      if (token = this.tokenizer.space(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.raw.length === 1 && lastToken !== undefined) {\n          // if there's a single \\n as a spacer, it's terminating the last line,\n          // so move it there so that we don't get unnecessary paragraph tags\n          lastToken.raw += '\\n';\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.code(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        // An indented code block cannot interrupt a paragraph.\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // fences\n      if (token = this.tokenizer.fences(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // heading\n      if (token = this.tokenizer.heading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // hr\n      if (token = this.tokenizer.hr(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // blockquote\n      if (token = this.tokenizer.blockquote(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // list\n      if (token = this.tokenizer.list(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // html\n      if (token = this.tokenizer.html(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // def\n      if (token = this.tokenizer.def(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'paragraph' || lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.raw;\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else if (!this.tokens.links[token.tag]) {\n          this.tokens.links[token.tag] = {\n            href: token.href,\n            title: token.title,\n          };\n        }\n        continue;\n      }\n\n      // table (gfm)\n      if (token = this.tokenizer.table(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // lheading\n      if (token = this.tokenizer.lheading(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // top-level paragraph\n      // prevent paragraph consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startBlock) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startBlock.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (this.state.top && (token = this.tokenizer.paragraph(cutSrc))) {\n        const lastToken = tokens.at(-1);\n        if (lastParagraphClipped && lastToken?.type === 'paragraph') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        lastParagraphClipped = cutSrc.length !== src.length;\n        src = src.substring(token.raw.length);\n        continue;\n      }\n\n      // text\n      if (token = this.tokenizer.text(src)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += '\\n' + token.raw;\n          lastToken.text += '\\n' + token.text;\n          this.inlineQueue.pop();\n          this.inlineQueue.at(-1)!.src = lastToken.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    this.state.top = true;\n    return tokens;\n  }\n\n  inline(src: string, tokens: Token[] = []) {\n    this.inlineQueue.push({ src, tokens });\n    return tokens;\n  }\n\n  /**\n   * Lexing/Compiling\n   */\n  inlineTokens(src: string, tokens: Token[] = []): Token[] {\n    // String with links masked to avoid interference with em and strong\n    let maskedSrc = src;\n    let match: RegExpExecArray | null = null;\n\n    // Mask out reflinks\n    if (this.tokens.links) {\n      const links = Object.keys(this.tokens.links);\n      if (links.length > 0) {\n        while ((match = this.tokenizer.rules.inline.reflinkSearch.exec(maskedSrc)) != null) {\n          if (links.includes(match[0].slice(match[0].lastIndexOf('[') + 1, -1))) {\n            maskedSrc = maskedSrc.slice(0, match.index)\n              + '[' + 'a'.repeat(match[0].length - 2) + ']'\n              + maskedSrc.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex);\n          }\n        }\n      }\n    }\n\n    // Mask out escaped characters\n    while ((match = this.tokenizer.rules.inline.anyPunctuation.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '++' + maskedSrc.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);\n    }\n\n    // Mask out other blocks\n    while ((match = this.tokenizer.rules.inline.blockSkip.exec(maskedSrc)) != null) {\n      maskedSrc = maskedSrc.slice(0, match.index) + '[' + 'a'.repeat(match[0].length - 2) + ']' + maskedSrc.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);\n    }\n\n    let keepPrevChar = false;\n    let prevChar = '';\n    while (src) {\n      if (!keepPrevChar) {\n        prevChar = '';\n      }\n      keepPrevChar = false;\n\n      let token: Tokens.Generic | undefined;\n\n      // extensions\n      if (this.options.extensions?.inline?.some((extTokenizer) => {\n        if (token = extTokenizer.call({ lexer: this }, src, tokens)) {\n          src = src.substring(token.raw.length);\n          tokens.push(token);\n          return true;\n        }\n        return false;\n      })) {\n        continue;\n      }\n\n      // escape\n      if (token = this.tokenizer.escape(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // tag\n      if (token = this.tokenizer.tag(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // link\n      if (token = this.tokenizer.link(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // reflink, nolink\n      if (token = this.tokenizer.reflink(src, this.tokens.links)) {\n        src = src.substring(token.raw.length);\n        const lastToken = tokens.at(-1);\n        if (token.type === 'text' && lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      // em & strong\n      if (token = this.tokenizer.emStrong(src, maskedSrc, prevChar)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // code\n      if (token = this.tokenizer.codespan(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // br\n      if (token = this.tokenizer.br(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // del (gfm)\n      if (token = this.tokenizer.del(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // autolink\n      if (token = this.tokenizer.autolink(src)) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // url (gfm)\n      if (!this.state.inLink && (token = this.tokenizer.url(src))) {\n        src = src.substring(token.raw.length);\n        tokens.push(token);\n        continue;\n      }\n\n      // text\n      // prevent inlineText consuming extensions by clipping 'src' to extension start\n      let cutSrc = src;\n      if (this.options.extensions?.startInline) {\n        let startIndex = Infinity;\n        const tempSrc = src.slice(1);\n        let tempStart;\n        this.options.extensions.startInline.forEach((getStartIndex) => {\n          tempStart = getStartIndex.call({ lexer: this }, tempSrc);\n          if (typeof tempStart === 'number' && tempStart >= 0) {\n            startIndex = Math.min(startIndex, tempStart);\n          }\n        });\n        if (startIndex < Infinity && startIndex >= 0) {\n          cutSrc = src.substring(0, startIndex + 1);\n        }\n      }\n      if (token = this.tokenizer.inlineText(cutSrc)) {\n        src = src.substring(token.raw.length);\n        if (token.raw.slice(-1) !== '_') { // Track prevChar before string of ____ started\n          prevChar = token.raw.slice(-1);\n        }\n        keepPrevChar = true;\n        const lastToken = tokens.at(-1);\n        if (lastToken?.type === 'text') {\n          lastToken.raw += token.raw;\n          lastToken.text += token.text;\n        } else {\n          tokens.push(token);\n        }\n        continue;\n      }\n\n      if (src) {\n        const errMsg = 'Infinite loop on byte: ' + src.charCodeAt(0);\n        if (this.options.silent) {\n          console.error(errMsg);\n          break;\n        } else {\n          throw new Error(errMsg);\n        }\n      }\n    }\n\n    return tokens;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport {\n  cleanUrl,\n  escape,\n} from './helpers.ts';\nimport { other } from './rules.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Tokens } from './Tokens.ts';\nimport type { _Parser } from './Parser.ts';\n\n/**\n * Renderer\n */\nexport class _Renderer {\n  options: MarkedOptions;\n  parser!: _Parser; // set by the parser\n  constructor(options?: MarkedOptions) {\n    this.options = options || _defaults;\n  }\n\n  space(token: Tokens.Space): string {\n    return '';\n  }\n\n  code({ text, lang, escaped }: Tokens.Code): string {\n    const langString = (lang || '').match(other.notSpaceStart)?.[0];\n\n    const code = text.replace(other.endingNewline, '') + '\\n';\n\n    if (!langString) {\n      return '<pre><code>'\n        + (escaped ? code : escape(code, true))\n        + '</code></pre>\\n';\n    }\n\n    return '<pre><code class=\"language-'\n      + escape(langString)\n      + '\">'\n      + (escaped ? code : escape(code, true))\n      + '</code></pre>\\n';\n  }\n\n  blockquote({ tokens }: Tokens.Blockquote): string {\n    const body = this.parser.parse(tokens);\n    return `<blockquote>\\n${body}</blockquote>\\n`;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag) : string {\n    return text;\n  }\n\n  heading({ tokens, depth }: Tokens.Heading): string {\n    return `<h${depth}>${this.parser.parseInline(tokens)}</h${depth}>\\n`;\n  }\n\n  hr(token: Tokens.Hr): string {\n    return '<hr>\\n';\n  }\n\n  list(token: Tokens.List): string {\n    const ordered = token.ordered;\n    const start = token.start;\n\n    let body = '';\n    for (let j = 0; j < token.items.length; j++) {\n      const item = token.items[j];\n      body += this.listitem(item);\n    }\n\n    const type = ordered ? 'ol' : 'ul';\n    const startAttr = (ordered && start !== 1) ? (' start=\"' + start + '\"') : '';\n    return '<' + type + startAttr + '>\\n' + body + '</' + type + '>\\n';\n  }\n\n  listitem(item: Tokens.ListItem): string {\n    let itemBody = '';\n    if (item.task) {\n      const checkbox = this.checkbox({ checked: !!item.checked });\n      if (item.loose) {\n        if (item.tokens[0]?.type === 'paragraph') {\n          item.tokens[0].text = checkbox + ' ' + item.tokens[0].text;\n          if (item.tokens[0].tokens && item.tokens[0].tokens.length > 0 && item.tokens[0].tokens[0].type === 'text') {\n            item.tokens[0].tokens[0].text = checkbox + ' ' + escape(item.tokens[0].tokens[0].text);\n            item.tokens[0].tokens[0].escaped = true;\n          }\n        } else {\n          item.tokens.unshift({\n            type: 'text',\n            raw: checkbox + ' ',\n            text: checkbox + ' ',\n            escaped: true,\n          });\n        }\n      } else {\n        itemBody += checkbox + ' ';\n      }\n    }\n\n    itemBody += this.parser.parse(item.tokens, !!item.loose);\n\n    return `<li>${itemBody}</li>\\n`;\n  }\n\n  checkbox({ checked }: Tokens.Checkbox): string {\n    return '<input '\n      + (checked ? 'checked=\"\" ' : '')\n      + 'disabled=\"\" type=\"checkbox\">';\n  }\n\n  paragraph({ tokens }: Tokens.Paragraph): string {\n    return `<p>${this.parser.parseInline(tokens)}</p>\\n`;\n  }\n\n  table(token: Tokens.Table): string {\n    let header = '';\n\n    // header\n    let cell = '';\n    for (let j = 0; j < token.header.length; j++) {\n      cell += this.tablecell(token.header[j]);\n    }\n    header += this.tablerow({ text: cell });\n\n    let body = '';\n    for (let j = 0; j < token.rows.length; j++) {\n      const row = token.rows[j];\n\n      cell = '';\n      for (let k = 0; k < row.length; k++) {\n        cell += this.tablecell(row[k]);\n      }\n\n      body += this.tablerow({ text: cell });\n    }\n    if (body) body = `<tbody>${body}</tbody>`;\n\n    return '<table>\\n'\n      + '<thead>\\n'\n      + header\n      + '</thead>\\n'\n      + body\n      + '</table>\\n';\n  }\n\n  tablerow({ text }: Tokens.TableRow): string {\n    return `<tr>\\n${text}</tr>\\n`;\n  }\n\n  tablecell(token: Tokens.TableCell): string {\n    const content = this.parser.parseInline(token.tokens);\n    const type = token.header ? 'th' : 'td';\n    const tag = token.align\n      ? `<${type} align=\"${token.align}\">`\n      : `<${type}>`;\n    return tag + content + `</${type}>\\n`;\n  }\n\n  /**\n   * span level renderer\n   */\n  strong({ tokens }: Tokens.Strong): string {\n    return `<strong>${this.parser.parseInline(tokens)}</strong>`;\n  }\n\n  em({ tokens }: Tokens.Em): string {\n    return `<em>${this.parser.parseInline(tokens)}</em>`;\n  }\n\n  codespan({ text }: Tokens.Codespan): string {\n    return `<code>${escape(text, true)}</code>`;\n  }\n\n  br(token: Tokens.Br): string {\n    return '<br>';\n  }\n\n  del({ tokens }: Tokens.Del): string {\n    return `<del>${this.parser.parseInline(tokens)}</del>`;\n  }\n\n  link({ href, title, tokens }: Tokens.Link): string {\n    const text = this.parser.parseInline(tokens);\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return text;\n    }\n    href = cleanHref;\n    let out = '<a href=\"' + href + '\"';\n    if (title) {\n      out += ' title=\"' + (escape(title)) + '\"';\n    }\n    out += '>' + text + '</a>';\n    return out;\n  }\n\n  image({ href, title, text, tokens }: Tokens.Image): string {\n    if (tokens) {\n      text = this.parser.parseInline(tokens, this.parser.textRenderer);\n    }\n    const cleanHref = cleanUrl(href);\n    if (cleanHref === null) {\n      return escape(text);\n    }\n    href = cleanHref;\n\n    let out = `<img src=\"${href}\" alt=\"${text}\"`;\n    if (title) {\n      out += ` title=\"${escape(title)}\"`;\n    }\n    out += '>';\n    return out;\n  }\n\n  text(token: Tokens.Text | Tokens.Escape) : string {\n    return 'tokens' in token && token.tokens\n      ? this.parser.parseInline(token.tokens)\n      : ('escaped' in token && token.escaped ? token.text : escape(token.text));\n  }\n}\n","import type { Tokens } from './Tokens.ts';\n\n/**\n * TextRenderer\n * returns only the textual part of the token\n */\nexport class _TextRenderer {\n  // no need for block level renderers\n  strong({ text }: Tokens.Strong) {\n    return text;\n  }\n\n  em({ text }: Tokens.Em) {\n    return text;\n  }\n\n  codespan({ text }: Tokens.Codespan) {\n    return text;\n  }\n\n  del({ text }: Tokens.Del) {\n    return text;\n  }\n\n  html({ text }: Tokens.HTML | Tokens.Tag) {\n    return text;\n  }\n\n  text({ text }: Tokens.Text | Tokens.Escape | Tokens.Tag) {\n    return text;\n  }\n\n  link({ text }: Tokens.Link) {\n    return '' + text;\n  }\n\n  image({ text }: Tokens.Image) {\n    return '' + text;\n  }\n\n  br() {\n    return '';\n  }\n}\n","import { _Renderer } from './Renderer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { _defaults } from './defaults.ts';\nimport type { MarkedToken, Token, Tokens } from './Tokens.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\n\n/**\n * Parsing & Compiling\n */\nexport class _Parser {\n  options: MarkedOptions;\n  renderer: _Renderer;\n  textRenderer: _TextRenderer;\n  constructor(options?: MarkedOptions) {\n    this.options = options || _defaults;\n    this.options.renderer = this.options.renderer || new _Renderer();\n    this.renderer = this.options.renderer;\n    this.renderer.options = this.options;\n    this.renderer.parser = this;\n    this.textRenderer = new _TextRenderer();\n  }\n\n  /**\n   * Static Parse Method\n   */\n  static parse(tokens: Token[], options?: MarkedOptions) {\n    const parser = new _Parser(options);\n    return parser.parse(tokens);\n  }\n\n  /**\n   * Static Parse Inline Method\n   */\n  static parseInline(tokens: Token[], options?: MarkedOptions) {\n    const parser = new _Parser(options);\n    return parser.parseInline(tokens);\n  }\n\n  /**\n   * Parse Loop\n   */\n  parse(tokens: Token[], top = true): string {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const genericToken = anyToken as Tokens.Generic;\n        const ret = this.options.extensions.renderers[genericToken.type].call({ parser: this }, genericToken);\n        if (ret !== false || !['space', 'hr', 'heading', 'code', 'table', 'blockquote', 'list', 'html', 'paragraph', 'text'].includes(genericToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'space': {\n          out += this.renderer.space(token);\n          continue;\n        }\n        case 'hr': {\n          out += this.renderer.hr(token);\n          continue;\n        }\n        case 'heading': {\n          out += this.renderer.heading(token);\n          continue;\n        }\n        case 'code': {\n          out += this.renderer.code(token);\n          continue;\n        }\n        case 'table': {\n          out += this.renderer.table(token);\n          continue;\n        }\n        case 'blockquote': {\n          out += this.renderer.blockquote(token);\n          continue;\n        }\n        case 'list': {\n          out += this.renderer.list(token);\n          continue;\n        }\n        case 'html': {\n          out += this.renderer.html(token);\n          continue;\n        }\n        case 'paragraph': {\n          out += this.renderer.paragraph(token);\n          continue;\n        }\n        case 'text': {\n          let textToken = token;\n          let body = this.renderer.text(textToken);\n          while (i + 1 < tokens.length && tokens[i + 1].type === 'text') {\n            textToken = tokens[++i] as Tokens.Text;\n            body += '\\n' + this.renderer.text(textToken);\n          }\n          if (top) {\n            out += this.renderer.paragraph({\n              type: 'paragraph',\n              raw: body,\n              text: body,\n              tokens: [{ type: 'text', raw: body, text: body, escaped: true }],\n            });\n          } else {\n            out += body;\n          }\n          continue;\n        }\n\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '';\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Parse Inline Tokens\n   */\n  parseInline(tokens: Token[], renderer: _Renderer | _TextRenderer = this.renderer): string {\n    let out = '';\n\n    for (let i = 0; i < tokens.length; i++) {\n      const anyToken = tokens[i];\n\n      // Run any renderer extensions\n      if (this.options.extensions?.renderers?.[anyToken.type]) {\n        const ret = this.options.extensions.renderers[anyToken.type].call({ parser: this }, anyToken);\n        if (ret !== false || !['escape', 'html', 'link', 'image', 'strong', 'em', 'codespan', 'br', 'del', 'text'].includes(anyToken.type)) {\n          out += ret || '';\n          continue;\n        }\n      }\n\n      const token = anyToken as MarkedToken;\n\n      switch (token.type) {\n        case 'escape': {\n          out += renderer.text(token);\n          break;\n        }\n        case 'html': {\n          out += renderer.html(token);\n          break;\n        }\n        case 'link': {\n          out += renderer.link(token);\n          break;\n        }\n        case 'image': {\n          out += renderer.image(token);\n          break;\n        }\n        case 'strong': {\n          out += renderer.strong(token);\n          break;\n        }\n        case 'em': {\n          out += renderer.em(token);\n          break;\n        }\n        case 'codespan': {\n          out += renderer.codespan(token);\n          break;\n        }\n        case 'br': {\n          out += renderer.br(token);\n          break;\n        }\n        case 'del': {\n          out += renderer.del(token);\n          break;\n        }\n        case 'text': {\n          out += renderer.text(token);\n          break;\n        }\n        default: {\n          const errMsg = 'Token with \"' + token.type + '\" type was not found.';\n          if (this.options.silent) {\n            console.error(errMsg);\n            return '';\n          } else {\n            throw new Error(errMsg);\n          }\n        }\n      }\n    }\n    return out;\n  }\n}\n","import { _defaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport type { MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, TokensList } from './Tokens.ts';\n\nexport class _Hooks {\n  options: MarkedOptions;\n  block?: boolean;\n\n  constructor(options?: MarkedOptions) {\n    this.options = options || _defaults;\n  }\n\n  static passThroughHooks = new Set([\n    'preprocess',\n    'postprocess',\n    'processAllTokens',\n  ]);\n\n  /**\n   * Process markdown before marked\n   */\n  preprocess(markdown: string) {\n    return markdown;\n  }\n\n  /**\n   * Process HTML after marked is finished\n   */\n  postprocess(html: string) {\n    return html;\n  }\n\n  /**\n   * Process all tokens before walk tokens\n   */\n  processAllTokens(tokens: Token[] | TokensList) {\n    return tokens;\n  }\n\n  /**\n   * Provide function to tokenize markdown\n   */\n  provideLexer() {\n    return this.block ? _Lexer.lex : _Lexer.lexInline;\n  }\n\n  /**\n   * Provide function to parse tokens\n   */\n  provideParser() {\n    return this.block ? _Parser.parse : _Parser.parseInline;\n  }\n}\n","import { _getDefaults } from './defaults.ts';\nimport { _Lexer } from './Lexer.ts';\nimport { _Parser } from './Parser.ts';\nimport { _Hooks } from './Hooks.ts';\nimport { _Renderer } from './Renderer.ts';\nimport { _Tokenizer } from './Tokenizer.ts';\nimport { _TextRenderer } from './TextRenderer.ts';\nimport { escape } from './helpers.ts';\nimport type { MarkedExtension, MarkedOptions } from './MarkedOptions.ts';\nimport type { Token, Tokens, TokensList } from './Tokens.ts';\n\nexport type MaybePromise = void | Promise<void>;\n\ntype UnknownFunction = (...args: unknown[]) => unknown;\ntype GenericRendererFunction = (...args: unknown[]) => string | false;\n\nexport class Marked {\n  defaults = _getDefaults();\n  options = this.setOptions;\n\n  parse = this.parseMarkdown(true);\n  parseInline = this.parseMarkdown(false);\n\n  Parser = _Parser;\n  Renderer = _Renderer;\n  TextRenderer = _TextRenderer;\n  Lexer = _Lexer;\n  Tokenizer = _Tokenizer;\n  Hooks = _Hooks;\n\n  constructor(...args: MarkedExtension[]) {\n    this.use(...args);\n  }\n\n  /**\n   * Run callback for every token\n   */\n  walkTokens(tokens: Token[] | TokensList, callback: (token: Token) => MaybePromise | MaybePromise[]) {\n    let values: MaybePromise[] = [];\n    for (const token of tokens) {\n      values = values.concat(callback.call(this, token));\n      switch (token.type) {\n        case 'table': {\n          const tableToken = token as Tokens.Table;\n          for (const cell of tableToken.header) {\n            values = values.concat(this.walkTokens(cell.tokens, callback));\n          }\n          for (const row of tableToken.rows) {\n            for (const cell of row) {\n              values = values.concat(this.walkTokens(cell.tokens, callback));\n            }\n          }\n          break;\n        }\n        case 'list': {\n          const listToken = token as Tokens.List;\n          values = values.concat(this.walkTokens(listToken.items, callback));\n          break;\n        }\n        default: {\n          const genericToken = token as Tokens.Generic;\n          if (this.defaults.extensions?.childTokens?.[genericToken.type]) {\n            this.defaults.extensions.childTokens[genericToken.type].forEach((childTokens) => {\n              const tokens = genericToken[childTokens].flat(Infinity) as Token[] | TokensList;\n              values = values.concat(this.walkTokens(tokens, callback));\n            });\n          } else if (genericToken.tokens) {\n            values = values.concat(this.walkTokens(genericToken.tokens, callback));\n          }\n        }\n      }\n    }\n    return values;\n  }\n\n  use(...args: MarkedExtension[]) {\n    const extensions: MarkedOptions['extensions'] = this.defaults.extensions || { renderers: {}, childTokens: {} };\n\n    args.forEach((pack) => {\n      // copy options to new object\n      const opts = { ...pack } as MarkedOptions;\n\n      // set async to true if it was set to true before\n      opts.async = this.defaults.async || opts.async || false;\n\n      // ==-- Parse \"addon\" extensions --== //\n      if (pack.extensions) {\n        pack.extensions.forEach((ext) => {\n          if (!ext.name) {\n            throw new Error('extension name required');\n          }\n          if ('renderer' in ext) { // Renderer extensions\n            const prevRenderer = extensions.renderers[ext.name];\n            if (prevRenderer) {\n              // Replace extension with func to run new extension but fall back if false\n              extensions.renderers[ext.name] = function(...args) {\n                let ret = ext.renderer.apply(this, args);\n                if (ret === false) {\n                  ret = prevRenderer.apply(this, args);\n                }\n                return ret;\n              };\n            } else {\n              extensions.renderers[ext.name] = ext.renderer;\n            }\n          }\n          if ('tokenizer' in ext) { // Tokenizer Extensions\n            if (!ext.level || (ext.level !== 'block' && ext.level !== 'inline')) {\n              throw new Error(\"extension level must be 'block' or 'inline'\");\n            }\n            const extLevel = extensions[ext.level];\n            if (extLevel) {\n              extLevel.unshift(ext.tokenizer);\n            } else {\n              extensions[ext.level] = [ext.tokenizer];\n            }\n            if (ext.start) { // Function to check for start of token\n              if (ext.level === 'block') {\n                if (extensions.startBlock) {\n                  extensions.startBlock.push(ext.start);\n                } else {\n                  extensions.startBlock = [ext.start];\n                }\n              } else if (ext.level === 'inline') {\n                if (extensions.startInline) {\n                  extensions.startInline.push(ext.start);\n                } else {\n                  extensions.startInline = [ext.start];\n                }\n              }\n            }\n          }\n          if ('childTokens' in ext && ext.childTokens) { // Child tokens to be visited by walkTokens\n            extensions.childTokens[ext.name] = ext.childTokens;\n          }\n        });\n        opts.extensions = extensions;\n      }\n\n      // ==-- Parse \"overwrite\" extensions --== //\n      if (pack.renderer) {\n        const renderer = this.defaults.renderer || new _Renderer(this.defaults);\n        for (const prop in pack.renderer) {\n          if (!(prop in renderer)) {\n            throw new Error(`renderer '${prop}' does not exist`);\n          }\n          if (['options', 'parser'].includes(prop)) {\n            // ignore options property\n            continue;\n          }\n          const rendererProp = prop as Exclude<keyof _Renderer, 'options' | 'parser'>;\n          const rendererFunc = pack.renderer[rendererProp] as GenericRendererFunction;\n          const prevRenderer = renderer[rendererProp] as GenericRendererFunction;\n          // Replace renderer with func to run extension, but fall back if false\n          renderer[rendererProp] = (...args: unknown[]) => {\n            let ret = rendererFunc.apply(renderer, args);\n            if (ret === false) {\n              ret = prevRenderer.apply(renderer, args);\n            }\n            return ret || '';\n          };\n        }\n        opts.renderer = renderer;\n      }\n      if (pack.tokenizer) {\n        const tokenizer = this.defaults.tokenizer || new _Tokenizer(this.defaults);\n        for (const prop in pack.tokenizer) {\n          if (!(prop in tokenizer)) {\n            throw new Error(`tokenizer '${prop}' does not exist`);\n          }\n          if (['options', 'rules', 'lexer'].includes(prop)) {\n            // ignore options, rules, and lexer properties\n            continue;\n          }\n          const tokenizerProp = prop as Exclude<keyof _Tokenizer, 'options' | 'rules' | 'lexer'>;\n          const tokenizerFunc = pack.tokenizer[tokenizerProp] as UnknownFunction;\n          const prevTokenizer = tokenizer[tokenizerProp] as UnknownFunction;\n          // Replace tokenizer with func to run extension, but fall back if false\n          // @ts-expect-error cannot type tokenizer function dynamically\n          tokenizer[tokenizerProp] = (...args: unknown[]) => {\n            let ret = tokenizerFunc.apply(tokenizer, args);\n            if (ret === false) {\n              ret = prevTokenizer.apply(tokenizer, args);\n            }\n            return ret;\n          };\n        }\n        opts.tokenizer = tokenizer;\n      }\n\n      // ==-- Parse Hooks extensions --== //\n      if (pack.hooks) {\n        const hooks = this.defaults.hooks || new _Hooks();\n        for (const prop in pack.hooks) {\n          if (!(prop in hooks)) {\n            throw new Error(`hook '${prop}' does not exist`);\n          }\n          if (['options', 'block'].includes(prop)) {\n            // ignore options and block properties\n            continue;\n          }\n          const hooksProp = prop as Exclude<keyof _Hooks, 'options' | 'block'>;\n          const hooksFunc = pack.hooks[hooksProp] as UnknownFunction;\n          const prevHook = hooks[hooksProp] as UnknownFunction;\n          if (_Hooks.passThroughHooks.has(prop)) {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (arg: unknown) => {\n              if (this.defaults.async) {\n                return Promise.resolve(hooksFunc.call(hooks, arg)).then(ret => {\n                  return prevHook.call(hooks, ret);\n                });\n              }\n\n              const ret = hooksFunc.call(hooks, arg);\n              return prevHook.call(hooks, ret);\n            };\n          } else {\n            // @ts-expect-error cannot type hook function dynamically\n            hooks[hooksProp] = (...args: unknown[]) => {\n              let ret = hooksFunc.apply(hooks, args);\n              if (ret === false) {\n                ret = prevHook.apply(hooks, args);\n              }\n              return ret;\n            };\n          }\n        }\n        opts.hooks = hooks;\n      }\n\n      // ==-- Parse WalkTokens extensions --== //\n      if (pack.walkTokens) {\n        const walkTokens = this.defaults.walkTokens;\n        const packWalktokens = pack.walkTokens;\n        opts.walkTokens = function(token) {\n          let values: MaybePromise[] = [];\n          values.push(packWalktokens.call(this, token));\n          if (walkTokens) {\n            values = values.concat(walkTokens.call(this, token));\n          }\n          return values;\n        };\n      }\n\n      this.defaults = { ...this.defaults, ...opts };\n    });\n\n    return this;\n  }\n\n  setOptions(opt: MarkedOptions) {\n    this.defaults = { ...this.defaults, ...opt };\n    return this;\n  }\n\n  lexer(src: string, options?: MarkedOptions) {\n    return _Lexer.lex(src, options ?? this.defaults);\n  }\n\n  parser(tokens: Token[], options?: MarkedOptions) {\n    return _Parser.parse(tokens, options ?? this.defaults);\n  }\n\n  private parseMarkdown(blockType: boolean) {\n    type overloadedParse = {\n      (src: string, options: MarkedOptions & { async: true }): Promise<string>;\n      (src: string, options: MarkedOptions & { async: false }): string;\n      (src: string, options?: MarkedOptions | null): string | Promise<string>;\n    };\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const parse: overloadedParse = (src: string, options?: MarkedOptions | null): any => {\n      const origOpt = { ...options };\n      const opt = { ...this.defaults, ...origOpt };\n\n      const throwError = this.onError(!!opt.silent, !!opt.async);\n\n      // throw error if an extension set async to true but parse was called with async: false\n      if (this.defaults.async === true && origOpt.async === false) {\n        return throwError(new Error('marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.'));\n      }\n\n      // throw error in case of non string input\n      if (typeof src === 'undefined' || src === null) {\n        return throwError(new Error('marked(): input parameter is undefined or null'));\n      }\n      if (typeof src !== 'string') {\n        return throwError(new Error('marked(): input parameter is of type '\n          + Object.prototype.toString.call(src) + ', string expected'));\n      }\n\n      if (opt.hooks) {\n        opt.hooks.options = opt;\n        opt.hooks.block = blockType;\n      }\n\n      const lexer = opt.hooks ? opt.hooks.provideLexer() : (blockType ? _Lexer.lex : _Lexer.lexInline);\n      const parser = opt.hooks ? opt.hooks.provideParser() : (blockType ? _Parser.parse : _Parser.parseInline);\n\n      if (opt.async) {\n        return Promise.resolve(opt.hooks ? opt.hooks.preprocess(src) : src)\n          .then(src => lexer(src, opt))\n          .then(tokens => opt.hooks ? opt.hooks.processAllTokens(tokens) : tokens)\n          .then(tokens => opt.walkTokens ? Promise.all(this.walkTokens(tokens, opt.walkTokens)).then(() => tokens) : tokens)\n          .then(tokens => parser(tokens, opt))\n          .then(html => opt.hooks ? opt.hooks.postprocess(html) : html)\n          .catch(throwError);\n      }\n\n      try {\n        if (opt.hooks) {\n          src = opt.hooks.preprocess(src) as string;\n        }\n        let tokens = lexer(src, opt);\n        if (opt.hooks) {\n          tokens = opt.hooks.processAllTokens(tokens);\n        }\n        if (opt.walkTokens) {\n          this.walkTokens(tokens, opt.walkTokens);\n        }\n        let html = parser(tokens, opt);\n        if (opt.hooks) {\n          html = opt.hooks.postprocess(html) as string;\n        }\n        return html;\n      } catch(e) {\n        return throwError(e as Error);\n      }\n    };\n\n    return parse;\n  }\n\n  private onError(silent: boolean, async: boolean) {\n    return (e: Error): string | Promise<string> => {\n      e.message += '\\nPlease report this to https://github.com/markedjs/marked.';\n\n      if (silent) {\n        const msg = '<p>An error occurred:</p><pre>'\n          + escape(e.message + '', true)\n          + '</pre>';\n        if (async) {\n          return Promise.resolve(msg);\n        }\n        return msg;\n      }\n\n      if (async) {\n        return Promise.reject(e);\n      }\n      throw e;\n    };\n  }\n}\n","/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */\n\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.DOMPurify = factory());\n})(this, (function () { 'use strict';\n\n  const {\n    entries,\n    setPrototypeOf,\n    isFrozen,\n    getPrototypeOf,\n    getOwnPropertyDescriptor\n  } = Object;\n  let {\n    freeze,\n    seal,\n    create\n  } = Object; // eslint-disable-line import/no-mutable-exports\n  let {\n    apply,\n    construct\n  } = typeof Reflect !== 'undefined' && Reflect;\n  if (!freeze) {\n    freeze = function freeze(x) {\n      return x;\n    };\n  }\n  if (!seal) {\n    seal = function seal(x) {\n      return x;\n    };\n  }\n  if (!apply) {\n    apply = function apply(fun, thisValue, args) {\n      return fun.apply(thisValue, args);\n    };\n  }\n  if (!construct) {\n    construct = function construct(Func, args) {\n      return new Func(...args);\n    };\n  }\n  const arrayForEach = unapply(Array.prototype.forEach);\n  const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\n  const arrayPop = unapply(Array.prototype.pop);\n  const arrayPush = unapply(Array.prototype.push);\n  const arraySplice = unapply(Array.prototype.splice);\n  const stringToLowerCase = unapply(String.prototype.toLowerCase);\n  const stringToString = unapply(String.prototype.toString);\n  const stringMatch = unapply(String.prototype.match);\n  const stringReplace = unapply(String.prototype.replace);\n  const stringIndexOf = unapply(String.prototype.indexOf);\n  const stringTrim = unapply(String.prototype.trim);\n  const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n  const regExpTest = unapply(RegExp.prototype.test);\n  const typeErrorCreate = unconstruct(TypeError);\n  /**\n   * Creates a new function that calls the given function with a specified thisArg and arguments.\n   *\n   * @param func - The function to be wrapped and called.\n   * @returns A new function that calls the given function with a specified thisArg and arguments.\n   */\n  function unapply(func) {\n    return function (thisArg) {\n      if (thisArg instanceof RegExp) {\n        thisArg.lastIndex = 0;\n      }\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return apply(func, thisArg, args);\n    };\n  }\n  /**\n   * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n   *\n   * @param func - The constructor function to be wrapped and called.\n   * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n   */\n  function unconstruct(func) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      return construct(func, args);\n    };\n  }\n  /**\n   * Add properties to a lookup table\n   *\n   * @param set - The set to which elements will be added.\n   * @param array - The array containing elements to be added to the set.\n   * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n   * @returns The modified set with added elements.\n   */\n  function addToSet(set, array) {\n    let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;\n    if (setPrototypeOf) {\n      // Make 'in' and truthy checks like Boolean(set.constructor)\n      // independent of any properties defined on Object.prototype.\n      // Prevent prototype setters from intercepting set as a this value.\n      setPrototypeOf(set, null);\n    }\n    let l = array.length;\n    while (l--) {\n      let element = array[l];\n      if (typeof element === 'string') {\n        const lcElement = transformCaseFunc(element);\n        if (lcElement !== element) {\n          // Config presets (e.g. tags.js, attrs.js) are immutable.\n          if (!isFrozen(array)) {\n            array[l] = lcElement;\n          }\n          element = lcElement;\n        }\n      }\n      set[element] = true;\n    }\n    return set;\n  }\n  /**\n   * Clean up an array to harden against CSPP\n   *\n   * @param array - The array to be cleaned.\n   * @returns The cleaned version of the array\n   */\n  function cleanArray(array) {\n    for (let index = 0; index < array.length; index++) {\n      const isPropertyExist = objectHasOwnProperty(array, index);\n      if (!isPropertyExist) {\n        array[index] = null;\n      }\n    }\n    return array;\n  }\n  /**\n   * Shallow clone an object\n   *\n   * @param object - The object to be cloned.\n   * @returns A new object that copies the original.\n   */\n  function clone(object) {\n    const newObject = create(null);\n    for (const [property, value] of entries(object)) {\n      const isPropertyExist = objectHasOwnProperty(object, property);\n      if (isPropertyExist) {\n        if (Array.isArray(value)) {\n          newObject[property] = cleanArray(value);\n        } else if (value && typeof value === 'object' && value.constructor === Object) {\n          newObject[property] = clone(value);\n        } else {\n          newObject[property] = value;\n        }\n      }\n    }\n    return newObject;\n  }\n  /**\n   * This method automatically checks if the prop is function or getter and behaves accordingly.\n   *\n   * @param object - The object to look up the getter function in its prototype chain.\n   * @param prop - The property name for which to find the getter function.\n   * @returns The getter function found in the prototype chain or a fallback function.\n   */\n  function lookupGetter(object, prop) {\n    while (object !== null) {\n      const desc = getOwnPropertyDescriptor(object, prop);\n      if (desc) {\n        if (desc.get) {\n          return unapply(desc.get);\n        }\n        if (typeof desc.value === 'function') {\n          return unapply(desc.value);\n        }\n      }\n      object = getPrototypeOf(object);\n    }\n    function fallbackValue() {\n      return null;\n    }\n    return fallbackValue;\n  }\n\n  const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);\n  const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);\n  const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);\n  // List of SVG elements that are disallowed by default.\n  // We still need to know them so that we can do namespace\n  // checks properly in case one wants to add them to\n  // allow-list.\n  const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);\n  const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);\n  // Similarly to SVG, we want to know all MathML elements,\n  // even those that we disallow by default.\n  const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);\n  const text = freeze(['#text']);\n\n  const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);\n  const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);\n  const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);\n  const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);\n\n  // eslint-disable-next-line unicorn/better-regex\n  const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\n  const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\n  const TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\n  const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\n  const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\n  const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n  );\n  const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\n  const ATTR_WHITESPACE = seal(/[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n  );\n  const DOCTYPE_NAME = seal(/^html$/i);\n  const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n\n  var EXPRESSIONS = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    ARIA_ATTR: ARIA_ATTR,\n    ATTR_WHITESPACE: ATTR_WHITESPACE,\n    CUSTOM_ELEMENT: CUSTOM_ELEMENT,\n    DATA_ATTR: DATA_ATTR,\n    DOCTYPE_NAME: DOCTYPE_NAME,\n    ERB_EXPR: ERB_EXPR,\n    IS_ALLOWED_URI: IS_ALLOWED_URI,\n    IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,\n    MUSTACHE_EXPR: MUSTACHE_EXPR,\n    TMPLIT_EXPR: TMPLIT_EXPR\n  });\n\n  /* eslint-disable @typescript-eslint/indent */\n  // https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\n  const NODE_TYPE = {\n    element: 1,\n    attribute: 2,\n    text: 3,\n    cdataSection: 4,\n    entityReference: 5,\n    // Deprecated\n    entityNode: 6,\n    // Deprecated\n    progressingInstruction: 7,\n    comment: 8,\n    document: 9,\n    documentType: 10,\n    documentFragment: 11,\n    notation: 12 // Deprecated\n  };\n  const getGlobal = function getGlobal() {\n    return typeof window === 'undefined' ? null : window;\n  };\n  /**\n   * Creates a no-op policy for internal use only.\n   * Don't export this function outside this module!\n   * @param trustedTypes The policy factory.\n   * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n   * @return The policy created (or null, if Trusted Types\n   * are not supported or creating the policy failed).\n   */\n  const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {\n    if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {\n      return null;\n    }\n    // Allow the callers to control the unique policy name\n    // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n    // Policy creation with duplicate names throws in Trusted Types.\n    let suffix = null;\n    const ATTR_NAME = 'data-tt-policy-suffix';\n    if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n      suffix = purifyHostElement.getAttribute(ATTR_NAME);\n    }\n    const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n    try {\n      return trustedTypes.createPolicy(policyName, {\n        createHTML(html) {\n          return html;\n        },\n        createScriptURL(scriptUrl) {\n          return scriptUrl;\n        }\n      });\n    } catch (_) {\n      // Policy creation failed (most likely another DOMPurify script has\n      // already run). Skip creating the policy, as this will only cause errors\n      // if TT are enforced.\n      console.warn('TrustedTypes policy ' + policyName + ' could not be created.');\n      return null;\n    }\n  };\n  const _createHooksMap = function _createHooksMap() {\n    return {\n      afterSanitizeAttributes: [],\n      afterSanitizeElements: [],\n      afterSanitizeShadowDOM: [],\n      beforeSanitizeAttributes: [],\n      beforeSanitizeElements: [],\n      beforeSanitizeShadowDOM: [],\n      uponSanitizeAttribute: [],\n      uponSanitizeElement: [],\n      uponSanitizeShadowNode: []\n    };\n  };\n  function createDOMPurify() {\n    let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();\n    const DOMPurify = root => createDOMPurify(root);\n    DOMPurify.version = '3.2.6';\n    DOMPurify.removed = [];\n    if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {\n      // Not running in a browser, provide a factory function\n      // so that you can pass your own Window\n      DOMPurify.isSupported = false;\n      return DOMPurify;\n    }\n    let {\n      document\n    } = window;\n    const originalDocument = document;\n    const currentScript = originalDocument.currentScript;\n    const {\n      DocumentFragment,\n      HTMLTemplateElement,\n      Node,\n      Element,\n      NodeFilter,\n      NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,\n      HTMLFormElement,\n      DOMParser,\n      trustedTypes\n    } = window;\n    const ElementPrototype = Element.prototype;\n    const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n    const remove = lookupGetter(ElementPrototype, 'remove');\n    const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n    const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n    const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n    // As per issue #47, the web-components registry is inherited by a\n    // new document created via createHTMLDocument. As per the spec\n    // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n    // a new empty registry is used when creating a template contents owner\n    // document, so we use that as our parent document to ensure nothing\n    // is inherited.\n    if (typeof HTMLTemplateElement === 'function') {\n      const template = document.createElement('template');\n      if (template.content && template.content.ownerDocument) {\n        document = template.content.ownerDocument;\n      }\n    }\n    let trustedTypesPolicy;\n    let emptyHTML = '';\n    const {\n      implementation,\n      createNodeIterator,\n      createDocumentFragment,\n      getElementsByTagName\n    } = document;\n    const {\n      importNode\n    } = originalDocument;\n    let hooks = _createHooksMap();\n    /**\n     * Expose whether this browser supports running the full DOMPurify.\n     */\n    DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;\n    const {\n      MUSTACHE_EXPR,\n      ERB_EXPR,\n      TMPLIT_EXPR,\n      DATA_ATTR,\n      ARIA_ATTR,\n      IS_SCRIPT_OR_DATA,\n      ATTR_WHITESPACE,\n      CUSTOM_ELEMENT\n    } = EXPRESSIONS;\n    let {\n      IS_ALLOWED_URI: IS_ALLOWED_URI$1\n    } = EXPRESSIONS;\n    /**\n     * We consider the elements and attributes below to be safe. Ideally\n     * don't add any new ones but feel free to remove unwanted ones.\n     */\n    /* allowed element names */\n    let ALLOWED_TAGS = null;\n    const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text]);\n    /* Allowed attribute names */\n    let ALLOWED_ATTR = null;\n    const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);\n    /*\n     * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n     * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n     * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n     * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n     */\n    let CUSTOM_ELEMENT_HANDLING = Object.seal(create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false\n      }\n    }));\n    /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n    let FORBID_TAGS = null;\n    /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n    let FORBID_ATTR = null;\n    /* Decide if ARIA attributes are okay */\n    let ALLOW_ARIA_ATTR = true;\n    /* Decide if custom data attributes are okay */\n    let ALLOW_DATA_ATTR = true;\n    /* Decide if unknown protocols are okay */\n    let ALLOW_UNKNOWN_PROTOCOLS = false;\n    /* Decide if self-closing tags in attributes are allowed.\n     * Usually removed due to a mXSS issue in jQuery 3.0 */\n    let ALLOW_SELF_CLOSE_IN_ATTR = true;\n    /* Output should be safe for common template engines.\n     * This means, DOMPurify removes data attributes, mustaches and ERB\n     */\n    let SAFE_FOR_TEMPLATES = false;\n    /* Output should be safe even for XML used within HTML and alike.\n     * This means, DOMPurify removes comments when containing risky content.\n     */\n    let SAFE_FOR_XML = true;\n    /* Decide if document with <html>... should be returned */\n    let WHOLE_DOCUMENT = false;\n    /* Track whether config is already set on this instance of DOMPurify. */\n    let SET_CONFIG = false;\n    /* Decide if all elements (e.g. style, script) must be children of\n     * document.body. By default, browsers might move them to document.head */\n    let FORCE_BODY = false;\n    /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n     * string (or a TrustedHTML object if Trusted Types are supported).\n     * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n     */\n    let RETURN_DOM = false;\n    /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n     * string  (or a TrustedHTML object if Trusted Types are supported) */\n    let RETURN_DOM_FRAGMENT = false;\n    /* Try to return a Trusted Type object instead of a string, return a string in\n     * case Trusted Types are not supported  */\n    let RETURN_TRUSTED_TYPE = false;\n    /* Output should be free from DOM clobbering attacks?\n     * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n     */\n    let SANITIZE_DOM = true;\n    /* Achieve full DOM Clobbering protection by isolating the namespace of named\n     * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n     *\n     * HTML/DOM spec rules that enable DOM Clobbering:\n     *   - Named Access on Window (§7.3.3)\n     *   - DOM Tree Accessors (§3.1.5)\n     *   - Form Element Parent-Child Relations (§4.10.3)\n     *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n     *   - HTMLCollection (§4.2.10.2)\n     *\n     * Namespace isolation is implemented by prefixing `id` and `name` attributes\n     * with a constant string, i.e., `user-content-`\n     */\n    let SANITIZE_NAMED_PROPS = false;\n    const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n    /* Keep element content when removing element? */\n    let KEEP_CONTENT = true;\n    /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n     * of importing it into a new Document and returning a sanitized copy */\n    let IN_PLACE = false;\n    /* Allow usage of profiles like html, svg and mathMl */\n    let USE_PROFILES = {};\n    /* Tags to ignore content of when KEEP_CONTENT is true */\n    let FORBID_CONTENTS = null;\n    const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);\n    /* Tags that are safe for data: URIs */\n    let DATA_URI_TAGS = null;\n    const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);\n    /* Attributes safe for values like \"javascript:\" */\n    let URI_SAFE_ATTRIBUTES = null;\n    const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);\n    const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n    const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n    const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n    /* Document namespace */\n    let NAMESPACE = HTML_NAMESPACE;\n    let IS_EMPTY_INPUT = false;\n    /* Allowed XHTML+XML namespaces */\n    let ALLOWED_NAMESPACES = null;\n    const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);\n    let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);\n    let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n    // Certain elements are allowed in both SVG and HTML\n    // namespace. We need to specify them explicitly\n    // so that they don't get erroneously deleted from\n    // HTML namespace.\n    const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);\n    /* Parsing of strict XHTML documents */\n    let PARSER_MEDIA_TYPE = null;\n    const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n    const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n    let transformCaseFunc = null;\n    /* Keep a reference to config to pass to hooks */\n    let CONFIG = null;\n    /* Ideally, do not touch anything below this line */\n    /* ______________________________________________ */\n    const formElement = document.createElement('form');\n    const isRegexOrFunction = function isRegexOrFunction(testValue) {\n      return testValue instanceof RegExp || testValue instanceof Function;\n    };\n    /**\n     * _parseConfig\n     *\n     * @param cfg optional config literal\n     */\n    // eslint-disable-next-line complexity\n    const _parseConfig = function _parseConfig() {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      if (CONFIG && CONFIG === cfg) {\n        return;\n      }\n      /* Shield configuration object from tampering */\n      if (!cfg || typeof cfg !== 'object') {\n        cfg = {};\n      }\n      /* Shield configuration object from prototype pollution */\n      cfg = clone(cfg);\n      PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;\n      // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n      transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;\n      /* Set configuration parameters */\n      ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;\n      ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;\n      ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;\n      URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;\n      DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;\n      FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;\n      FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});\n      FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});\n      USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;\n      ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n      ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n      ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n      ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n      SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n      SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n      WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n      RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n      RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n      RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n      FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n      SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n      SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n      KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n      IN_PLACE = cfg.IN_PLACE || false; // Default false\n      IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;\n      NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n      MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n      HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n      CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {\n        CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n      }\n      if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {\n        CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n      }\n      if (SAFE_FOR_TEMPLATES) {\n        ALLOW_DATA_ATTR = false;\n      }\n      if (RETURN_DOM_FRAGMENT) {\n        RETURN_DOM = true;\n      }\n      /* Parse profile info */\n      if (USE_PROFILES) {\n        ALLOWED_TAGS = addToSet({}, text);\n        ALLOWED_ATTR = [];\n        if (USE_PROFILES.html === true) {\n          addToSet(ALLOWED_TAGS, html$1);\n          addToSet(ALLOWED_ATTR, html);\n        }\n        if (USE_PROFILES.svg === true) {\n          addToSet(ALLOWED_TAGS, svg$1);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.svgFilters === true) {\n          addToSet(ALLOWED_TAGS, svgFilters);\n          addToSet(ALLOWED_ATTR, svg);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n        if (USE_PROFILES.mathMl === true) {\n          addToSet(ALLOWED_TAGS, mathMl$1);\n          addToSet(ALLOWED_ATTR, mathMl);\n          addToSet(ALLOWED_ATTR, xml);\n        }\n      }\n      /* Merge configuration parameters */\n      if (cfg.ADD_TAGS) {\n        if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n          ALLOWED_TAGS = clone(ALLOWED_TAGS);\n        }\n        addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n      }\n      if (cfg.ADD_ATTR) {\n        if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n          ALLOWED_ATTR = clone(ALLOWED_ATTR);\n        }\n        addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n      }\n      if (cfg.ADD_URI_SAFE_ATTR) {\n        addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n      }\n      if (cfg.FORBID_CONTENTS) {\n        if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n          FORBID_CONTENTS = clone(FORBID_CONTENTS);\n        }\n        addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n      }\n      /* Add #text in case KEEP_CONTENT is set to true */\n      if (KEEP_CONTENT) {\n        ALLOWED_TAGS['#text'] = true;\n      }\n      /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n      if (WHOLE_DOCUMENT) {\n        addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n      }\n      /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n      if (ALLOWED_TAGS.table) {\n        addToSet(ALLOWED_TAGS, ['tbody']);\n        delete FORBID_TAGS.tbody;\n      }\n      if (cfg.TRUSTED_TYPES_POLICY) {\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.');\n        }\n        if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n          throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.');\n        }\n        // Overwrite existing TrustedTypes policy.\n        trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n        // Sign local variables required by `sanitize`.\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      } else {\n        // Uninitialized policy, attempt to initialize the internal dompurify policy.\n        if (trustedTypesPolicy === undefined) {\n          trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);\n        }\n        // If creating the internal policy succeeded sign internal variables.\n        if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n          emptyHTML = trustedTypesPolicy.createHTML('');\n        }\n      }\n      // Prevent further manipulation of configuration.\n      // Not available in IE8, Safari 5, etc.\n      if (freeze) {\n        freeze(cfg);\n      }\n      CONFIG = cfg;\n    };\n    /* Keep track of all possible SVG and MathML tags\n     * so that we can perform the namespace checks\n     * correctly. */\n    const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);\n    const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);\n    /**\n     * @param element a DOM element whose namespace is being checked\n     * @returns Return false if the element has a\n     *  namespace that a spec-compliant parser would never\n     *  return. Return true otherwise.\n     */\n    const _checkValidNamespace = function _checkValidNamespace(element) {\n      let parent = getParentNode(element);\n      // In JSDOM, if we're inside shadow DOM, then parentNode\n      // can be null. We just simulate parent in this case.\n      if (!parent || !parent.tagName) {\n        parent = {\n          namespaceURI: NAMESPACE,\n          tagName: 'template'\n        };\n      }\n      const tagName = stringToLowerCase(element.tagName);\n      const parentTagName = stringToLowerCase(parent.tagName);\n      if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return false;\n      }\n      if (element.namespaceURI === SVG_NAMESPACE) {\n        // The only way to switch from HTML namespace to SVG\n        // is via <svg>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'svg';\n        }\n        // The only way to switch from MathML to SVG is via`\n        // svg if parent is either <annotation-xml> or MathML\n        // text integration points.\n        if (parent.namespaceURI === MATHML_NAMESPACE) {\n          return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);\n        }\n        // We only allow elements that are defined in SVG\n        // spec. All others are disallowed in SVG namespace.\n        return Boolean(ALL_SVG_TAGS[tagName]);\n      }\n      if (element.namespaceURI === MATHML_NAMESPACE) {\n        // The only way to switch from HTML namespace to MathML\n        // is via <math>. If it happens via any other tag, then\n        // it should be killed.\n        if (parent.namespaceURI === HTML_NAMESPACE) {\n          return tagName === 'math';\n        }\n        // The only way to switch from SVG to MathML is via\n        // <math> and HTML integration points\n        if (parent.namespaceURI === SVG_NAMESPACE) {\n          return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n        }\n        // We only allow elements that are defined in MathML\n        // spec. All others are disallowed in MathML namespace.\n        return Boolean(ALL_MATHML_TAGS[tagName]);\n      }\n      if (element.namespaceURI === HTML_NAMESPACE) {\n        // The only way to switch from SVG to HTML is via\n        // HTML integration points, and from MathML to HTML\n        // is via MathML text integration points\n        if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n        if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {\n          return false;\n        }\n        // We disallow tags that are specific for MathML\n        // or SVG and should never appear in HTML namespace\n        return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);\n      }\n      // For XHTML and XML documents that support custom namespaces\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {\n        return true;\n      }\n      // The code should never reach this place (this means\n      // that the element somehow got namespace that is not\n      // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n      // Return false just in case.\n      return false;\n    };\n    /**\n     * _forceRemove\n     *\n     * @param node a DOM node\n     */\n    const _forceRemove = function _forceRemove(node) {\n      arrayPush(DOMPurify.removed, {\n        element: node\n      });\n      try {\n        // eslint-disable-next-line unicorn/prefer-dom-node-remove\n        getParentNode(node).removeChild(node);\n      } catch (_) {\n        remove(node);\n      }\n    };\n    /**\n     * _removeAttribute\n     *\n     * @param name an Attribute name\n     * @param element a DOM node\n     */\n    const _removeAttribute = function _removeAttribute(name, element) {\n      try {\n        arrayPush(DOMPurify.removed, {\n          attribute: element.getAttributeNode(name),\n          from: element\n        });\n      } catch (_) {\n        arrayPush(DOMPurify.removed, {\n          attribute: null,\n          from: element\n        });\n      }\n      element.removeAttribute(name);\n      // We void attribute values for unremovable \"is\" attributes\n      if (name === 'is') {\n        if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n          try {\n            _forceRemove(element);\n          } catch (_) {}\n        } else {\n          try {\n            element.setAttribute(name, '');\n          } catch (_) {}\n        }\n      }\n    };\n    /**\n     * _initDocument\n     *\n     * @param dirty - a string of dirty markup\n     * @return a DOM, filled with the dirty markup\n     */\n    const _initDocument = function _initDocument(dirty) {\n      /* Create a HTML document */\n      let doc = null;\n      let leadingWhitespace = null;\n      if (FORCE_BODY) {\n        dirty = '<remove></remove>' + dirty;\n      } else {\n        /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n        const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n        leadingWhitespace = matches && matches[0];\n      }\n      if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {\n        // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n        dirty = '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' + dirty + '</body></html>';\n      }\n      const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;\n      /*\n       * Use the DOMParser API by default, fallback later if needs be\n       * DOMParser not work for svg when has multiple root element.\n       */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        try {\n          doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n        } catch (_) {}\n      }\n      /* Use createHTMLDocument in case DOMParser is not available */\n      if (!doc || !doc.documentElement) {\n        doc = implementation.createDocument(NAMESPACE, 'template', null);\n        try {\n          doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;\n        } catch (_) {\n          // Syntax error if dirtyPayload is invalid xml\n        }\n      }\n      const body = doc.body || doc.documentElement;\n      if (dirty && leadingWhitespace) {\n        body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);\n      }\n      /* Work on whole document or just its body */\n      if (NAMESPACE === HTML_NAMESPACE) {\n        return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];\n      }\n      return WHOLE_DOCUMENT ? doc.documentElement : body;\n    };\n    /**\n     * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n     *\n     * @param root The root element or node to start traversing on.\n     * @return The created NodeIterator\n     */\n    const _createNodeIterator = function _createNodeIterator(root) {\n      return createNodeIterator.call(root.ownerDocument || root, root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);\n    };\n    /**\n     * _isClobbered\n     *\n     * @param element element to check for clobbering attacks\n     * @return true if clobbered, false if safe\n     */\n    const _isClobbered = function _isClobbered(element) {\n      return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');\n    };\n    /**\n     * Checks whether the given object is a DOM node.\n     *\n     * @param value object to check whether it's a DOM node\n     * @return true is object is a DOM node\n     */\n    const _isNode = function _isNode(value) {\n      return typeof Node === 'function' && value instanceof Node;\n    };\n    function _executeHooks(hooks, currentNode, data) {\n      arrayForEach(hooks, hook => {\n        hook.call(DOMPurify, currentNode, data, CONFIG);\n      });\n    }\n    /**\n     * _sanitizeElements\n     *\n     * @protect nodeName\n     * @protect textContent\n     * @protect removeChild\n     * @param currentNode to check for permission to exist\n     * @return true if node was killed, false if left alive\n     */\n    const _sanitizeElements = function _sanitizeElements(currentNode) {\n      let content = null;\n      /* Execute a hook if present */\n      _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n      /* Check if element is clobbered or can clobber */\n      if (_isClobbered(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Now let's check the element's type and name */\n      const tagName = transformCaseFunc(currentNode.nodeName);\n      /* Execute a hook if present */\n      _executeHooks(hooks.uponSanitizeElement, currentNode, {\n        tagName,\n        allowedTags: ALLOWED_TAGS\n      });\n      /* Detect mXSS attempts abusing namespace confusion */\n      if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\\w!]/g, currentNode.textContent)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Remove any occurrence of processing instructions */\n      if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Remove any kind of possibly harmful comments */\n      if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\\w]/g, currentNode.data)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Remove element if anything forbids its presence */\n      if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n        /* Check if we have a custom element to handle */\n        if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {\n            return false;\n          }\n          if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {\n            return false;\n          }\n        }\n        /* Keep content except for bad-listed elements */\n        if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n          const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n          const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n          if (childNodes && parentNode) {\n            const childCount = childNodes.length;\n            for (let i = childCount - 1; i >= 0; --i) {\n              const childClone = cloneNode(childNodes[i], true);\n              childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n              parentNode.insertBefore(childClone, getNextSibling(currentNode));\n            }\n          }\n        }\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Check whether element has a valid namespace */\n      if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Make sure that older browsers don't get fallback-tag mXSS */\n      if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)) {\n        _forceRemove(currentNode);\n        return true;\n      }\n      /* Sanitize element content to be template-safe */\n      if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n        /* Get the element's text content */\n        content = currentNode.textContent;\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          content = stringReplace(content, expr, ' ');\n        });\n        if (currentNode.textContent !== content) {\n          arrayPush(DOMPurify.removed, {\n            element: currentNode.cloneNode()\n          });\n          currentNode.textContent = content;\n        }\n      }\n      /* Execute a hook if present */\n      _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n      return false;\n    };\n    /**\n     * _isValidAttribute\n     *\n     * @param lcTag Lowercase tag name of containing element.\n     * @param lcName Lowercase attribute name.\n     * @param value Attribute value.\n     * @return Returns true if `value` is valid, otherwise false.\n     */\n    // eslint-disable-next-line complexity\n    const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {\n      /* Make sure attribute cannot clobber */\n      if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {\n        return false;\n      }\n      /* Allow valid data-* attributes: At least one character after \"-\"\n          (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n          XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n          We don't need to check the value; it's always URI safe. */\n      if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n        if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {\n          return false;\n        }\n        /* Check value is safe. First, is attr inert? If so, is safe */\n      } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {\n        return false;\n      } else ;\n      return true;\n    };\n    /**\n     * _isBasicCustomElement\n     * checks if at least one dash is included in tagName, and it's not the first char\n     * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n     *\n     * @param tagName name of the tag of the node to sanitize\n     * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n     */\n    const _isBasicCustomElement = function _isBasicCustomElement(tagName) {\n      return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n    };\n    /**\n     * _sanitizeAttributes\n     *\n     * @protect attributes\n     * @protect nodeName\n     * @protect removeAttribute\n     * @protect setAttribute\n     *\n     * @param currentNode to sanitize\n     */\n    const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {\n      /* Execute a hook if present */\n      _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n      const {\n        attributes\n      } = currentNode;\n      /* Check if we have attributes; if not we might have a text node */\n      if (!attributes || _isClobbered(currentNode)) {\n        return;\n      }\n      const hookEvent = {\n        attrName: '',\n        attrValue: '',\n        keepAttr: true,\n        allowedAttributes: ALLOWED_ATTR,\n        forceKeepAttr: undefined\n      };\n      let l = attributes.length;\n      /* Go backwards over all attributes; safely remove bad ones */\n      while (l--) {\n        const attr = attributes[l];\n        const {\n          name,\n          namespaceURI,\n          value: attrValue\n        } = attr;\n        const lcName = transformCaseFunc(name);\n        const initValue = attrValue;\n        let value = name === 'value' ? initValue : stringTrim(initValue);\n        /* Execute a hook if present */\n        hookEvent.attrName = lcName;\n        hookEvent.attrValue = value;\n        hookEvent.keepAttr = true;\n        hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n        _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n        value = hookEvent.attrValue;\n        /* Full DOM Clobbering protection via namespace isolation,\n         * Prefix id and name attributes with `user-content-`\n         */\n        if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n          // Remove the attribute with this value\n          _removeAttribute(name, currentNode);\n          // Prefix the value and later re-create the attribute with the sanitized value\n          value = SANITIZE_NAMED_PROPS_PREFIX + value;\n        }\n        /* Work around a security issue with comments inside attributes */\n        if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n        /* Did the hooks approve of the attribute? */\n        if (hookEvent.forceKeepAttr) {\n          continue;\n        }\n        /* Did the hooks approve of the attribute? */\n        if (!hookEvent.keepAttr) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n        /* Work around a security issue in jQuery 3.0 */\n        if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n        /* Sanitize attribute content to be template-safe */\n        if (SAFE_FOR_TEMPLATES) {\n          arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n            value = stringReplace(value, expr, ' ');\n          });\n        }\n        /* Is `value` valid for this attribute? */\n        const lcTag = transformCaseFunc(currentNode.nodeName);\n        if (!_isValidAttribute(lcTag, lcName, value)) {\n          _removeAttribute(name, currentNode);\n          continue;\n        }\n        /* Handle attributes that require Trusted Types */\n        if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {\n          if (namespaceURI) ; else {\n            switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n              case 'TrustedHTML':\n                {\n                  value = trustedTypesPolicy.createHTML(value);\n                  break;\n                }\n              case 'TrustedScriptURL':\n                {\n                  value = trustedTypesPolicy.createScriptURL(value);\n                  break;\n                }\n            }\n          }\n        }\n        /* Handle invalid data-* attribute set by try-catching it */\n        if (value !== initValue) {\n          try {\n            if (namespaceURI) {\n              currentNode.setAttributeNS(namespaceURI, name, value);\n            } else {\n              /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n              currentNode.setAttribute(name, value);\n            }\n            if (_isClobbered(currentNode)) {\n              _forceRemove(currentNode);\n            } else {\n              arrayPop(DOMPurify.removed);\n            }\n          } catch (_) {\n            _removeAttribute(name, currentNode);\n          }\n        }\n      }\n      /* Execute a hook if present */\n      _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n    };\n    /**\n     * _sanitizeShadowDOM\n     *\n     * @param fragment to iterate over recursively\n     */\n    const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {\n      let shadowNode = null;\n      const shadowIterator = _createNodeIterator(fragment);\n      /* Execute a hook if present */\n      _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n      while (shadowNode = shadowIterator.nextNode()) {\n        /* Execute a hook if present */\n        _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n        /* Sanitize tags and elements */\n        _sanitizeElements(shadowNode);\n        /* Check attributes next */\n        _sanitizeAttributes(shadowNode);\n        /* Deep shadow DOM detected */\n        if (shadowNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(shadowNode.content);\n        }\n      }\n      /* Execute a hook if present */\n      _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n    };\n    // eslint-disable-next-line complexity\n    DOMPurify.sanitize = function (dirty) {\n      let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      let body = null;\n      let importedNode = null;\n      let currentNode = null;\n      let returnNode = null;\n      /* Make sure we have a string to sanitize.\n        DO NOT return early, as this will return the wrong type if\n        the user has requested a DOM object rather than a string */\n      IS_EMPTY_INPUT = !dirty;\n      if (IS_EMPTY_INPUT) {\n        dirty = '<!-->';\n      }\n      /* Stringify, in case dirty is an object */\n      if (typeof dirty !== 'string' && !_isNode(dirty)) {\n        if (typeof dirty.toString === 'function') {\n          dirty = dirty.toString();\n          if (typeof dirty !== 'string') {\n            throw typeErrorCreate('dirty is not a string, aborting');\n          }\n        } else {\n          throw typeErrorCreate('toString is not a function');\n        }\n      }\n      /* Return dirty HTML if DOMPurify cannot run */\n      if (!DOMPurify.isSupported) {\n        return dirty;\n      }\n      /* Assign config vars */\n      if (!SET_CONFIG) {\n        _parseConfig(cfg);\n      }\n      /* Clean up removed elements */\n      DOMPurify.removed = [];\n      /* Check if dirty is correctly typed for IN_PLACE */\n      if (typeof dirty === 'string') {\n        IN_PLACE = false;\n      }\n      if (IN_PLACE) {\n        /* Do some early pre-sanitization to avoid unsafe root nodes */\n        if (dirty.nodeName) {\n          const tagName = transformCaseFunc(dirty.nodeName);\n          if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n            throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');\n          }\n        }\n      } else if (dirty instanceof Node) {\n        /* If dirty is a DOM element, append to an empty document to avoid\n           elements being stripped by the parser */\n        body = _initDocument('<!---->');\n        importedNode = body.ownerDocument.importNode(dirty, true);\n        if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {\n          /* Node is already a body, use as is */\n          body = importedNode;\n        } else if (importedNode.nodeName === 'HTML') {\n          body = importedNode;\n        } else {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          body.appendChild(importedNode);\n        }\n      } else {\n        /* Exit directly if we have nothing to do */\n        if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1) {\n          return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;\n        }\n        /* Initialize the document to work on */\n        body = _initDocument(dirty);\n        /* Check we have a DOM node from the data */\n        if (!body) {\n          return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n        }\n      }\n      /* Remove first element node (ours) if FORCE_BODY is set */\n      if (body && FORCE_BODY) {\n        _forceRemove(body.firstChild);\n      }\n      /* Get node iterator */\n      const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n      /* Now start iterating over the created document */\n      while (currentNode = nodeIterator.nextNode()) {\n        /* Sanitize tags and elements */\n        _sanitizeElements(currentNode);\n        /* Check attributes next */\n        _sanitizeAttributes(currentNode);\n        /* Shadow DOM detected, sanitize it */\n        if (currentNode.content instanceof DocumentFragment) {\n          _sanitizeShadowDOM(currentNode.content);\n        }\n      }\n      /* If we sanitized `dirty` in-place, return it. */\n      if (IN_PLACE) {\n        return dirty;\n      }\n      /* Return sanitized string or DOM */\n      if (RETURN_DOM) {\n        if (RETURN_DOM_FRAGMENT) {\n          returnNode = createDocumentFragment.call(body.ownerDocument);\n          while (body.firstChild) {\n            // eslint-disable-next-line unicorn/prefer-dom-node-append\n            returnNode.appendChild(body.firstChild);\n          }\n        } else {\n          returnNode = body;\n        }\n        if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n          /*\n            AdoptNode() is not used because internal state is not reset\n            (e.g. the past names map of a HTMLFormElement), this is safe\n            in theory but we would rather not risk another attack vector.\n            The state that is cloned by importNode() is explicitly defined\n            by the specs.\n          */\n          returnNode = importNode.call(originalDocument, returnNode, true);\n        }\n        return returnNode;\n      }\n      let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n      /* Serialize doctype if allowed */\n      if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {\n        serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n      }\n      /* Sanitize final string template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {\n          serializedHTML = stringReplace(serializedHTML, expr, ' ');\n        });\n      }\n      return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;\n    };\n    DOMPurify.setConfig = function () {\n      let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      _parseConfig(cfg);\n      SET_CONFIG = true;\n    };\n    DOMPurify.clearConfig = function () {\n      CONFIG = null;\n      SET_CONFIG = false;\n    };\n    DOMPurify.isValidAttribute = function (tag, attr, value) {\n      /* Initialize shared config vars if necessary. */\n      if (!CONFIG) {\n        _parseConfig({});\n      }\n      const lcTag = transformCaseFunc(tag);\n      const lcName = transformCaseFunc(attr);\n      return _isValidAttribute(lcTag, lcName, value);\n    };\n    DOMPurify.addHook = function (entryPoint, hookFunction) {\n      if (typeof hookFunction !== 'function') {\n        return;\n      }\n      arrayPush(hooks[entryPoint], hookFunction);\n    };\n    DOMPurify.removeHook = function (entryPoint, hookFunction) {\n      if (hookFunction !== undefined) {\n        const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n        return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];\n      }\n      return arrayPop(hooks[entryPoint]);\n    };\n    DOMPurify.removeHooks = function (entryPoint) {\n      hooks[entryPoint] = [];\n    };\n    DOMPurify.removeAllHooks = function () {\n      hooks = _createHooksMap();\n    };\n    return DOMPurify;\n  }\n  var purify = createDOMPurify();\n\n  return purify;\n\n}));\n//# sourceMappingURL=purify.js.map\n","const {\n  entries,\n  setPrototypeOf,\n  isFrozen,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n} = Object;\n\nlet { freeze, seal, create } = Object; // eslint-disable-line import/no-mutable-exports\nlet { apply, construct } = typeof Reflect !== 'undefined' && Reflect;\n\nif (!freeze) {\n  freeze = function (x) {\n    return x;\n  };\n}\n\nif (!seal) {\n  seal = function (x) {\n    return x;\n  };\n}\n\nif (!apply) {\n  apply = function (fun, thisValue, args) {\n    return fun.apply(thisValue, args);\n  };\n}\n\nif (!construct) {\n  construct = function (Func, args) {\n    return new Func(...args);\n  };\n}\n\nconst arrayForEach = unapply(Array.prototype.forEach);\nconst arrayIndexOf = unapply(Array.prototype.indexOf);\nconst arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);\nconst arrayPop = unapply(Array.prototype.pop);\nconst arrayPush = unapply(Array.prototype.push);\nconst arraySlice = unapply(Array.prototype.slice);\nconst arraySplice = unapply(Array.prototype.splice);\n\nconst stringToLowerCase = unapply(String.prototype.toLowerCase);\nconst stringToString = unapply(String.prototype.toString);\nconst stringMatch = unapply(String.prototype.match);\nconst stringReplace = unapply(String.prototype.replace);\nconst stringIndexOf = unapply(String.prototype.indexOf);\nconst stringTrim = unapply(String.prototype.trim);\n\nconst objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);\n\nconst regExpTest = unapply(RegExp.prototype.test);\n\nconst typeErrorCreate = unconstruct(TypeError);\n\n/**\n * Creates a new function that calls the given function with a specified thisArg and arguments.\n *\n * @param func - The function to be wrapped and called.\n * @returns A new function that calls the given function with a specified thisArg and arguments.\n */\nfunction unapply<T>(\n  func: (thisArg: any, ...args: any[]) => T\n): (thisArg: any, ...args: any[]) => T {\n  return (thisArg: any, ...args: any[]): T => {\n    if (thisArg instanceof RegExp) {\n      thisArg.lastIndex = 0;\n    }\n\n    return apply(func, thisArg, args);\n  };\n}\n\n/**\n * Creates a new function that constructs an instance of the given constructor function with the provided arguments.\n *\n * @param func - The constructor function to be wrapped and called.\n * @returns A new function that constructs an instance of the given constructor function with the provided arguments.\n */\nfunction unconstruct<T>(func: (...args: any[]) => T): (...args: any[]) => T {\n  return (...args: any[]): T => construct(func, args);\n}\n\n/**\n * Add properties to a lookup table\n *\n * @param set - The set to which elements will be added.\n * @param array - The array containing elements to be added to the set.\n * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.\n * @returns The modified set with added elements.\n */\nfunction addToSet(\n  set: Record<string, any>,\n  array: readonly any[],\n  transformCaseFunc: ReturnType<typeof unapply<string>> = stringToLowerCase\n): Record<string, any> {\n  if (setPrototypeOf) {\n    // Make 'in' and truthy checks like Boolean(set.constructor)\n    // independent of any properties defined on Object.prototype.\n    // Prevent prototype setters from intercepting set as a this value.\n    setPrototypeOf(set, null);\n  }\n\n  let l = array.length;\n  while (l--) {\n    let element = array[l];\n    if (typeof element === 'string') {\n      const lcElement = transformCaseFunc(element);\n      if (lcElement !== element) {\n        // Config presets (e.g. tags.js, attrs.js) are immutable.\n        if (!isFrozen(array)) {\n          (array as any[])[l] = lcElement;\n        }\n\n        element = lcElement;\n      }\n    }\n\n    set[element] = true;\n  }\n\n  return set;\n}\n\n/**\n * Clean up an array to harden against CSPP\n *\n * @param array - The array to be cleaned.\n * @returns The cleaned version of the array\n */\nfunction cleanArray<T>(array: T[]): Array<T | null> {\n  for (let index = 0; index < array.length; index++) {\n    const isPropertyExist = objectHasOwnProperty(array, index);\n\n    if (!isPropertyExist) {\n      array[index] = null;\n    }\n  }\n\n  return array;\n}\n\n/**\n * Shallow clone an object\n *\n * @param object - The object to be cloned.\n * @returns A new object that copies the original.\n */\nfunction clone<T extends Record<string, any>>(object: T): T {\n  const newObject = create(null);\n\n  for (const [property, value] of entries(object)) {\n    const isPropertyExist = objectHasOwnProperty(object, property);\n\n    if (isPropertyExist) {\n      if (Array.isArray(value)) {\n        newObject[property] = cleanArray(value);\n      } else if (\n        value &&\n        typeof value === 'object' &&\n        value.constructor === Object\n      ) {\n        newObject[property] = clone(value);\n      } else {\n        newObject[property] = value;\n      }\n    }\n  }\n\n  return newObject;\n}\n\n/**\n * This method automatically checks if the prop is function or getter and behaves accordingly.\n *\n * @param object - The object to look up the getter function in its prototype chain.\n * @param prop - The property name for which to find the getter function.\n * @returns The getter function found in the prototype chain or a fallback function.\n */\nfunction lookupGetter<T extends Record<string, any>>(\n  object: T,\n  prop: string\n): ReturnType<typeof unapply<any>> | (() => null) {\n  while (object !== null) {\n    const desc = getOwnPropertyDescriptor(object, prop);\n\n    if (desc) {\n      if (desc.get) {\n        return unapply(desc.get);\n      }\n\n      if (typeof desc.value === 'function') {\n        return unapply(desc.value);\n      }\n    }\n\n    object = getPrototypeOf(object);\n  }\n\n  function fallbackValue(): null {\n    return null;\n  }\n\n  return fallbackValue;\n}\n\nexport {\n  // Array\n  arrayForEach,\n  arrayIndexOf,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySlice,\n  arraySplice,\n  // Object\n  entries,\n  freeze,\n  getPrototypeOf,\n  getOwnPropertyDescriptor,\n  isFrozen,\n  setPrototypeOf,\n  seal,\n  clone,\n  create,\n  objectHasOwnProperty,\n  // RegExp\n  regExpTest,\n  // String\n  stringIndexOf,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringTrim,\n  // Errors\n  typeErrorCreate,\n  // Other\n  lookupGetter,\n  addToSet,\n  // Reflect\n  unapply,\n  unconstruct,\n};\n","import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'a',\n  'abbr',\n  'acronym',\n  'address',\n  'area',\n  'article',\n  'aside',\n  'audio',\n  'b',\n  'bdi',\n  'bdo',\n  'big',\n  'blink',\n  'blockquote',\n  'body',\n  'br',\n  'button',\n  'canvas',\n  'caption',\n  'center',\n  'cite',\n  'code',\n  'col',\n  'colgroup',\n  'content',\n  'data',\n  'datalist',\n  'dd',\n  'decorator',\n  'del',\n  'details',\n  'dfn',\n  'dialog',\n  'dir',\n  'div',\n  'dl',\n  'dt',\n  'element',\n  'em',\n  'fieldset',\n  'figcaption',\n  'figure',\n  'font',\n  'footer',\n  'form',\n  'h1',\n  'h2',\n  'h3',\n  'h4',\n  'h5',\n  'h6',\n  'head',\n  'header',\n  'hgroup',\n  'hr',\n  'html',\n  'i',\n  'img',\n  'input',\n  'ins',\n  'kbd',\n  'label',\n  'legend',\n  'li',\n  'main',\n  'map',\n  'mark',\n  'marquee',\n  'menu',\n  'menuitem',\n  'meter',\n  'nav',\n  'nobr',\n  'ol',\n  'optgroup',\n  'option',\n  'output',\n  'p',\n  'picture',\n  'pre',\n  'progress',\n  'q',\n  'rp',\n  'rt',\n  'ruby',\n  's',\n  'samp',\n  'section',\n  'select',\n  'shadow',\n  'small',\n  'source',\n  'spacer',\n  'span',\n  'strike',\n  'strong',\n  'style',\n  'sub',\n  'summary',\n  'sup',\n  'table',\n  'tbody',\n  'td',\n  'template',\n  'textarea',\n  'tfoot',\n  'th',\n  'thead',\n  'time',\n  'tr',\n  'track',\n  'tt',\n  'u',\n  'ul',\n  'var',\n  'video',\n  'wbr',\n] as const);\n\nexport const svg = freeze([\n  'svg',\n  'a',\n  'altglyph',\n  'altglyphdef',\n  'altglyphitem',\n  'animatecolor',\n  'animatemotion',\n  'animatetransform',\n  'circle',\n  'clippath',\n  'defs',\n  'desc',\n  'ellipse',\n  'filter',\n  'font',\n  'g',\n  'glyph',\n  'glyphref',\n  'hkern',\n  'image',\n  'line',\n  'lineargradient',\n  'marker',\n  'mask',\n  'metadata',\n  'mpath',\n  'path',\n  'pattern',\n  'polygon',\n  'polyline',\n  'radialgradient',\n  'rect',\n  'stop',\n  'style',\n  'switch',\n  'symbol',\n  'text',\n  'textpath',\n  'title',\n  'tref',\n  'tspan',\n  'view',\n  'vkern',\n] as const);\n\nexport const svgFilters = freeze([\n  'feBlend',\n  'feColorMatrix',\n  'feComponentTransfer',\n  'feComposite',\n  'feConvolveMatrix',\n  'feDiffuseLighting',\n  'feDisplacementMap',\n  'feDistantLight',\n  'feDropShadow',\n  'feFlood',\n  'feFuncA',\n  'feFuncB',\n  'feFuncG',\n  'feFuncR',\n  'feGaussianBlur',\n  'feImage',\n  'feMerge',\n  'feMergeNode',\n  'feMorphology',\n  'feOffset',\n  'fePointLight',\n  'feSpecularLighting',\n  'feSpotLight',\n  'feTile',\n  'feTurbulence',\n] as const);\n\n// List of SVG elements that are disallowed by default.\n// We still need to know them so that we can do namespace\n// checks properly in case one wants to add them to\n// allow-list.\nexport const svgDisallowed = freeze([\n  'animate',\n  'color-profile',\n  'cursor',\n  'discard',\n  'font-face',\n  'font-face-format',\n  'font-face-name',\n  'font-face-src',\n  'font-face-uri',\n  'foreignobject',\n  'hatch',\n  'hatchpath',\n  'mesh',\n  'meshgradient',\n  'meshpatch',\n  'meshrow',\n  'missing-glyph',\n  'script',\n  'set',\n  'solidcolor',\n  'unknown',\n  'use',\n] as const);\n\nexport const mathMl = freeze([\n  'math',\n  'menclose',\n  'merror',\n  'mfenced',\n  'mfrac',\n  'mglyph',\n  'mi',\n  'mlabeledtr',\n  'mmultiscripts',\n  'mn',\n  'mo',\n  'mover',\n  'mpadded',\n  'mphantom',\n  'mroot',\n  'mrow',\n  'ms',\n  'mspace',\n  'msqrt',\n  'mstyle',\n  'msub',\n  'msup',\n  'msubsup',\n  'mtable',\n  'mtd',\n  'mtext',\n  'mtr',\n  'munder',\n  'munderover',\n  'mprescripts',\n] as const);\n\n// Similarly to SVG, we want to know all MathML elements,\n// even those that we disallow by default.\nexport const mathMlDisallowed = freeze([\n  'maction',\n  'maligngroup',\n  'malignmark',\n  'mlongdiv',\n  'mscarries',\n  'mscarry',\n  'msgroup',\n  'mstack',\n  'msline',\n  'msrow',\n  'semantics',\n  'annotation',\n  'annotation-xml',\n  'mprescripts',\n  'none',\n] as const);\n\nexport const text = freeze(['#text'] as const);\n","import { freeze } from './utils.js';\n\nexport const html = freeze([\n  'accept',\n  'action',\n  'align',\n  'alt',\n  'autocapitalize',\n  'autocomplete',\n  'autopictureinpicture',\n  'autoplay',\n  'background',\n  'bgcolor',\n  'border',\n  'capture',\n  'cellpadding',\n  'cellspacing',\n  'checked',\n  'cite',\n  'class',\n  'clear',\n  'color',\n  'cols',\n  'colspan',\n  'controls',\n  'controlslist',\n  'coords',\n  'crossorigin',\n  'datetime',\n  'decoding',\n  'default',\n  'dir',\n  'disabled',\n  'disablepictureinpicture',\n  'disableremoteplayback',\n  'download',\n  'draggable',\n  'enctype',\n  'enterkeyhint',\n  'face',\n  'for',\n  'headers',\n  'height',\n  'hidden',\n  'high',\n  'href',\n  'hreflang',\n  'id',\n  'inputmode',\n  'integrity',\n  'ismap',\n  'kind',\n  'label',\n  'lang',\n  'list',\n  'loading',\n  'loop',\n  'low',\n  'max',\n  'maxlength',\n  'media',\n  'method',\n  'min',\n  'minlength',\n  'multiple',\n  'muted',\n  'name',\n  'nonce',\n  'noshade',\n  'novalidate',\n  'nowrap',\n  'open',\n  'optimum',\n  'pattern',\n  'placeholder',\n  'playsinline',\n  'popover',\n  'popovertarget',\n  'popovertargetaction',\n  'poster',\n  'preload',\n  'pubdate',\n  'radiogroup',\n  'readonly',\n  'rel',\n  'required',\n  'rev',\n  'reversed',\n  'role',\n  'rows',\n  'rowspan',\n  'spellcheck',\n  'scope',\n  'selected',\n  'shape',\n  'size',\n  'sizes',\n  'span',\n  'srclang',\n  'start',\n  'src',\n  'srcset',\n  'step',\n  'style',\n  'summary',\n  'tabindex',\n  'title',\n  'translate',\n  'type',\n  'usemap',\n  'valign',\n  'value',\n  'width',\n  'wrap',\n  'xmlns',\n  'slot',\n] as const);\n\nexport const svg = freeze([\n  'accent-height',\n  'accumulate',\n  'additive',\n  'alignment-baseline',\n  'amplitude',\n  'ascent',\n  'attributename',\n  'attributetype',\n  'azimuth',\n  'basefrequency',\n  'baseline-shift',\n  'begin',\n  'bias',\n  'by',\n  'class',\n  'clip',\n  'clippathunits',\n  'clip-path',\n  'clip-rule',\n  'color',\n  'color-interpolation',\n  'color-interpolation-filters',\n  'color-profile',\n  'color-rendering',\n  'cx',\n  'cy',\n  'd',\n  'dx',\n  'dy',\n  'diffuseconstant',\n  'direction',\n  'display',\n  'divisor',\n  'dur',\n  'edgemode',\n  'elevation',\n  'end',\n  'exponent',\n  'fill',\n  'fill-opacity',\n  'fill-rule',\n  'filter',\n  'filterunits',\n  'flood-color',\n  'flood-opacity',\n  'font-family',\n  'font-size',\n  'font-size-adjust',\n  'font-stretch',\n  'font-style',\n  'font-variant',\n  'font-weight',\n  'fx',\n  'fy',\n  'g1',\n  'g2',\n  'glyph-name',\n  'glyphref',\n  'gradientunits',\n  'gradienttransform',\n  'height',\n  'href',\n  'id',\n  'image-rendering',\n  'in',\n  'in2',\n  'intercept',\n  'k',\n  'k1',\n  'k2',\n  'k3',\n  'k4',\n  'kerning',\n  'keypoints',\n  'keysplines',\n  'keytimes',\n  'lang',\n  'lengthadjust',\n  'letter-spacing',\n  'kernelmatrix',\n  'kernelunitlength',\n  'lighting-color',\n  'local',\n  'marker-end',\n  'marker-mid',\n  'marker-start',\n  'markerheight',\n  'markerunits',\n  'markerwidth',\n  'maskcontentunits',\n  'maskunits',\n  'max',\n  'mask',\n  'media',\n  'method',\n  'mode',\n  'min',\n  'name',\n  'numoctaves',\n  'offset',\n  'operator',\n  'opacity',\n  'order',\n  'orient',\n  'orientation',\n  'origin',\n  'overflow',\n  'paint-order',\n  'path',\n  'pathlength',\n  'patterncontentunits',\n  'patterntransform',\n  'patternunits',\n  'points',\n  'preservealpha',\n  'preserveaspectratio',\n  'primitiveunits',\n  'r',\n  'rx',\n  'ry',\n  'radius',\n  'refx',\n  'refy',\n  'repeatcount',\n  'repeatdur',\n  'restart',\n  'result',\n  'rotate',\n  'scale',\n  'seed',\n  'shape-rendering',\n  'slope',\n  'specularconstant',\n  'specularexponent',\n  'spreadmethod',\n  'startoffset',\n  'stddeviation',\n  'stitchtiles',\n  'stop-color',\n  'stop-opacity',\n  'stroke-dasharray',\n  'stroke-dashoffset',\n  'stroke-linecap',\n  'stroke-linejoin',\n  'stroke-miterlimit',\n  'stroke-opacity',\n  'stroke',\n  'stroke-width',\n  'style',\n  'surfacescale',\n  'systemlanguage',\n  'tabindex',\n  'tablevalues',\n  'targetx',\n  'targety',\n  'transform',\n  'transform-origin',\n  'text-anchor',\n  'text-decoration',\n  'text-rendering',\n  'textlength',\n  'type',\n  'u1',\n  'u2',\n  'unicode',\n  'values',\n  'viewbox',\n  'visibility',\n  'version',\n  'vert-adv-y',\n  'vert-origin-x',\n  'vert-origin-y',\n  'width',\n  'word-spacing',\n  'wrap',\n  'writing-mode',\n  'xchannelselector',\n  'ychannelselector',\n  'x',\n  'x1',\n  'x2',\n  'xmlns',\n  'y',\n  'y1',\n  'y2',\n  'z',\n  'zoomandpan',\n] as const);\n\nexport const mathMl = freeze([\n  'accent',\n  'accentunder',\n  'align',\n  'bevelled',\n  'close',\n  'columnsalign',\n  'columnlines',\n  'columnspan',\n  'denomalign',\n  'depth',\n  'dir',\n  'display',\n  'displaystyle',\n  'encoding',\n  'fence',\n  'frame',\n  'height',\n  'href',\n  'id',\n  'largeop',\n  'length',\n  'linethickness',\n  'lspace',\n  'lquote',\n  'mathbackground',\n  'mathcolor',\n  'mathsize',\n  'mathvariant',\n  'maxsize',\n  'minsize',\n  'movablelimits',\n  'notation',\n  'numalign',\n  'open',\n  'rowalign',\n  'rowlines',\n  'rowspacing',\n  'rowspan',\n  'rspace',\n  'rquote',\n  'scriptlevel',\n  'scriptminsize',\n  'scriptsizemultiplier',\n  'selection',\n  'separator',\n  'separators',\n  'stretchy',\n  'subscriptshift',\n  'supscriptshift',\n  'symmetric',\n  'voffset',\n  'width',\n  'xmlns',\n]);\n\nexport const xml = freeze([\n  'xlink:href',\n  'xml:id',\n  'xlink:title',\n  'xml:space',\n  'xmlns:xlink',\n] as const);\n","import { seal } from './utils.js';\n\n// eslint-disable-next-line unicorn/better-regex\nexport const MUSTACHE_EXPR = seal(/\\{\\{[\\w\\W]*|[\\w\\W]*\\}\\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode\nexport const ERB_EXPR = seal(/<%[\\w\\W]*|[\\w\\W]*%>/gm);\nexport const TMPLIT_EXPR = seal(/\\$\\{[\\w\\W]*/gm); // eslint-disable-line unicorn/better-regex\nexport const DATA_ATTR = seal(/^data-[\\-\\w.\\u00B7-\\uFFFF]+$/); // eslint-disable-line no-useless-escape\nexport const ARIA_ATTR = seal(/^aria-[\\-\\w]+$/); // eslint-disable-line no-useless-escape\nexport const IS_ALLOWED_URI = seal(\n  /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\\-]+(?:[^a-z+.\\-:]|$))/i // eslint-disable-line no-useless-escape\n);\nexport const IS_SCRIPT_OR_DATA = seal(/^(?:\\w+script|data):/i);\nexport const ATTR_WHITESPACE = seal(\n  /[\\u0000-\\u0020\\u00A0\\u1680\\u180E\\u2000-\\u2029\\u205F\\u3000]/g // eslint-disable-line no-control-regex\n);\nexport const DOCTYPE_NAME = seal(/^html$/i);\nexport const CUSTOM_ELEMENT = seal(/^[a-z][.\\w]*(-[.\\w]+)+$/i);\n","/* eslint-disable @typescript-eslint/indent */\n\nimport type { TrustedHTML, TrustedTypesWindow } from 'trusted-types/lib';\nimport type { Config, UseProfilesConfig } from './config';\nimport * as TAGS from './tags.js';\nimport * as ATTRS from './attrs.js';\nimport * as EXPRESSIONS from './regexp.js';\nimport {\n  addToSet,\n  clone,\n  entries,\n  freeze,\n  arrayForEach,\n  arrayLastIndexOf,\n  arrayPop,\n  arrayPush,\n  arraySplice,\n  stringMatch,\n  stringReplace,\n  stringToLowerCase,\n  stringToString,\n  stringIndexOf,\n  stringTrim,\n  regExpTest,\n  typeErrorCreate,\n  lookupGetter,\n  create,\n  objectHasOwnProperty,\n} from './utils.js';\n\nexport type { Config } from './config';\n\ndeclare const VERSION: string;\n\n// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType\nconst NODE_TYPE = {\n  element: 1,\n  attribute: 2,\n  text: 3,\n  cdataSection: 4,\n  entityReference: 5, // Deprecated\n  entityNode: 6, // Deprecated\n  progressingInstruction: 7,\n  comment: 8,\n  document: 9,\n  documentType: 10,\n  documentFragment: 11,\n  notation: 12, // Deprecated\n};\n\nconst getGlobal = function (): WindowLike {\n  return typeof window === 'undefined' ? null : window;\n};\n\n/**\n * Creates a no-op policy for internal use only.\n * Don't export this function outside this module!\n * @param trustedTypes The policy factory.\n * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).\n * @return The policy created (or null, if Trusted Types\n * are not supported or creating the policy failed).\n */\nconst _createTrustedTypesPolicy = function (\n  trustedTypes: TrustedTypePolicyFactory,\n  purifyHostElement: HTMLScriptElement\n) {\n  if (\n    typeof trustedTypes !== 'object' ||\n    typeof trustedTypes.createPolicy !== 'function'\n  ) {\n    return null;\n  }\n\n  // Allow the callers to control the unique policy name\n  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.\n  // Policy creation with duplicate names throws in Trusted Types.\n  let suffix = null;\n  const ATTR_NAME = 'data-tt-policy-suffix';\n  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {\n    suffix = purifyHostElement.getAttribute(ATTR_NAME);\n  }\n\n  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');\n\n  try {\n    return trustedTypes.createPolicy(policyName, {\n      createHTML(html) {\n        return html;\n      },\n      createScriptURL(scriptUrl) {\n        return scriptUrl;\n      },\n    });\n  } catch (_) {\n    // Policy creation failed (most likely another DOMPurify script has\n    // already run). Skip creating the policy, as this will only cause errors\n    // if TT are enforced.\n    console.warn(\n      'TrustedTypes policy ' + policyName + ' could not be created.'\n    );\n    return null;\n  }\n};\n\nconst _createHooksMap = function (): HooksMap {\n  return {\n    afterSanitizeAttributes: [],\n    afterSanitizeElements: [],\n    afterSanitizeShadowDOM: [],\n    beforeSanitizeAttributes: [],\n    beforeSanitizeElements: [],\n    beforeSanitizeShadowDOM: [],\n    uponSanitizeAttribute: [],\n    uponSanitizeElement: [],\n    uponSanitizeShadowNode: [],\n  };\n};\n\nfunction createDOMPurify(window: WindowLike = getGlobal()): DOMPurify {\n  const DOMPurify: DOMPurify = (root: WindowLike) => createDOMPurify(root);\n\n  DOMPurify.version = VERSION;\n\n  DOMPurify.removed = [];\n\n  if (\n    !window ||\n    !window.document ||\n    window.document.nodeType !== NODE_TYPE.document ||\n    !window.Element\n  ) {\n    // Not running in a browser, provide a factory function\n    // so that you can pass your own Window\n    DOMPurify.isSupported = false;\n\n    return DOMPurify;\n  }\n\n  let { document } = window;\n\n  const originalDocument = document;\n  const currentScript: HTMLScriptElement =\n    originalDocument.currentScript as HTMLScriptElement;\n  const {\n    DocumentFragment,\n    HTMLTemplateElement,\n    Node,\n    Element,\n    NodeFilter,\n    NamedNodeMap = window.NamedNodeMap || (window as any).MozNamedAttrMap,\n    HTMLFormElement,\n    DOMParser,\n    trustedTypes,\n  } = window;\n\n  const ElementPrototype = Element.prototype;\n\n  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');\n  const remove = lookupGetter(ElementPrototype, 'remove');\n  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');\n  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');\n  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');\n\n  // As per issue #47, the web-components registry is inherited by a\n  // new document created via createHTMLDocument. As per the spec\n  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)\n  // a new empty registry is used when creating a template contents owner\n  // document, so we use that as our parent document to ensure nothing\n  // is inherited.\n  if (typeof HTMLTemplateElement === 'function') {\n    const template = document.createElement('template');\n    if (template.content && template.content.ownerDocument) {\n      document = template.content.ownerDocument;\n    }\n  }\n\n  let trustedTypesPolicy;\n  let emptyHTML = '';\n\n  const {\n    implementation,\n    createNodeIterator,\n    createDocumentFragment,\n    getElementsByTagName,\n  } = document;\n  const { importNode } = originalDocument;\n\n  let hooks = _createHooksMap();\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  DOMPurify.isSupported =\n    typeof entries === 'function' &&\n    typeof getParentNode === 'function' &&\n    implementation &&\n    implementation.createHTMLDocument !== undefined;\n\n  const {\n    MUSTACHE_EXPR,\n    ERB_EXPR,\n    TMPLIT_EXPR,\n    DATA_ATTR,\n    ARIA_ATTR,\n    IS_SCRIPT_OR_DATA,\n    ATTR_WHITESPACE,\n    CUSTOM_ELEMENT,\n  } = EXPRESSIONS;\n\n  let { IS_ALLOWED_URI } = EXPRESSIONS;\n\n  /**\n   * We consider the elements and attributes below to be safe. Ideally\n   * don't add any new ones but feel free to remove unwanted ones.\n   */\n\n  /* allowed element names */\n  let ALLOWED_TAGS = null;\n  const DEFAULT_ALLOWED_TAGS = addToSet({}, [\n    ...TAGS.html,\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.mathMl,\n    ...TAGS.text,\n  ]);\n\n  /* Allowed attribute names */\n  let ALLOWED_ATTR = null;\n  const DEFAULT_ALLOWED_ATTR = addToSet({}, [\n    ...ATTRS.html,\n    ...ATTRS.svg,\n    ...ATTRS.mathMl,\n    ...ATTRS.xml,\n  ]);\n\n  /*\n   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.\n   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)\n   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)\n   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.\n   */\n  let CUSTOM_ELEMENT_HANDLING = Object.seal(\n    create(null, {\n      tagNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      attributeNameCheck: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: null,\n      },\n      allowCustomizedBuiltInElements: {\n        writable: true,\n        configurable: false,\n        enumerable: true,\n        value: false,\n      },\n    })\n  );\n\n  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */\n  let FORBID_TAGS = null;\n\n  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */\n  let FORBID_ATTR = null;\n\n  /* Decide if ARIA attributes are okay */\n  let ALLOW_ARIA_ATTR = true;\n\n  /* Decide if custom data attributes are okay */\n  let ALLOW_DATA_ATTR = true;\n\n  /* Decide if unknown protocols are okay */\n  let ALLOW_UNKNOWN_PROTOCOLS = false;\n\n  /* Decide if self-closing tags in attributes are allowed.\n   * Usually removed due to a mXSS issue in jQuery 3.0 */\n  let ALLOW_SELF_CLOSE_IN_ATTR = true;\n\n  /* Output should be safe for common template engines.\n   * This means, DOMPurify removes data attributes, mustaches and ERB\n   */\n  let SAFE_FOR_TEMPLATES = false;\n\n  /* Output should be safe even for XML used within HTML and alike.\n   * This means, DOMPurify removes comments when containing risky content.\n   */\n  let SAFE_FOR_XML = true;\n\n  /* Decide if document with <html>... should be returned */\n  let WHOLE_DOCUMENT = false;\n\n  /* Track whether config is already set on this instance of DOMPurify. */\n  let SET_CONFIG = false;\n\n  /* Decide if all elements (e.g. style, script) must be children of\n   * document.body. By default, browsers might move them to document.head */\n  let FORCE_BODY = false;\n\n  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html\n   * string (or a TrustedHTML object if Trusted Types are supported).\n   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead\n   */\n  let RETURN_DOM = false;\n\n  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html\n   * string  (or a TrustedHTML object if Trusted Types are supported) */\n  let RETURN_DOM_FRAGMENT = false;\n\n  /* Try to return a Trusted Type object instead of a string, return a string in\n   * case Trusted Types are not supported  */\n  let RETURN_TRUSTED_TYPE = false;\n\n  /* Output should be free from DOM clobbering attacks?\n   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.\n   */\n  let SANITIZE_DOM = true;\n\n  /* Achieve full DOM Clobbering protection by isolating the namespace of named\n   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.\n   *\n   * HTML/DOM spec rules that enable DOM Clobbering:\n   *   - Named Access on Window (§7.3.3)\n   *   - DOM Tree Accessors (§3.1.5)\n   *   - Form Element Parent-Child Relations (§4.10.3)\n   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)\n   *   - HTMLCollection (§4.2.10.2)\n   *\n   * Namespace isolation is implemented by prefixing `id` and `name` attributes\n   * with a constant string, i.e., `user-content-`\n   */\n  let SANITIZE_NAMED_PROPS = false;\n  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';\n\n  /* Keep element content when removing element? */\n  let KEEP_CONTENT = true;\n\n  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead\n   * of importing it into a new Document and returning a sanitized copy */\n  let IN_PLACE = false;\n\n  /* Allow usage of profiles like html, svg and mathMl */\n  let USE_PROFILES: UseProfilesConfig | false = {};\n\n  /* Tags to ignore content of when KEEP_CONTENT is true */\n  let FORBID_CONTENTS = null;\n  const DEFAULT_FORBID_CONTENTS = addToSet({}, [\n    'annotation-xml',\n    'audio',\n    'colgroup',\n    'desc',\n    'foreignobject',\n    'head',\n    'iframe',\n    'math',\n    'mi',\n    'mn',\n    'mo',\n    'ms',\n    'mtext',\n    'noembed',\n    'noframes',\n    'noscript',\n    'plaintext',\n    'script',\n    'style',\n    'svg',\n    'template',\n    'thead',\n    'title',\n    'video',\n    'xmp',\n  ]);\n\n  /* Tags that are safe for data: URIs */\n  let DATA_URI_TAGS = null;\n  const DEFAULT_DATA_URI_TAGS = addToSet({}, [\n    'audio',\n    'video',\n    'img',\n    'source',\n    'image',\n    'track',\n  ]);\n\n  /* Attributes safe for values like \"javascript:\" */\n  let URI_SAFE_ATTRIBUTES = null;\n  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, [\n    'alt',\n    'class',\n    'for',\n    'id',\n    'label',\n    'name',\n    'pattern',\n    'placeholder',\n    'role',\n    'summary',\n    'title',\n    'value',\n    'style',\n    'xmlns',\n  ]);\n\n  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';\n  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';\n  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\n  /* Document namespace */\n  let NAMESPACE = HTML_NAMESPACE;\n  let IS_EMPTY_INPUT = false;\n\n  /* Allowed XHTML+XML namespaces */\n  let ALLOWED_NAMESPACES = null;\n  const DEFAULT_ALLOWED_NAMESPACES = addToSet(\n    {},\n    [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE],\n    stringToString\n  );\n\n  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, [\n    'mi',\n    'mo',\n    'mn',\n    'ms',\n    'mtext',\n  ]);\n\n  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);\n\n  // Certain elements are allowed in both SVG and HTML\n  // namespace. We need to specify them explicitly\n  // so that they don't get erroneously deleted from\n  // HTML namespace.\n  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, [\n    'title',\n    'style',\n    'font',\n    'a',\n    'script',\n  ]);\n\n  /* Parsing of strict XHTML documents */\n  let PARSER_MEDIA_TYPE: null | DOMParserSupportedType = null;\n  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];\n  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';\n  let transformCaseFunc: null | Parameters<typeof addToSet>[2] = null;\n\n  /* Keep a reference to config to pass to hooks */\n  let CONFIG: Config | null = null;\n\n  /* Ideally, do not touch anything below this line */\n  /* ______________________________________________ */\n\n  const formElement = document.createElement('form');\n\n  const isRegexOrFunction = function (\n    testValue: unknown\n  ): testValue is Function | RegExp {\n    return testValue instanceof RegExp || testValue instanceof Function;\n  };\n\n  /**\n   * _parseConfig\n   *\n   * @param cfg optional config literal\n   */\n  // eslint-disable-next-line complexity\n  const _parseConfig = function (cfg: Config = {}): void {\n    if (CONFIG && CONFIG === cfg) {\n      return;\n    }\n\n    /* Shield configuration object from tampering */\n    if (!cfg || typeof cfg !== 'object') {\n      cfg = {};\n    }\n\n    /* Shield configuration object from prototype pollution */\n    cfg = clone(cfg);\n\n    PARSER_MEDIA_TYPE =\n      // eslint-disable-next-line unicorn/prefer-includes\n      SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1\n        ? DEFAULT_PARSER_MEDIA_TYPE\n        : cfg.PARSER_MEDIA_TYPE;\n\n    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.\n    transformCaseFunc =\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml'\n        ? stringToString\n        : stringToLowerCase;\n\n    /* Set configuration parameters */\n    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS')\n      ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc)\n      : DEFAULT_ALLOWED_TAGS;\n    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR')\n      ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc)\n      : DEFAULT_ALLOWED_ATTR;\n    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES')\n      ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString)\n      : DEFAULT_ALLOWED_NAMESPACES;\n    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR')\n      ? addToSet(\n          clone(DEFAULT_URI_SAFE_ATTRIBUTES),\n          cfg.ADD_URI_SAFE_ATTR,\n          transformCaseFunc\n        )\n      : DEFAULT_URI_SAFE_ATTRIBUTES;\n    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS')\n      ? addToSet(\n          clone(DEFAULT_DATA_URI_TAGS),\n          cfg.ADD_DATA_URI_TAGS,\n          transformCaseFunc\n        )\n      : DEFAULT_DATA_URI_TAGS;\n    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS')\n      ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc)\n      : DEFAULT_FORBID_CONTENTS;\n    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS')\n      ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc)\n      : clone({});\n    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR')\n      ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc)\n      : clone({});\n    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES')\n      ? cfg.USE_PROFILES\n      : false;\n    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true\n    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true\n    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false\n    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true\n    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false\n    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true\n    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false\n    RETURN_DOM = cfg.RETURN_DOM || false; // Default false\n    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false\n    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false\n    FORCE_BODY = cfg.FORCE_BODY || false; // Default false\n    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true\n    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false\n    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true\n    IN_PLACE = cfg.IN_PLACE || false; // Default false\n    IS_ALLOWED_URI = cfg.ALLOWED_URI_REGEXP || EXPRESSIONS.IS_ALLOWED_URI;\n    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;\n    MATHML_TEXT_INTEGRATION_POINTS =\n      cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;\n    HTML_INTEGRATION_POINTS =\n      cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;\n\n    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.tagNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)\n    ) {\n      CUSTOM_ELEMENT_HANDLING.attributeNameCheck =\n        cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;\n    }\n\n    if (\n      cfg.CUSTOM_ELEMENT_HANDLING &&\n      typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements ===\n        'boolean'\n    ) {\n      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements =\n        cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;\n    }\n\n    if (SAFE_FOR_TEMPLATES) {\n      ALLOW_DATA_ATTR = false;\n    }\n\n    if (RETURN_DOM_FRAGMENT) {\n      RETURN_DOM = true;\n    }\n\n    /* Parse profile info */\n    if (USE_PROFILES) {\n      ALLOWED_TAGS = addToSet({}, TAGS.text);\n      ALLOWED_ATTR = [];\n      if (USE_PROFILES.html === true) {\n        addToSet(ALLOWED_TAGS, TAGS.html);\n        addToSet(ALLOWED_ATTR, ATTRS.html);\n      }\n\n      if (USE_PROFILES.svg === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.svgFilters === true) {\n        addToSet(ALLOWED_TAGS, TAGS.svgFilters);\n        addToSet(ALLOWED_ATTR, ATTRS.svg);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n\n      if (USE_PROFILES.mathMl === true) {\n        addToSet(ALLOWED_TAGS, TAGS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.mathMl);\n        addToSet(ALLOWED_ATTR, ATTRS.xml);\n      }\n    }\n\n    /* Merge configuration parameters */\n    if (cfg.ADD_TAGS) {\n      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {\n        ALLOWED_TAGS = clone(ALLOWED_TAGS);\n      }\n\n      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);\n    }\n\n    if (cfg.ADD_ATTR) {\n      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {\n        ALLOWED_ATTR = clone(ALLOWED_ATTR);\n      }\n\n      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.ADD_URI_SAFE_ATTR) {\n      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);\n    }\n\n    if (cfg.FORBID_CONTENTS) {\n      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {\n        FORBID_CONTENTS = clone(FORBID_CONTENTS);\n      }\n\n      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);\n    }\n\n    /* Add #text in case KEEP_CONTENT is set to true */\n    if (KEEP_CONTENT) {\n      ALLOWED_TAGS['#text'] = true;\n    }\n\n    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */\n    if (WHOLE_DOCUMENT) {\n      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);\n    }\n\n    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */\n    if (ALLOWED_TAGS.table) {\n      addToSet(ALLOWED_TAGS, ['tbody']);\n      delete FORBID_TAGS.tbody;\n    }\n\n    if (cfg.TRUSTED_TYPES_POLICY) {\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createHTML\" hook.'\n        );\n      }\n\n      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {\n        throw typeErrorCreate(\n          'TRUSTED_TYPES_POLICY configuration option must provide a \"createScriptURL\" hook.'\n        );\n      }\n\n      // Overwrite existing TrustedTypes policy.\n      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;\n\n      // Sign local variables required by `sanitize`.\n      emptyHTML = trustedTypesPolicy.createHTML('');\n    } else {\n      // Uninitialized policy, attempt to initialize the internal dompurify policy.\n      if (trustedTypesPolicy === undefined) {\n        trustedTypesPolicy = _createTrustedTypesPolicy(\n          trustedTypes,\n          currentScript\n        );\n      }\n\n      // If creating the internal policy succeeded sign internal variables.\n      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {\n        emptyHTML = trustedTypesPolicy.createHTML('');\n      }\n    }\n\n    // Prevent further manipulation of configuration.\n    // Not available in IE8, Safari 5, etc.\n    if (freeze) {\n      freeze(cfg);\n    }\n\n    CONFIG = cfg;\n  };\n\n  /* Keep track of all possible SVG and MathML tags\n   * so that we can perform the namespace checks\n   * correctly. */\n  const ALL_SVG_TAGS = addToSet({}, [\n    ...TAGS.svg,\n    ...TAGS.svgFilters,\n    ...TAGS.svgDisallowed,\n  ]);\n  const ALL_MATHML_TAGS = addToSet({}, [\n    ...TAGS.mathMl,\n    ...TAGS.mathMlDisallowed,\n  ]);\n\n  /**\n   * @param element a DOM element whose namespace is being checked\n   * @returns Return false if the element has a\n   *  namespace that a spec-compliant parser would never\n   *  return. Return true otherwise.\n   */\n  const _checkValidNamespace = function (element: Element): boolean {\n    let parent = getParentNode(element);\n\n    // In JSDOM, if we're inside shadow DOM, then parentNode\n    // can be null. We just simulate parent in this case.\n    if (!parent || !parent.tagName) {\n      parent = {\n        namespaceURI: NAMESPACE,\n        tagName: 'template',\n      };\n    }\n\n    const tagName = stringToLowerCase(element.tagName);\n    const parentTagName = stringToLowerCase(parent.tagName);\n\n    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {\n      return false;\n    }\n\n    if (element.namespaceURI === SVG_NAMESPACE) {\n      // The only way to switch from HTML namespace to SVG\n      // is via <svg>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'svg';\n      }\n\n      // The only way to switch from MathML to SVG is via`\n      // svg if parent is either <annotation-xml> or MathML\n      // text integration points.\n      if (parent.namespaceURI === MATHML_NAMESPACE) {\n        return (\n          tagName === 'svg' &&\n          (parentTagName === 'annotation-xml' ||\n            MATHML_TEXT_INTEGRATION_POINTS[parentTagName])\n        );\n      }\n\n      // We only allow elements that are defined in SVG\n      // spec. All others are disallowed in SVG namespace.\n      return Boolean(ALL_SVG_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === MATHML_NAMESPACE) {\n      // The only way to switch from HTML namespace to MathML\n      // is via <math>. If it happens via any other tag, then\n      // it should be killed.\n      if (parent.namespaceURI === HTML_NAMESPACE) {\n        return tagName === 'math';\n      }\n\n      // The only way to switch from SVG to MathML is via\n      // <math> and HTML integration points\n      if (parent.namespaceURI === SVG_NAMESPACE) {\n        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];\n      }\n\n      // We only allow elements that are defined in MathML\n      // spec. All others are disallowed in MathML namespace.\n      return Boolean(ALL_MATHML_TAGS[tagName]);\n    }\n\n    if (element.namespaceURI === HTML_NAMESPACE) {\n      // The only way to switch from SVG to HTML is via\n      // HTML integration points, and from MathML to HTML\n      // is via MathML text integration points\n      if (\n        parent.namespaceURI === SVG_NAMESPACE &&\n        !HTML_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      if (\n        parent.namespaceURI === MATHML_NAMESPACE &&\n        !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]\n      ) {\n        return false;\n      }\n\n      // We disallow tags that are specific for MathML\n      // or SVG and should never appear in HTML namespace\n      return (\n        !ALL_MATHML_TAGS[tagName] &&\n        (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName])\n      );\n    }\n\n    // For XHTML and XML documents that support custom namespaces\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      ALLOWED_NAMESPACES[element.namespaceURI]\n    ) {\n      return true;\n    }\n\n    // The code should never reach this place (this means\n    // that the element somehow got namespace that is not\n    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).\n    // Return false just in case.\n    return false;\n  };\n\n  /**\n   * _forceRemove\n   *\n   * @param node a DOM node\n   */\n  const _forceRemove = function (node: Node): void {\n    arrayPush(DOMPurify.removed, { element: node });\n\n    try {\n      // eslint-disable-next-line unicorn/prefer-dom-node-remove\n      getParentNode(node).removeChild(node);\n    } catch (_) {\n      remove(node);\n    }\n  };\n\n  /**\n   * _removeAttribute\n   *\n   * @param name an Attribute name\n   * @param element a DOM node\n   */\n  const _removeAttribute = function (name: string, element: Element): void {\n    try {\n      arrayPush(DOMPurify.removed, {\n        attribute: element.getAttributeNode(name),\n        from: element,\n      });\n    } catch (_) {\n      arrayPush(DOMPurify.removed, {\n        attribute: null,\n        from: element,\n      });\n    }\n\n    element.removeAttribute(name);\n\n    // We void attribute values for unremovable \"is\" attributes\n    if (name === 'is') {\n      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {\n        try {\n          _forceRemove(element);\n        } catch (_) {}\n      } else {\n        try {\n          element.setAttribute(name, '');\n        } catch (_) {}\n      }\n    }\n  };\n\n  /**\n   * _initDocument\n   *\n   * @param dirty - a string of dirty markup\n   * @return a DOM, filled with the dirty markup\n   */\n  const _initDocument = function (dirty: string): Document {\n    /* Create a HTML document */\n    let doc = null;\n    let leadingWhitespace = null;\n\n    if (FORCE_BODY) {\n      dirty = '<remove></remove>' + dirty;\n    } else {\n      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */\n      const matches = stringMatch(dirty, /^[\\r\\n\\t ]+/);\n      leadingWhitespace = matches && matches[0];\n    }\n\n    if (\n      PARSER_MEDIA_TYPE === 'application/xhtml+xml' &&\n      NAMESPACE === HTML_NAMESPACE\n    ) {\n      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)\n      dirty =\n        '<html xmlns=\"http://www.w3.org/1999/xhtml\"><head></head><body>' +\n        dirty +\n        '</body></html>';\n    }\n\n    const dirtyPayload = trustedTypesPolicy\n      ? trustedTypesPolicy.createHTML(dirty)\n      : dirty;\n    /*\n     * Use the DOMParser API by default, fallback later if needs be\n     * DOMParser not work for svg when has multiple root element.\n     */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      try {\n        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);\n      } catch (_) {}\n    }\n\n    /* Use createHTMLDocument in case DOMParser is not available */\n    if (!doc || !doc.documentElement) {\n      doc = implementation.createDocument(NAMESPACE, 'template', null);\n      try {\n        doc.documentElement.innerHTML = IS_EMPTY_INPUT\n          ? emptyHTML\n          : dirtyPayload;\n      } catch (_) {\n        // Syntax error if dirtyPayload is invalid xml\n      }\n    }\n\n    const body = doc.body || doc.documentElement;\n\n    if (dirty && leadingWhitespace) {\n      body.insertBefore(\n        document.createTextNode(leadingWhitespace),\n        body.childNodes[0] || null\n      );\n    }\n\n    /* Work on whole document or just its body */\n    if (NAMESPACE === HTML_NAMESPACE) {\n      return getElementsByTagName.call(\n        doc,\n        WHOLE_DOCUMENT ? 'html' : 'body'\n      )[0];\n    }\n\n    return WHOLE_DOCUMENT ? doc.documentElement : body;\n  };\n\n  /**\n   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.\n   *\n   * @param root The root element or node to start traversing on.\n   * @return The created NodeIterator\n   */\n  const _createNodeIterator = function (root: Node): NodeIterator {\n    return createNodeIterator.call(\n      root.ownerDocument || root,\n      root,\n      // eslint-disable-next-line no-bitwise\n      NodeFilter.SHOW_ELEMENT |\n        NodeFilter.SHOW_COMMENT |\n        NodeFilter.SHOW_TEXT |\n        NodeFilter.SHOW_PROCESSING_INSTRUCTION |\n        NodeFilter.SHOW_CDATA_SECTION,\n      null\n    );\n  };\n\n  /**\n   * _isClobbered\n   *\n   * @param element element to check for clobbering attacks\n   * @return true if clobbered, false if safe\n   */\n  const _isClobbered = function (element: Element): boolean {\n    return (\n      element instanceof HTMLFormElement &&\n      (typeof element.nodeName !== 'string' ||\n        typeof element.textContent !== 'string' ||\n        typeof element.removeChild !== 'function' ||\n        !(element.attributes instanceof NamedNodeMap) ||\n        typeof element.removeAttribute !== 'function' ||\n        typeof element.setAttribute !== 'function' ||\n        typeof element.namespaceURI !== 'string' ||\n        typeof element.insertBefore !== 'function' ||\n        typeof element.hasChildNodes !== 'function')\n    );\n  };\n\n  /**\n   * Checks whether the given object is a DOM node.\n   *\n   * @param value object to check whether it's a DOM node\n   * @return true is object is a DOM node\n   */\n  const _isNode = function (value: unknown): value is Node {\n    return typeof Node === 'function' && value instanceof Node;\n  };\n\n  function _executeHooks<\n    T extends\n      | NodeHook\n      | ElementHook\n      | DocumentFragmentHook\n      | UponSanitizeElementHook\n      | UponSanitizeAttributeHook\n  >(hooks: T[], currentNode: Parameters<T>[0], data: Parameters<T>[1]): void {\n    arrayForEach(hooks, (hook) => {\n      hook.call(DOMPurify, currentNode, data, CONFIG);\n    });\n  }\n\n  /**\n   * _sanitizeElements\n   *\n   * @protect nodeName\n   * @protect textContent\n   * @protect removeChild\n   * @param currentNode to check for permission to exist\n   * @return true if node was killed, false if left alive\n   */\n  const _sanitizeElements = function (currentNode: any): boolean {\n    let content = null;\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);\n\n    /* Check if element is clobbered or can clobber */\n    if (_isClobbered(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Now let's check the element's type and name */\n    const tagName = transformCaseFunc(currentNode.nodeName);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.uponSanitizeElement, currentNode, {\n      tagName,\n      allowedTags: ALLOWED_TAGS,\n    });\n\n    /* Detect mXSS attempts abusing namespace confusion */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.hasChildNodes() &&\n      !_isNode(currentNode.firstElementChild) &&\n      regExpTest(/<[/\\w!]/g, currentNode.innerHTML) &&\n      regExpTest(/<[/\\w!]/g, currentNode.textContent)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any occurrence of processing instructions */\n    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove any kind of possibly harmful comments */\n    if (\n      SAFE_FOR_XML &&\n      currentNode.nodeType === NODE_TYPE.comment &&\n      regExpTest(/<[/\\w]/g, currentNode.data)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Remove element if anything forbids its presence */\n    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n      /* Check if we have a custom element to handle */\n      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n          regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)\n        ) {\n          return false;\n        }\n\n        if (\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n          CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)\n        ) {\n          return false;\n        }\n      }\n\n      /* Keep content except for bad-listed elements */\n      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {\n        const parentNode = getParentNode(currentNode) || currentNode.parentNode;\n        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;\n\n        if (childNodes && parentNode) {\n          const childCount = childNodes.length;\n\n          for (let i = childCount - 1; i >= 0; --i) {\n            const childClone = cloneNode(childNodes[i], true);\n            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;\n            parentNode.insertBefore(childClone, getNextSibling(currentNode));\n          }\n        }\n      }\n\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Check whether element has a valid namespace */\n    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Make sure that older browsers don't get fallback-tag mXSS */\n    if (\n      (tagName === 'noscript' ||\n        tagName === 'noembed' ||\n        tagName === 'noframes') &&\n      regExpTest(/<\\/no(script|embed|frames)/i, currentNode.innerHTML)\n    ) {\n      _forceRemove(currentNode);\n      return true;\n    }\n\n    /* Sanitize element content to be template-safe */\n    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {\n      /* Get the element's text content */\n      content = currentNode.textContent;\n\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n        content = stringReplace(content, expr, ' ');\n      });\n\n      if (currentNode.textContent !== content) {\n        arrayPush(DOMPurify.removed, { element: currentNode.cloneNode() });\n        currentNode.textContent = content;\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeElements, currentNode, null);\n\n    return false;\n  };\n\n  /**\n   * _isValidAttribute\n   *\n   * @param lcTag Lowercase tag name of containing element.\n   * @param lcName Lowercase attribute name.\n   * @param value Attribute value.\n   * @return Returns true if `value` is valid, otherwise false.\n   */\n  // eslint-disable-next-line complexity\n  const _isValidAttribute = function (\n    lcTag: string,\n    lcName: string,\n    value: string\n  ): boolean {\n    /* Make sure attribute cannot clobber */\n    if (\n      SANITIZE_DOM &&\n      (lcName === 'id' || lcName === 'name') &&\n      (value in document || value in formElement)\n    ) {\n      return false;\n    }\n\n    /* Allow valid data-* attributes: At least one character after \"-\"\n        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)\n        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)\n        We don't need to check the value; it's always URI safe. */\n    if (\n      ALLOW_DATA_ATTR &&\n      !FORBID_ATTR[lcName] &&\n      regExpTest(DATA_ATTR, lcName)\n    ) {\n      // This attribute is safe\n    } else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) {\n      // This attribute is safe\n      /* Otherwise, check the name is permitted */\n    } else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {\n      if (\n        // First condition does a very basic check if a) it's basically a valid custom element tagname AND\n        // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck\n        (_isBasicCustomElement(lcTag) &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag))) &&\n          ((CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName)) ||\n            (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)))) ||\n        // Alternative, second condition checks if it's an `is`-attribute, AND\n        // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck\n        (lcName === 'is' &&\n          CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements &&\n          ((CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp &&\n            regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value)) ||\n            (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function &&\n              CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))))\n      ) {\n        // If user has supplied a regexp or function in CUSTOM_ELEMENT_HANDLING.tagNameCheck, we need to also allow derived custom elements using the same tagName test.\n        // Additionally, we need to allow attributes passing the CUSTOM_ELEMENT_HANDLING.attributeNameCheck user has configured, as custom elements can define these at their own discretion.\n      } else {\n        return false;\n      }\n      /* Check value is safe. First, is attr inert? If so, is safe */\n    } else if (URI_SAFE_ATTRIBUTES[lcName]) {\n      // This attribute is safe\n      /* Check no script, data or unknown possibly unsafe URI\n        unless we know URI values are safe for that attribute */\n    } else if (\n      regExpTest(IS_ALLOWED_URI, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Keep image data URIs alive if src/xlink:href is allowed */\n      /* Further prevent gadget XSS for dynamically built script tags */\n    } else if (\n      (lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') &&\n      lcTag !== 'script' &&\n      stringIndexOf(value, 'data:') === 0 &&\n      DATA_URI_TAGS[lcTag]\n    ) {\n      // This attribute is safe\n      /* Allow unknown protocols: This provides support for links that\n        are handled by protocol handlers which may be unknown ahead of\n        time, e.g. fb:, spotify: */\n    } else if (\n      ALLOW_UNKNOWN_PROTOCOLS &&\n      !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))\n    ) {\n      // This attribute is safe\n      /* Check for binary attributes */\n    } else if (value) {\n      return false;\n    } else {\n      // Binary attributes are safe at this point\n      /* Anything else, presume unsafe, do not add it back */\n    }\n\n    return true;\n  };\n\n  /**\n   * _isBasicCustomElement\n   * checks if at least one dash is included in tagName, and it's not the first char\n   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name\n   *\n   * @param tagName name of the tag of the node to sanitize\n   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.\n   */\n  const _isBasicCustomElement = function (tagName: string): RegExpMatchArray {\n    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);\n  };\n\n  /**\n   * _sanitizeAttributes\n   *\n   * @protect attributes\n   * @protect nodeName\n   * @protect removeAttribute\n   * @protect setAttribute\n   *\n   * @param currentNode to sanitize\n   */\n  const _sanitizeAttributes = function (currentNode: Element): void {\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);\n\n    const { attributes } = currentNode;\n\n    /* Check if we have attributes; if not we might have a text node */\n    if (!attributes || _isClobbered(currentNode)) {\n      return;\n    }\n\n    const hookEvent = {\n      attrName: '',\n      attrValue: '',\n      keepAttr: true,\n      allowedAttributes: ALLOWED_ATTR,\n      forceKeepAttr: undefined,\n    };\n    let l = attributes.length;\n\n    /* Go backwards over all attributes; safely remove bad ones */\n    while (l--) {\n      const attr = attributes[l];\n      const { name, namespaceURI, value: attrValue } = attr;\n      const lcName = transformCaseFunc(name);\n\n      const initValue = attrValue;\n      let value = name === 'value' ? initValue : stringTrim(initValue);\n\n      /* Execute a hook if present */\n      hookEvent.attrName = lcName;\n      hookEvent.attrValue = value;\n      hookEvent.keepAttr = true;\n      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set\n      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);\n      value = hookEvent.attrValue;\n\n      /* Full DOM Clobbering protection via namespace isolation,\n       * Prefix id and name attributes with `user-content-`\n       */\n      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {\n        // Remove the attribute with this value\n        _removeAttribute(name, currentNode);\n\n        // Prefix the value and later re-create the attribute with the sanitized value\n        value = SANITIZE_NAMED_PROPS_PREFIX + value;\n      }\n\n      /* Work around a security issue with comments inside attributes */\n      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\\/(style|title)/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (hookEvent.forceKeepAttr) {\n        continue;\n      }\n\n      /* Did the hooks approve of the attribute? */\n      if (!hookEvent.keepAttr) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Work around a security issue in jQuery 3.0 */\n      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\\/>/i, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Sanitize attribute content to be template-safe */\n      if (SAFE_FOR_TEMPLATES) {\n        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n          value = stringReplace(value, expr, ' ');\n        });\n      }\n\n      /* Is `value` valid for this attribute? */\n      const lcTag = transformCaseFunc(currentNode.nodeName);\n      if (!_isValidAttribute(lcTag, lcName, value)) {\n        _removeAttribute(name, currentNode);\n        continue;\n      }\n\n      /* Handle attributes that require Trusted Types */\n      if (\n        trustedTypesPolicy &&\n        typeof trustedTypes === 'object' &&\n        typeof trustedTypes.getAttributeType === 'function'\n      ) {\n        if (namespaceURI) {\n          /* Namespaces are not yet supported, see https://bugs.chromium.org/p/chromium/issues/detail?id=1305293 */\n        } else {\n          switch (trustedTypes.getAttributeType(lcTag, lcName)) {\n            case 'TrustedHTML': {\n              value = trustedTypesPolicy.createHTML(value);\n              break;\n            }\n\n            case 'TrustedScriptURL': {\n              value = trustedTypesPolicy.createScriptURL(value);\n              break;\n            }\n\n            default: {\n              break;\n            }\n          }\n        }\n      }\n\n      /* Handle invalid data-* attribute set by try-catching it */\n      if (value !== initValue) {\n        try {\n          if (namespaceURI) {\n            currentNode.setAttributeNS(namespaceURI, name, value);\n          } else {\n            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. \"x-schema\". */\n            currentNode.setAttribute(name, value);\n          }\n\n          if (_isClobbered(currentNode)) {\n            _forceRemove(currentNode);\n          } else {\n            arrayPop(DOMPurify.removed);\n          }\n        } catch (_) {\n          _removeAttribute(name, currentNode);\n        }\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);\n  };\n\n  /**\n   * _sanitizeShadowDOM\n   *\n   * @param fragment to iterate over recursively\n   */\n  const _sanitizeShadowDOM = function (fragment: DocumentFragment): void {\n    let shadowNode = null;\n    const shadowIterator = _createNodeIterator(fragment);\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);\n\n    while ((shadowNode = shadowIterator.nextNode())) {\n      /* Execute a hook if present */\n      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);\n\n      /* Sanitize tags and elements */\n      _sanitizeElements(shadowNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(shadowNode);\n\n      /* Deep shadow DOM detected */\n      if (shadowNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(shadowNode.content);\n      }\n    }\n\n    /* Execute a hook if present */\n    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);\n  };\n\n  // eslint-disable-next-line complexity\n  DOMPurify.sanitize = function (dirty, cfg = {}) {\n    let body = null;\n    let importedNode = null;\n    let currentNode = null;\n    let returnNode = null;\n    /* Make sure we have a string to sanitize.\n      DO NOT return early, as this will return the wrong type if\n      the user has requested a DOM object rather than a string */\n    IS_EMPTY_INPUT = !dirty;\n    if (IS_EMPTY_INPUT) {\n      dirty = '<!-->';\n    }\n\n    /* Stringify, in case dirty is an object */\n    if (typeof dirty !== 'string' && !_isNode(dirty)) {\n      if (typeof dirty.toString === 'function') {\n        dirty = dirty.toString();\n        if (typeof dirty !== 'string') {\n          throw typeErrorCreate('dirty is not a string, aborting');\n        }\n      } else {\n        throw typeErrorCreate('toString is not a function');\n      }\n    }\n\n    /* Return dirty HTML if DOMPurify cannot run */\n    if (!DOMPurify.isSupported) {\n      return dirty;\n    }\n\n    /* Assign config vars */\n    if (!SET_CONFIG) {\n      _parseConfig(cfg);\n    }\n\n    /* Clean up removed elements */\n    DOMPurify.removed = [];\n\n    /* Check if dirty is correctly typed for IN_PLACE */\n    if (typeof dirty === 'string') {\n      IN_PLACE = false;\n    }\n\n    if (IN_PLACE) {\n      /* Do some early pre-sanitization to avoid unsafe root nodes */\n      if ((dirty as Node).nodeName) {\n        const tagName = transformCaseFunc((dirty as Node).nodeName);\n        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {\n          throw typeErrorCreate(\n            'root node is forbidden and cannot be sanitized in-place'\n          );\n        }\n      }\n    } else if (dirty instanceof Node) {\n      /* If dirty is a DOM element, append to an empty document to avoid\n         elements being stripped by the parser */\n      body = _initDocument('<!---->');\n      importedNode = body.ownerDocument.importNode(dirty, true);\n      if (\n        importedNode.nodeType === NODE_TYPE.element &&\n        importedNode.nodeName === 'BODY'\n      ) {\n        /* Node is already a body, use as is */\n        body = importedNode;\n      } else if (importedNode.nodeName === 'HTML') {\n        body = importedNode;\n      } else {\n        // eslint-disable-next-line unicorn/prefer-dom-node-append\n        body.appendChild(importedNode);\n      }\n    } else {\n      /* Exit directly if we have nothing to do */\n      if (\n        !RETURN_DOM &&\n        !SAFE_FOR_TEMPLATES &&\n        !WHOLE_DOCUMENT &&\n        // eslint-disable-next-line unicorn/prefer-includes\n        dirty.indexOf('<') === -1\n      ) {\n        return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n          ? trustedTypesPolicy.createHTML(dirty)\n          : dirty;\n      }\n\n      /* Initialize the document to work on */\n      body = _initDocument(dirty);\n\n      /* Check we have a DOM node from the data */\n      if (!body) {\n        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';\n      }\n    }\n\n    /* Remove first element node (ours) if FORCE_BODY is set */\n    if (body && FORCE_BODY) {\n      _forceRemove(body.firstChild);\n    }\n\n    /* Get node iterator */\n    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);\n\n    /* Now start iterating over the created document */\n    while ((currentNode = nodeIterator.nextNode())) {\n      /* Sanitize tags and elements */\n      _sanitizeElements(currentNode);\n\n      /* Check attributes next */\n      _sanitizeAttributes(currentNode);\n\n      /* Shadow DOM detected, sanitize it */\n      if (currentNode.content instanceof DocumentFragment) {\n        _sanitizeShadowDOM(currentNode.content);\n      }\n    }\n\n    /* If we sanitized `dirty` in-place, return it. */\n    if (IN_PLACE) {\n      return dirty;\n    }\n\n    /* Return sanitized string or DOM */\n    if (RETURN_DOM) {\n      if (RETURN_DOM_FRAGMENT) {\n        returnNode = createDocumentFragment.call(body.ownerDocument);\n\n        while (body.firstChild) {\n          // eslint-disable-next-line unicorn/prefer-dom-node-append\n          returnNode.appendChild(body.firstChild);\n        }\n      } else {\n        returnNode = body;\n      }\n\n      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {\n        /*\n          AdoptNode() is not used because internal state is not reset\n          (e.g. the past names map of a HTMLFormElement), this is safe\n          in theory but we would rather not risk another attack vector.\n          The state that is cloned by importNode() is explicitly defined\n          by the specs.\n        */\n        returnNode = importNode.call(originalDocument, returnNode, true);\n      }\n\n      return returnNode;\n    }\n\n    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;\n\n    /* Serialize doctype if allowed */\n    if (\n      WHOLE_DOCUMENT &&\n      ALLOWED_TAGS['!doctype'] &&\n      body.ownerDocument &&\n      body.ownerDocument.doctype &&\n      body.ownerDocument.doctype.name &&\n      regExpTest(EXPRESSIONS.DOCTYPE_NAME, body.ownerDocument.doctype.name)\n    ) {\n      serializedHTML =\n        '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\\n' + serializedHTML;\n    }\n\n    /* Sanitize final string template-safe */\n    if (SAFE_FOR_TEMPLATES) {\n      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], (expr) => {\n        serializedHTML = stringReplace(serializedHTML, expr, ' ');\n      });\n    }\n\n    return trustedTypesPolicy && RETURN_TRUSTED_TYPE\n      ? trustedTypesPolicy.createHTML(serializedHTML)\n      : serializedHTML;\n  };\n\n  DOMPurify.setConfig = function (cfg = {}) {\n    _parseConfig(cfg);\n    SET_CONFIG = true;\n  };\n\n  DOMPurify.clearConfig = function () {\n    CONFIG = null;\n    SET_CONFIG = false;\n  };\n\n  DOMPurify.isValidAttribute = function (tag, attr, value) {\n    /* Initialize shared config vars if necessary. */\n    if (!CONFIG) {\n      _parseConfig({});\n    }\n\n    const lcTag = transformCaseFunc(tag);\n    const lcName = transformCaseFunc(attr);\n    return _isValidAttribute(lcTag, lcName, value);\n  };\n\n  DOMPurify.addHook = function (entryPoint, hookFunction) {\n    if (typeof hookFunction !== 'function') {\n      return;\n    }\n\n    arrayPush(hooks[entryPoint], hookFunction);\n  };\n\n  DOMPurify.removeHook = function (entryPoint, hookFunction) {\n    if (hookFunction !== undefined) {\n      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);\n\n      return index === -1\n        ? undefined\n        : arraySplice(hooks[entryPoint], index, 1)[0];\n    }\n\n    return arrayPop(hooks[entryPoint]);\n  };\n\n  DOMPurify.removeHooks = function (entryPoint) {\n    hooks[entryPoint] = [];\n  };\n\n  DOMPurify.removeAllHooks = function () {\n    hooks = _createHooksMap();\n  };\n\n  return DOMPurify;\n}\n\nexport default createDOMPurify();\n\nexport interface DOMPurify {\n  /**\n   * Creates a DOMPurify instance using the given window-like object. Defaults to `window`.\n   */\n  (root?: WindowLike): DOMPurify;\n\n  /**\n   * Version label, exposed for easier checks\n   * if DOMPurify is up to date or not\n   */\n  version: string;\n\n  /**\n   * Array of elements that DOMPurify removed during sanitation.\n   * Empty if nothing was removed.\n   */\n  removed: Array<RemovedElement | RemovedAttribute>;\n\n  /**\n   * Expose whether this browser supports running the full DOMPurify.\n   */\n  isSupported: boolean;\n\n  /**\n   * Set the configuration once.\n   *\n   * @param cfg configuration object\n   */\n  setConfig(cfg?: Config): void;\n\n  /**\n   * Removes the configuration.\n   */\n  clearConfig(): void;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized TrustedHTML.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_TRUSTED_TYPE: true }\n  ): TrustedHTML;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: Node, cfg: Config & { IN_PLACE: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized DOM node.\n   */\n  sanitize(dirty: string | Node, cfg: Config & { RETURN_DOM: true }): Node;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized document fragment.\n   */\n  sanitize(\n    dirty: string | Node,\n    cfg: Config & { RETURN_DOM_FRAGMENT: true }\n  ): DocumentFragment;\n\n  /**\n   * Provides core sanitation functionality.\n   *\n   * @param dirty string or DOM node\n   * @param cfg object\n   * @returns Sanitized string.\n   */\n  sanitize(dirty: string | Node, cfg?: Config): string;\n\n  /**\n   * Checks if an attribute value is valid.\n   * Uses last set config, if any. Otherwise, uses config defaults.\n   *\n   * @param tag Tag name of containing element.\n   * @param attr Attribute name.\n   * @param value Attribute value.\n   * @returns Returns true if `value` is valid. Otherwise, returns false.\n   */\n  isValidAttribute(tag: string, attr: string, value: string): boolean;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: BasicHookName, hookFunction: NodeHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(entryPoint: ElementHookName, hookFunction: ElementHook): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction: DocumentFragmentHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction: UponSanitizeElementHook\n  ): void;\n\n  /**\n   * Adds a DOMPurify hook.\n   *\n   * @param entryPoint entry point for the hook to add\n   * @param hookFunction function to execute\n   */\n  addHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction: UponSanitizeAttributeHook\n  ): void;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: BasicHookName,\n    hookFunction?: NodeHook\n  ): NodeHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: ElementHookName,\n    hookFunction?: ElementHook\n  ): ElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: DocumentFragmentHookName,\n    hookFunction?: DocumentFragmentHook\n  ): DocumentFragmentHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeElement',\n    hookFunction?: UponSanitizeElementHook\n  ): UponSanitizeElementHook | undefined;\n\n  /**\n   * Remove a DOMPurify hook at a given entryPoint\n   * (pops it from the stack of hooks if hook not specified)\n   *\n   * @param entryPoint entry point for the hook to remove\n   * @param hookFunction optional specific hook to remove\n   * @returns removed hook\n   */\n  removeHook(\n    entryPoint: 'uponSanitizeAttribute',\n    hookFunction?: UponSanitizeAttributeHook\n  ): UponSanitizeAttributeHook | undefined;\n\n  /**\n   * Removes all DOMPurify hooks at a given entryPoint\n   *\n   * @param entryPoint entry point for the hooks to remove\n   */\n  removeHooks(entryPoint: HookName): void;\n\n  /**\n   * Removes all DOMPurify hooks.\n   */\n  removeAllHooks(): void;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedElement {\n  /**\n   * The element that was removed.\n   */\n  element: Node;\n}\n\n/**\n * An element removed by DOMPurify.\n */\nexport interface RemovedAttribute {\n  /**\n   * The attribute that was removed.\n   */\n  attribute: Attr | null;\n\n  /**\n   * The element that the attribute was removed.\n   */\n  from: Node;\n}\n\ntype BasicHookName =\n  | 'beforeSanitizeElements'\n  | 'afterSanitizeElements'\n  | 'uponSanitizeShadowNode';\ntype ElementHookName = 'beforeSanitizeAttributes' | 'afterSanitizeAttributes';\ntype DocumentFragmentHookName =\n  | 'beforeSanitizeShadowDOM'\n  | 'afterSanitizeShadowDOM';\ntype UponSanitizeElementHookName = 'uponSanitizeElement';\ntype UponSanitizeAttributeHookName = 'uponSanitizeAttribute';\n\ninterface HooksMap {\n  beforeSanitizeElements: NodeHook[];\n  afterSanitizeElements: NodeHook[];\n  beforeSanitizeShadowDOM: DocumentFragmentHook[];\n  uponSanitizeShadowNode: NodeHook[];\n  afterSanitizeShadowDOM: DocumentFragmentHook[];\n  beforeSanitizeAttributes: ElementHook[];\n  afterSanitizeAttributes: ElementHook[];\n  uponSanitizeElement: UponSanitizeElementHook[];\n  uponSanitizeAttribute: UponSanitizeAttributeHook[];\n}\n\nexport type HookName =\n  | BasicHookName\n  | ElementHookName\n  | DocumentFragmentHookName\n  | UponSanitizeElementHookName\n  | UponSanitizeAttributeHookName;\n\nexport type NodeHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type ElementHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type DocumentFragmentHook = (\n  this: DOMPurify,\n  currentNode: DocumentFragment,\n  hookEvent: null,\n  config: Config\n) => void;\n\nexport type UponSanitizeElementHook = (\n  this: DOMPurify,\n  currentNode: Node,\n  hookEvent: UponSanitizeElementHookEvent,\n  config: Config\n) => void;\n\nexport type UponSanitizeAttributeHook = (\n  this: DOMPurify,\n  currentNode: Element,\n  hookEvent: UponSanitizeAttributeHookEvent,\n  config: Config\n) => void;\n\nexport interface UponSanitizeElementHookEvent {\n  tagName: string;\n  allowedTags: Record<string, boolean>;\n}\n\nexport interface UponSanitizeAttributeHookEvent {\n  attrName: string;\n  attrValue: string;\n  keepAttr: boolean;\n  allowedAttributes: Record<string, boolean>;\n  forceKeepAttr: boolean | undefined;\n}\n\n/**\n * A `Window`-like object containing the properties and types that DOMPurify requires.\n */\nexport type WindowLike = Pick<\n  typeof globalThis,\n  | 'DocumentFragment'\n  | 'HTMLTemplateElement'\n  | 'Node'\n  | 'Element'\n  | 'NodeFilter'\n  | 'NamedNodeMap'\n  | 'HTMLFormElement'\n  | 'DOMParser'\n> & {\n  document?: Document;\n  MozNamedAttrMap?: typeof window.NamedNodeMap;\n} & Pick<TrustedTypesWindow, 'trustedTypes'>;\n"],"names":["$parcel$interopDefault","a","__esModule","default","$1862cbf67f994e67$exports","resolve","$d55025bea272cdc1$exports","globalThis","self","f","module1","exports","H","Object","defineProperty","be","getOwnPropertyDescriptor","Te","getOwnPropertyNames","we","prototype","hasOwnProperty","kt","e","Hooks","L","Lexer","x","Marked","E","Parser","b","Renderer","$","TextRenderer","_","Tokenizer","S","defaults","w","getDefaults","z","lexer","ht","marked","k","options","it","parse","pt","parseInline","ct","parser","ut","setOptions","ot","use","lt","walkTokens","at","t","get","enumerable","async","breaks","extensions","gfm","hooks","pedantic","renderer","silent","tokenizer","Re","l","n","s","call","value","I","exec","h","source","replace","i","r","m","caret","getRegex","RegExp","codeRemoveIndent","outputLinkReplace","indentCodeCompensation","beginningSpace","endingHash","startingSpaceChar","endingSpaceChar","nonSpaceChar","newLineCharGlobal","tabCharGlobal","multipleSpaceGlobal","blankLine","doubleBlankLine","blockquoteStart","blockquoteSetextReplace","blockquoteSetextReplace2","listReplaceTabs","listReplaceNesting","listIsTask","listReplaceTask","anyLine","hrefBrackets","tableDelimiter","tableAlignChars","tableRowBlankLine","tableAlignRight","tableAlignCenter","tableAlignLeft","startATag","endATag","startPreScriptTag","endPreScriptTag","startAngleBracket","endAngleBracket","pedanticHrefTitle","unicodeAlphaNumeric","escapeTest","escapeReplace","escapeTestNoEncode","escapeReplaceNoEncode","unescapeTest","percentDecode","findPipe","splitPipe","slashPipe","carriageReturn","spaceLine","notSpaceStart","endingNewline","listItemRegex","nextBulletRegex","Math","min","hrRegex","fencesBeginRegex","headingBeginRegex","htmlBeginRegex","O","F","ie","oe","Me","Q","U","Ae","Ee","v","K","Ce","le","X","blockquote","code","def","fences","heading","hr","html","lheading","list","newline","paragraph","table","text","re","Oe","Be","ae","D","W","ce","Ze","pe","ue","je","Fe","he","Qe","Ue","Ke","Xe","We","Je","Ve","q","Ye","ke","ge","et","J","_backpedal","anyPunctuation","autolink","blockSkip","br","del","emStrongLDelim","emStrongRDelimAst","emStrongRDelimUnd","escape","link","nolink","punctuation","reflink","reflinkSearch","tag","url","tt","j","nt","B","normal","P","st","fe","R","test","V","encodeURI","Y","o","c","split","trim","shift","length","pop","splice","push","A","charAt","slice","me","href","title","other","state","inLink","type","raw","tokens","inlineTokens","rules","space","block","codeBlockStyle","rt","match","map","join","lang","inline","depth","p","u","d","top","blockTokens","g","T","y","substring","ordered","start","loose","items","Z","repeat","trimStart","search","te","ne","se","xe","G","C","ee","task","checked","trimEnd","filter","some","pre","toLowerCase","header","align","rows","inRawBlock","de","indexOf","emStrong","lastIndex","index","codespan","inlineText","escaped","inlineQueue","links","create","lex","lexInline","src","startBlock","forEach","charCodeAt","console","error","Error","keys","includes","lastIndexOf","startInline","listitem","checkbox","unshift","tablecell","tablerow","strong","em","image","textRenderer","renderers","passThroughHooks","Set","preprocess","postprocess","processAllTokens","provideLexer","provideParser","parseMarkdown","concat","childTokens","flat","name","apply","level","has","Promise","then","onError","toString","all","catch","message","reject","M","$d349326c2b62c55f$exports","factory","entries","setPrototypeOf","isFrozen","getPrototypeOf","freeze","seal","construct","Reflect","fun","thisValue","args","Func","arrayForEach","unapply","Array","arrayLastIndexOf","arrayPop","arrayPush","arraySplice","stringToLowerCase","String","stringToString","stringMatch","stringReplace","stringIndexOf","stringTrim","objectHasOwnProperty","regExpTest","typeErrorCreate","func","TypeError","_len2","arguments","_key2","thisArg","_len","_key","addToSet","set","array","transformCaseFunc","undefined","element","lcElement","clone","object","newObject","property","isArray","cleanArray","lookupGetter","prop","desc","html$1","svg$1","svgFilters","svgDisallowed","mathMl$1","mathMlDisallowed","svg","mathMl","xml","MUSTACHE_EXPR","ERB_EXPR","TMPLIT_EXPR","DATA_ATTR","ARIA_ATTR","IS_ALLOWED_URI","IS_SCRIPT_OR_DATA","ATTR_WHITESPACE","DOCTYPE_NAME","EXPRESSIONS","__proto__","CUSTOM_ELEMENT","NODE_TYPE","progressingInstruction","comment","document","_createTrustedTypesPolicy","trustedTypes","purifyHostElement","createPolicy","suffix","ATTR_NAME","hasAttribute","getAttribute","policyName","createHTML","createScriptURL","scriptUrl","warn","_createHooksMap","afterSanitizeAttributes","afterSanitizeElements","afterSanitizeShadowDOM","beforeSanitizeAttributes","beforeSanitizeElements","beforeSanitizeShadowDOM","uponSanitizeAttribute","uponSanitizeElement","uponSanitizeShadowNode","createDOMPurify","trustedTypesPolicy","window1","window","DOMPurify","root","version","removed","nodeType","Element","isSupported","originalDocument","currentScript","DocumentFragment","HTMLTemplateElement","Node","NodeFilter","NamedNodeMap","MozNamedAttrMap","HTMLFormElement","DOMParser","ElementPrototype","cloneNode","remove","getNextSibling","getChildNodes","getParentNode","template","createElement","content","ownerDocument","emptyHTML","implementation","createNodeIterator","createDocumentFragment","getElementsByTagName","importNode","createHTMLDocument","IS_ALLOWED_URI$1","ALLOWED_TAGS","DEFAULT_ALLOWED_TAGS","ALLOWED_ATTR","DEFAULT_ALLOWED_ATTR","CUSTOM_ELEMENT_HANDLING","tagNameCheck","writable","configurable","attributeNameCheck","allowCustomizedBuiltInElements","FORBID_TAGS","FORBID_ATTR","ALLOW_ARIA_ATTR","ALLOW_DATA_ATTR","ALLOW_UNKNOWN_PROTOCOLS","ALLOW_SELF_CLOSE_IN_ATTR","SAFE_FOR_TEMPLATES","SAFE_FOR_XML","WHOLE_DOCUMENT","SET_CONFIG","FORCE_BODY","RETURN_DOM","RETURN_DOM_FRAGMENT","RETURN_TRUSTED_TYPE","SANITIZE_DOM","SANITIZE_NAMED_PROPS","KEEP_CONTENT","IN_PLACE","USE_PROFILES","FORBID_CONTENTS","DEFAULT_FORBID_CONTENTS","DATA_URI_TAGS","DEFAULT_DATA_URI_TAGS","URI_SAFE_ATTRIBUTES","DEFAULT_URI_SAFE_ATTRIBUTES","MATHML_NAMESPACE","SVG_NAMESPACE","HTML_NAMESPACE","NAMESPACE","IS_EMPTY_INPUT","ALLOWED_NAMESPACES","DEFAULT_ALLOWED_NAMESPACES","MATHML_TEXT_INTEGRATION_POINTS","HTML_INTEGRATION_POINTS","COMMON_SVG_AND_HTML_ELEMENTS","PARSER_MEDIA_TYPE","SUPPORTED_PARSER_MEDIA_TYPES","CONFIG","formElement","isRegexOrFunction","testValue","Function","_parseConfig","cfg","ADD_URI_SAFE_ATTR","ADD_DATA_URI_TAGS","ALLOWED_URI_REGEXP","ADD_TAGS","ADD_ATTR","tbody","TRUSTED_TYPES_POLICY","ALL_SVG_TAGS","ALL_MATHML_TAGS","_checkValidNamespace","parent","tagName","namespaceURI","parentTagName","Boolean","_forceRemove","node","removeChild","_removeAttribute","attribute","getAttributeNode","from","removeAttribute","setAttribute","_initDocument","dirty","doc","leadingWhitespace","matches","dirtyPayload","parseFromString","documentElement","createDocument","innerHTML","body","insertBefore","createTextNode","childNodes","_createNodeIterator","SHOW_ELEMENT","SHOW_COMMENT","SHOW_TEXT","SHOW_PROCESSING_INSTRUCTION","SHOW_CDATA_SECTION","_isClobbered","nodeName","textContent","attributes","hasChildNodes","_isNode","_executeHooks","currentNode","data","hook","_sanitizeElements","allowedTags","firstElementChild","_isBasicCustomElement","parentNode","childCount","childClone","__removalCount","expr","_isValidAttribute","lcTag","lcName","_sanitizeAttributes","hookEvent","attrName","attrValue","keepAttr","allowedAttributes","forceKeepAttr","SANITIZE_NAMED_PROPS_PREFIX","getAttributeType","setAttributeNS","_sanitizeShadowDOM","fragment","shadowNode","shadowIterator","nextNode","sanitize","importedNode","returnNode","appendChild","firstChild","nodeIterator","shadowroot","shadowrootmode","serializedHTML","outerHTML","doctype","setConfig","clearConfig","isValidAttribute","attr","addHook","entryPoint","hookFunction","removeHook","removeHooks","removeAllHooks","$e73bf42412feb220$var$chatContainer","getElementById","$e73bf42412feb220$var$messageForm","$e73bf42412feb220$var$userInput","$e73bf42412feb220$var$languageSelector","$e73bf42412feb220$var$createMessageBubble","sender","wrapper","className","bubble","classList","add","avatar","img","alt","setTimeout","$e73bf42412feb220$var$scrollToBottom","scrollTop","scrollHeight","$e73bf42412feb220$var$getAssistantResponse","userMessage","codeLanguage","response","fetch","method","headers","JSON","stringify","query","language","ok","json","reply","addEventListener","preventDefault","selectedLanguage","alert","style","height","$e73bf42412feb220$var$textarea","key","shiftKey","requestSubmit","marked_exports","__export","_Hooks","_Lexer","_Parser","_Renderer","_TextRenderer","_Tokenizer","_defaults","_getDefaults","__toCommonJS","changeDefaults","newDefaults","noopTest","edit","regex","opt","obj","val","valSource","bull","indent","blockCode","bullet","lheadingCore","lheadingGfm","_paragraph","blockText","_blockLabel","_tag","_comment","blockNormal","gfmTable","blockGfm","blockPedantic","inlineCode","_punctuation","_punctuationOrSpace","_notPunctuationOrSpace","_punctuationGfmStrongEm","_punctuationOrSpaceGfmStrongEm","_notPunctuationOrSpaceGfmStrongEm","emStrongLDelimCore","emStrongLDelimGfm","emStrongRDelimAstCore","emStrongRDelimAstGfm","_inlineComment","_inlineLabel","inlineNormal","inlinePedantic","inlineGfm","inlineBreaks","escapeReplacements","getEscapeReplacement","ch","encode","cleanUrl","splitCells","tableRow","count","row","offset","str","curr","cells","rtrim","invert","suffLen","currChar","findClosingBracket","outputLink","cap","token","matchIndentToCode","indentToCode","matchIndentInNode","indentInNode","trimmed","lines","inBlockquote","currentLines","currentRaw","currentText","lastToken","oldToken","newText","newToken","isordered","itemRegex","endsWithBlankLine","endEarly","itemContents","line","nextLine","rawLine","nextLineWithoutTabs","istask","ischecked","lastItem","spacers","hasMultipleLineBreaks","aligns","item","cell","trimmedUrl","rtrimSlash","lastParenIndex","linkLen","linkString","maskedSrc","prevChar","lLength","rDelim","rLength","delimTotal","midDelimTotal","endReg","lastCharLength","hasNonSpaceChars","hasSpaceCharsOnBothEnds","prevCapZero","__Lexer","next","lastParagraphClipped","extTokenizer","cutSrc","startIndex","tempSrc","tempStart","getStartIndex","errMsg","keepPrevChar","langString","startAttr","itemBody","cleanHref","out","__Parser","anyToken","genericToken","ret","textToken","markdown","callback","values","tableToken","listToken","pack","opts","ext","prevRenderer","extLevel","rendererProp","rendererFunc","tokenizerProp","tokenizerFunc","prevTokenizer","hooksProp","hooksFunc","prevHook","arg","packWalktokens","blockType","origOpt","throwError","msg","markedInstance","unconstruct","isPropertyExist","constructor","fallbackValue","cdataSection","entityReference","entityNode","documentType","documentFragment","notation","getGlobal","VERSION","TAGS","ATTRS","DEFAULT_PARSER_MEDIA_TYPE","initValue"],"version":3,"file":"front.83907146.js.map"}